// KASAN: use-after-free Read in tcp_connect
// https://syzkaller.appspot.com/bug?id=28f3c6f048653756fa6d137e67309ad83c7f2fde
// status:open
// autogenerated by syzkaller (http://github.com/google/syzkaller)

#define _GNU_SOURCE
#include <arpa/inet.h>
#include <endian.h>
#include <errno.h>
#include <errno.h>
#include <fcntl.h>
#include <linux/futex.h>
#include <linux/if.h>
#include <linux/if_ether.h>
#include <linux/if_tun.h>
#include <linux/ip.h>
#include <linux/tcp.h>
#include <net/if_arp.h>
#include <pthread.h>
#include <sched.h>
#include <signal.h>
#include <stdarg.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <unistd.h>

__attribute__((noreturn)) static void doexit(int status)
{
  volatile unsigned i;
  syscall(__NR_exit_group, status);
  for (i = 0;; i++) {
  }
}
#include <errno.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>

const int kFailStatus = 67;
const int kRetryStatus = 69;

static void fail(const char* msg, ...)
{
  int e = errno;
  va_list args;
  va_start(args, msg);
  vfprintf(stderr, msg, args);
  va_end(args);
  fprintf(stderr, " (errno %d)\n", e);
  doexit((e == ENOMEM || e == EAGAIN) ? kRetryStatus : kFailStatus);
}

static void vsnprintf_check(char* str, size_t size, const char* format,
                            va_list args)
{
  int rv;

  rv = vsnprintf(str, size, format, args);
  if (rv < 0)
    fail("tun: snprintf failed");
  if ((size_t)rv >= size)
    fail("tun: string '%s...' doesn't fit into buffer", str);
}

#define COMMAND_MAX_LEN 128
#define PATH_PREFIX                                                            \
  "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin "
#define PATH_PREFIX_LEN (sizeof(PATH_PREFIX) - 1)

static void execute_command(bool panic, const char* format, ...)
{
  va_list args;
  char command[PATH_PREFIX_LEN + COMMAND_MAX_LEN];
  int rv;

  va_start(args, format);
  memcpy(command, PATH_PREFIX, PATH_PREFIX_LEN);
  vsnprintf_check(command + PATH_PREFIX_LEN, COMMAND_MAX_LEN, format, args);
  va_end(args);
  rv = system(command);
  if (rv) {
    if (panic)
      fail("command '%s' failed: %d", &command[0], rv);
  }
}

#define DEV_IPV4 "172.20.20.%d"
#define DEV_IPV6 "fe80::%02hx"
#define DEV_MAC "aa:aa:aa:aa:aa:%02hx"

static void snprintf_check(char* str, size_t size, const char* format, ...)
{
  va_list args;

  va_start(args, format);
  vsnprintf_check(str, size, format, args);
  va_end(args);
}

static void initialize_netdevices(void)
{
  unsigned i;
  const char* devtypes[] = {"ip6gretap", "bridge", "vcan", "bond", "team"};
  const char* devnames[] = {"lo",
                            "sit0",
                            "bridge0",
                            "vcan0",
                            "tunl0",
                            "gre0",
                            "gretap0",
                            "ip_vti0",
                            "ip6_vti0",
                            "ip6tnl0",
                            "ip6gre0",
                            "ip6gretap0",
                            "erspan0",
                            "bond0",
                            "veth0",
                            "veth1",
                            "team0",
                            "veth0_to_bridge",
                            "veth1_to_bridge",
                            "veth0_to_bond",
                            "veth1_to_bond",
                            "veth0_to_team",
                            "veth1_to_team"};
  const char* devmasters[] = {"bridge", "bond", "team"};

  for (i = 0; i < sizeof(devtypes) / (sizeof(devtypes[0])); i++)
    execute_command(0, "ip link add dev %s0 type %s", devtypes[i], devtypes[i]);
  execute_command(0, "ip link add type veth");

  for (i = 0; i < sizeof(devmasters) / (sizeof(devmasters[0])); i++) {
    execute_command(
        0, "ip link add name %s_slave_0 type veth peer name veth0_to_%s",
        devmasters[i], devmasters[i]);
    execute_command(
        0, "ip link add name %s_slave_1 type veth peer name veth1_to_%s",
        devmasters[i], devmasters[i]);
    execute_command(0, "ip link set %s_slave_0 master %s0", devmasters[i],
                    devmasters[i]);
    execute_command(0, "ip link set %s_slave_1 master %s0", devmasters[i],
                    devmasters[i]);
    execute_command(0, "ip link set veth0_to_%s up", devmasters[i]);
    execute_command(0, "ip link set veth1_to_%s up", devmasters[i]);
  }
  execute_command(0, "ip link set bridge_slave_0 up");
  execute_command(0, "ip link set bridge_slave_1 up");

  for (i = 0; i < sizeof(devnames) / (sizeof(devnames[0])); i++) {
    char addr[32];
    snprintf_check(addr, sizeof(addr), DEV_IPV4, i + 10);
    execute_command(0, "ip -4 addr add %s/24 dev %s", addr, devnames[i]);
    snprintf_check(addr, sizeof(addr), DEV_IPV6, i + 10);
    execute_command(0, "ip -6 addr add %s/120 dev %s", addr, devnames[i]);
    snprintf_check(addr, sizeof(addr), DEV_MAC, i + 10);
    execute_command(0, "ip link set dev %s address %s", devnames[i], addr);
    execute_command(0, "ip link set dev %s up", devnames[i]);
  }
}

static void loop();

static void sandbox_common()
{
  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
  setpgrp();
  setsid();

  struct rlimit rlim;
  rlim.rlim_cur = rlim.rlim_max = 160 << 20;
  setrlimit(RLIMIT_AS, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 8 << 20;
  setrlimit(RLIMIT_MEMLOCK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 136 << 20;
  setrlimit(RLIMIT_FSIZE, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 1 << 20;
  setrlimit(RLIMIT_STACK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 0;
  setrlimit(RLIMIT_CORE, &rlim);

  if (unshare(CLONE_NEWNS)) {
  }
  if (unshare(CLONE_NEWIPC)) {
  }
  if (unshare(0x02000000)) {
  }
  if (unshare(CLONE_NEWUTS)) {
  }
  if (unshare(CLONE_SYSVSEM)) {
  }
}

static int do_sandbox_none(void)
{
  if (unshare(CLONE_NEWPID)) {
  }
  int pid = fork();
  if (pid < 0)
    fail("sandbox fork failed");
  if (pid)
    return pid;

  sandbox_common();
  if (unshare(CLONE_NEWNET)) {
  }
  initialize_netdevices();
  loop();
  doexit(1);
}

static void execute_one();
extern unsigned long long procid;

void loop()
{
  while (1) {
    execute_one();
  }
}

struct thread_t {
  int created, running, call;
  pthread_t th;
};

static struct thread_t threads[16];
static void execute_call(int call);
static int running;

static void* thr(void* arg)
{
  struct thread_t* th = (struct thread_t*)arg;
  for (;;) {
    while (!__atomic_load_n(&th->running, __ATOMIC_ACQUIRE))
      syscall(SYS_futex, &th->running, FUTEX_WAIT, 0, 0);
    execute_call(th->call);
    __atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
    __atomic_store_n(&th->running, 0, __ATOMIC_RELEASE);
    syscall(SYS_futex, &th->running, FUTEX_WAKE);
  }
  return 0;
}

static void execute(int num_calls)
{
  int call, thread;
  running = 0;
  for (call = 0; call < num_calls; call++) {
    for (thread = 0; thread < sizeof(threads) / sizeof(threads[0]); thread++) {
      struct thread_t* th = &threads[thread];
      if (!th->created) {
        th->created = 1;
        pthread_attr_t attr;
        pthread_attr_init(&attr);
        pthread_attr_setstacksize(&attr, 128 << 10);
        pthread_create(&th->th, &attr, thr, th);
      }
      if (!__atomic_load_n(&th->running, __ATOMIC_ACQUIRE)) {
        th->call = call;
        __atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
        __atomic_store_n(&th->running, 1, __ATOMIC_RELEASE);
        syscall(SYS_futex, &th->running, FUTEX_WAKE);
        struct timespec ts;
        ts.tv_sec = 0;
        ts.tv_nsec = 20 * 1000 * 1000;
        syscall(SYS_futex, &th->running, FUTEX_WAIT, 1, &ts);
        if (running)
          usleep((call == num_calls - 1) ? 10000 : 1000);
        break;
      }
    }
  }
}

uint64_t r[1] = {0xffffffffffffffff};
void execute_call(int call)
{
  long res;
  switch (call) {
  case 0:
    res = syscall(__NR_socket, 2, 1, 0);
    if (res != -1)
      r[0] = res;
    break;
  case 1:
    *(uint16_t*)0x20516ff0 = 2;
    *(uint16_t*)0x20516ff2 = htobe16(0x4e21);
    *(uint32_t*)0x20516ff4 = htobe32(0xe0000001);
    *(uint8_t*)0x20516ff8 = 0;
    *(uint8_t*)0x20516ff9 = 0;
    *(uint8_t*)0x20516ffa = 0;
    *(uint8_t*)0x20516ffb = 0;
    *(uint8_t*)0x20516ffc = 0;
    *(uint8_t*)0x20516ffd = 0;
    *(uint8_t*)0x20516ffe = 0;
    *(uint8_t*)0x20516fff = 0;
    syscall(__NR_bind, r[0], 0x20516ff0, 0x10);
    break;
  case 2:
    *(uint16_t*)0x20385ff0 = 2;
    *(uint16_t*)0x20385ff2 = htobe16(0x4e21);
    *(uint32_t*)0x20385ff4 = htobe32(0x7f000001);
    *(uint8_t*)0x20385ff8 = 0;
    *(uint8_t*)0x20385ff9 = 0;
    *(uint8_t*)0x20385ffa = 0;
    *(uint8_t*)0x20385ffb = 0;
    *(uint8_t*)0x20385ffc = 0;
    *(uint8_t*)0x20385ffd = 0;
    *(uint8_t*)0x20385ffe = 0;
    *(uint8_t*)0x20385fff = 0;
    syscall(__NR_sendto, r[0], 0x20588fff, 0xfffffffffffffe98, 0x20020003,
            0x20385ff0, 0x10);
    break;
  case 3:
    *(uint64_t*)0x20000c40 = 0x200001c0;
    *(uint16_t*)0x200001c0 = 0x27;
    *(uint32_t*)0x200001c4 = 0;
    *(uint32_t*)0x200001c8 = 0;
    *(uint32_t*)0x200001cc = 1;
    *(uint8_t*)0x200001d0 = 5;
    *(uint8_t*)0x200001d1 = 3;
    memcpy((void*)0x200001d2,
           "\x30\xd0\x6e\x99\x73\x45\xfe\x1a\xa8\x8c\x3f\xaf\x19\x5a\x6b\x38"
           "\xe7\xac\xa6\x72\x8d\xb1\xf5\x74\xf1\x45\xde\x08\x18\xc3\x04\x42"
           "\xf3\x30\x81\xc3\xd4\xc9\x3b\x0e\x88\x4e\xd4\xd3\xe0\x7c\x1a\xae"
           "\xfc\xd8\x64\xb1\xc9\xac\x05\xf7\x27\xa0\x68\x2d\x25\xe9\x31",
           63);
    *(uint64_t*)0x20000218 = 0xb;
    *(uint32_t*)0x20000c48 = 0x60;
    *(uint64_t*)0x20000c50 = 0x20000440;
    *(uint64_t*)0x20000440 = 0x20000240;
    *(uint64_t*)0x20000448 = 0;
    *(uint64_t*)0x20000450 = 0x20000280;
    *(uint64_t*)0x20000458 = 0;
    *(uint64_t*)0x20000460 = 0x20000380;
    memcpy((void*)0x20000380,
           "\xb8\xe4\x1c\x20\xe7\x6b\x2b\xaa\xde\xdd\x2f\x51\xe8\x7f\x23\xb1"
           "\x31\x7f\x4e\xaa\x19\xc0\x4c\xc9\x8a\x9a\xf3\x27\xe4\x22\x9a\xf5"
           "\xcf\xe3\x16\x84\x01\x5a\x58\xcc\xcc\x42\xb3\xed\xb4\x3c\x97\xe0"
           "\x4d\x5f\xa0\x0f\x21\x2b\xd7\x07\x31\xa3\x07\x44\x4d\x13\xfc\x02"
           "\xcf\xba\x9f\x8c\x5e\x4d\xf8\x23\xcc\x3f\x61\x08\xb1\x3b\xe0\xcd"
           "\x7d\x7e\x20\xe0\x1f\xc4\x8f\x01\xff\x89\xa4\x6f\xea\x9a\x5c\x66"
           "\x6a\xd1\x98\xc3\xd2\xec\xae\x53\xc1\x6a\x53\x96\x84\xa2\x85\x45"
           "\xa4\xa4\x0b\x74\x3d\x2d\xd7\x82\x33\x8a\x8e\x46\x80\xcb\x91\xe1"
           "\x37\x86\x3e\x45\x92\xc2\x8a\xc7\xb8\xfd\x76\x8f\xf9\x4e\xcf\xa6"
           "\x49\xbb\x97\xc9\x35\xac\x0c\xca\x76\x9f\x4c\x80\xfd\x9f",
           158);
    *(uint64_t*)0x20000468 = 0x9e;
    *(uint64_t*)0x20000c58 = 3;
    *(uint64_t*)0x20000c60 = 0x20000480;
    *(uint64_t*)0x20000480 = 0x10;
    *(uint32_t*)0x20000488 = 0;
    *(uint32_t*)0x2000048c = 5;
    *(uint64_t*)0x20000c68 = 0x10;
    *(uint32_t*)0x20000c70 = 0x40;
    *(uint64_t*)0x20000c78 = 0x200004c0;
    *(uint16_t*)0x200004c0 = 0x27;
    *(uint32_t*)0x200004c4 = 1;
    *(uint32_t*)0x200004c8 = 0;
    *(uint32_t*)0x200004cc = 2;
    *(uint8_t*)0x200004d0 = 1;
    *(uint8_t*)0x200004d1 = 5;
    memcpy((void*)0x200004d2,
           "\xd1\xff\xb6\x1d\x3b\x31\x55\xb4\xf9\x3c\xb7\x1c\x25\xa7\x3a\x18"
           "\x14\x5e\xdc\x68\x0e\xcb\x4a\xc3\x6b\xb8\x47\x02\xa8\x47\xa3\x9a"
           "\x7d\x8f\xbb\xb2\x0d\xf2\x4b\x2c\x0e\x4a\xb9\xbb\x32\x20\x7b\x2f"
           "\xcf\x5f\x23\x97\xc6\xba\x5b\x50\x37\xce\x3d\xa1\x59\x5b\x4a",
           63);
    *(uint64_t*)0x20000518 = 0x30;
    *(uint32_t*)0x20000c80 = 0x60;
    *(uint64_t*)0x20000c88 = 0x20000640;
    *(uint64_t*)0x20000640 = 0x20000540;
    *(uint64_t*)0x20000648 = 0;
    *(uint64_t*)0x20000650 = 0x20000600;
    *(uint64_t*)0x20000658 = 0;
    *(uint64_t*)0x20000c90 = 2;
    *(uint64_t*)0x20000c98 = 0x20000680;
    *(uint64_t*)0x20000680 = 0x10;
    *(uint32_t*)0x20000688 = 0;
    *(uint32_t*)0x2000068c = 0xffffeb95;
    *(uint64_t*)0x20000ca0 = 0x10;
    *(uint32_t*)0x20000ca8 = 1;
    *(uint64_t*)0x20000cb0 = 0x20000740;
    *(uint16_t*)0x20000740 = 0x27;
    *(uint32_t*)0x20000744 = 0;
    *(uint32_t*)0x20000748 = 0;
    *(uint32_t*)0x2000074c = 3;
    *(uint8_t*)0x20000750 = -1;
    *(uint8_t*)0x20000751 = 0;
    memcpy((void*)0x20000752,
           "\xfd\x4b\xca\xea\x7b\xec\x9c\xe1\xb0\xf2\x1f\xa8\x16\x60\x7b\x2d"
           "\x64\xd0\x55\x32\x6e\x6d\x83\xe6\xc0\x33\xc1\x14\x88\x8a\xa0\xe3"
           "\xbb\xdf\x0b\x80\x4b\xd4\x18\x32\x5a\xfb\xe3\x40\x28\xf4\x01\xe6"
           "\x3d\xac\x21\xdb\xe8\x97\xad\xc5\x03\xc4\x62\xba\x2b\xde\x69",
           63);
    *(uint64_t*)0x20000798 = 0x2a;
    *(uint32_t*)0x20000cb8 = 0x60;
    *(uint64_t*)0x20000cc0 = 0x20000980;
    *(uint64_t*)0x20000980 = 0x200007c0;
    *(uint64_t*)0x20000988 = 0;
    *(uint64_t*)0x20000990 = 0x20000880;
    *(uint64_t*)0x20000998 = 0;
    *(uint64_t*)0x20000cc8 = 2;
    *(uint64_t*)0x20000cd0 = 0;
    *(uint64_t*)0x20000cd8 = 0;
    *(uint32_t*)0x20000ce0 = 0;
    *(uint64_t*)0x20000ce8 = 0x200009c0;
    *(uint16_t*)0x200009c0 = 0x27;
    *(uint32_t*)0x200009c4 = 1;
    *(uint32_t*)0x200009c8 = 0;
    *(uint32_t*)0x200009cc = 4;
    *(uint8_t*)0x200009d0 = 3;
    *(uint8_t*)0x200009d1 = 0x13;
    memcpy((void*)0x200009d2,
           "\xe6\xcd\xff\x1d\xa7\xe0\x10\xef\x3c\x1a\x9d\xfb\x17\xa3\x6e\xdd"
           "\xe1\xc5\xdc\x81\x26\xfa\xbc\xde\x96\x94\xed\x46\x56\x6c\xfc\x1e"
           "\x3e\xb5\xa6\xad\xae\x12\x44\xed\x17\x55\x0e\xdf\xd8\x4e\x57\x9b"
           "\x52\x3e\x93\x0b\x7f\xc9\xbd\xb8\x9d\xae\x43\xf5\x8c\x63\x45",
           63);
    *(uint64_t*)0x20000a18 = 0x15;
    *(uint32_t*)0x20000cf0 = 0x60;
    *(uint64_t*)0x20000cf8 = 0x20000bc0;
    *(uint64_t*)0x20000bc0 = 0x20000a40;
    *(uint64_t*)0x20000bc8 = 0;
    *(uint64_t*)0x20000bd0 = 0x20000ac0;
    *(uint64_t*)0x20000bd8 = 0;
    *(uint64_t*)0x20000be0 = 0x20000b40;
    *(uint64_t*)0x20000be8 = 0;
    *(uint64_t*)0x20000d00 = 3;
    *(uint64_t*)0x20000d08 = 0x20000c00;
    *(uint64_t*)0x20000c00 = 0x10;
    *(uint32_t*)0x20000c08 = 0x112;
    *(uint32_t*)0x20000c0c = 0x7a4;
    *(uint64_t*)0x20000d10 = 0x10;
    *(uint32_t*)0x20000d18 = 0x84;
    syscall(__NR_sendmmsg, r[0], 0x20000c40, 4, 0x8000);
    break;
  case 4:
    *(uint16_t*)0x203cd000 = 0;
    *(uint8_t*)0x203cd002 = 0;
    *(uint8_t*)0x203cd003 = 0;
    *(uint8_t*)0x203cd004 = 0;
    *(uint8_t*)0x203cd005 = 0;
    *(uint8_t*)0x203cd006 = 0;
    *(uint8_t*)0x203cd007 = 0;
    syscall(__NR_connect, r[0], 0x203cd000, 0x10);
    break;
  case 5:
    *(uint16_t*)0x20000000 = 2;
    *(uint16_t*)0x20000002 = htobe16(0);
    *(uint8_t*)0x20000004 = 0xac;
    *(uint8_t*)0x20000005 = 0x14;
    *(uint8_t*)0x20000006 = 0x14;
    *(uint8_t*)0x20000007 = 0xbb;
    *(uint8_t*)0x20000008 = 0;
    *(uint8_t*)0x20000009 = 0;
    *(uint8_t*)0x2000000a = 0;
    *(uint8_t*)0x2000000b = 0;
    *(uint8_t*)0x2000000c = 0;
    *(uint8_t*)0x2000000d = 0;
    *(uint8_t*)0x2000000e = 0;
    *(uint8_t*)0x2000000f = 0;
    syscall(__NR_connect, r[0], 0x20000000, 0x10);
    break;
  }
}

void execute_one()
{
  execute(6);
}

int main()
{
  syscall(__NR_mmap, 0x20000000, 0x1000000, 3, 0x32, -1, 0);
  for (;;) {
    int pid = do_sandbox_none();
    int status = 0;
    while (waitpid(pid, &status, __WALL) != pid) {
    }
  }
}
