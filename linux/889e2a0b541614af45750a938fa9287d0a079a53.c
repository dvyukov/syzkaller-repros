// general protection fault in perf_iterate_sb
// https://syzkaller.appspot.com/bug?id=889e2a0b541614af45750a938fa9287d0a079a53
// status:open
// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <arpa/inet.h>
#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <net/if.h>
#include <net/if_arp.h>
#include <netinet/in.h>
#include <pthread.h>
#include <sched.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#include <linux/capability.h>
#include <linux/futex.h>
#include <linux/if_addr.h>
#include <linux/if_ether.h>
#include <linux/if_link.h>
#include <linux/if_tun.h>
#include <linux/in6.h>
#include <linux/ip.h>
#include <linux/neighbour.h>
#include <linux/net.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/tcp.h>
#include <linux/veth.h>

unsigned long long procid;

static __thread int skip_segv;
static __thread jmp_buf segv_env;

static void segv_handler(int sig, siginfo_t* info, void* ctx)
{
  uintptr_t addr = (uintptr_t)info->si_addr;
  const uintptr_t prog_start = 1 << 20;
  const uintptr_t prog_end = 100 << 20;
  if (__atomic_load_n(&skip_segv, __ATOMIC_RELAXED) &&
      (addr < prog_start || addr > prog_end)) {
    _longjmp(segv_env, 1);
  }
  exit(sig);
}

static void install_segv_handler(void)
{
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  syscall(SYS_rt_sigaction, 0x20, &sa, NULL, 8);
  syscall(SYS_rt_sigaction, 0x21, &sa, NULL, 8);
  memset(&sa, 0, sizeof(sa));
  sa.sa_sigaction = segv_handler;
  sa.sa_flags = SA_NODEFER | SA_SIGINFO;
  sigaction(SIGSEGV, &sa, NULL);
  sigaction(SIGBUS, &sa, NULL);
}

#define NONFAILING(...)                                                        \
  {                                                                            \
    __atomic_fetch_add(&skip_segv, 1, __ATOMIC_SEQ_CST);                       \
    if (_setjmp(segv_env) == 0) {                                              \
      __VA_ARGS__;                                                             \
    }                                                                          \
    __atomic_fetch_sub(&skip_segv, 1, __ATOMIC_SEQ_CST);                       \
  }

static void sleep_ms(uint64_t ms)
{
  usleep(ms * 1000);
}

static uint64_t current_time_ms(void)
{
  struct timespec ts;
  if (clock_gettime(CLOCK_MONOTONIC, &ts))
    exit(1);
  return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}

static void use_temporary_dir(void)
{
  char tmpdir_template[] = "./syzkaller.XXXXXX";
  char* tmpdir = mkdtemp(tmpdir_template);
  if (!tmpdir)
    exit(1);
  if (chmod(tmpdir, 0777))
    exit(1);
  if (chdir(tmpdir))
    exit(1);
}

static void thread_start(void* (*fn)(void*), void* arg)
{
  pthread_t th;
  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 128 << 10);
  int i;
  for (i = 0; i < 100; i++) {
    if (pthread_create(&th, &attr, fn, arg) == 0) {
      pthread_attr_destroy(&attr);
      return;
    }
    if (errno == EAGAIN) {
      usleep(50);
      continue;
    }
    break;
  }
  exit(1);
}

#define BITMASK(bf_off, bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
#define STORE_BY_BITMASK(type, htobe, addr, val, bf_off, bf_len)               \
  *(type*)(addr) =                                                             \
      htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) |           \
            (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))

typedef struct {
  int state;
} event_t;

static void event_init(event_t* ev)
{
  ev->state = 0;
}

static void event_reset(event_t* ev)
{
  ev->state = 0;
}

static void event_set(event_t* ev)
{
  if (ev->state)
    exit(1);
  __atomic_store_n(&ev->state, 1, __ATOMIC_RELEASE);
  syscall(SYS_futex, &ev->state, FUTEX_WAKE | FUTEX_PRIVATE_FLAG);
}

static void event_wait(event_t* ev)
{
  while (!__atomic_load_n(&ev->state, __ATOMIC_ACQUIRE))
    syscall(SYS_futex, &ev->state, FUTEX_WAIT | FUTEX_PRIVATE_FLAG, 0, 0);
}

static int event_isset(event_t* ev)
{
  return __atomic_load_n(&ev->state, __ATOMIC_ACQUIRE);
}

static int event_timedwait(event_t* ev, uint64_t timeout)
{
  uint64_t start = current_time_ms();
  uint64_t now = start;
  for (;;) {
    uint64_t remain = timeout - (now - start);
    struct timespec ts;
    ts.tv_sec = remain / 1000;
    ts.tv_nsec = (remain % 1000) * 1000 * 1000;
    syscall(SYS_futex, &ev->state, FUTEX_WAIT | FUTEX_PRIVATE_FLAG, 0, &ts);
    if (__atomic_load_n(&ev->state, __ATOMIC_RELAXED))
      return 1;
    now = current_time_ms();
    if (now - start > timeout)
      return 0;
  }
}

static bool write_file(const char* file, const char* what, ...)
{
  char buf[1024];
  va_list args;
  va_start(args, what);
  vsnprintf(buf, sizeof(buf), what, args);
  va_end(args);
  buf[sizeof(buf) - 1] = 0;
  int len = strlen(buf);
  int fd = open(file, O_WRONLY | O_CLOEXEC);
  if (fd == -1)
    return false;
  if (write(fd, buf, len) != len) {
    int err = errno;
    close(fd);
    errno = err;
    return false;
  }
  close(fd);
  return true;
}

static struct {
  char* pos;
  int nesting;
  struct nlattr* nested[8];
  char buf[1024];
} nlmsg;

static void netlink_init(int typ, int flags, const void* data, int size)
{
  memset(&nlmsg, 0, sizeof(nlmsg));
  struct nlmsghdr* hdr = (struct nlmsghdr*)nlmsg.buf;
  hdr->nlmsg_type = typ;
  hdr->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | flags;
  memcpy(hdr + 1, data, size);
  nlmsg.pos = (char*)(hdr + 1) + NLMSG_ALIGN(size);
}

static void netlink_attr(int typ, const void* data, int size)
{
  struct nlattr* attr = (struct nlattr*)nlmsg.pos;
  attr->nla_len = sizeof(*attr) + size;
  attr->nla_type = typ;
  memcpy(attr + 1, data, size);
  nlmsg.pos += NLMSG_ALIGN(attr->nla_len);
}

static void netlink_nest(int typ)
{
  struct nlattr* attr = (struct nlattr*)nlmsg.pos;
  attr->nla_type = typ;
  nlmsg.pos += sizeof(*attr);
  nlmsg.nested[nlmsg.nesting++] = attr;
}

static void netlink_done(void)
{
  struct nlattr* attr = nlmsg.nested[--nlmsg.nesting];
  attr->nla_len = nlmsg.pos - (char*)attr;
}

static int netlink_send(int sock)
{
  if (nlmsg.pos > nlmsg.buf + sizeof(nlmsg.buf) || nlmsg.nesting)
    exit(1);
  struct nlmsghdr* hdr = (struct nlmsghdr*)nlmsg.buf;
  hdr->nlmsg_len = nlmsg.pos - nlmsg.buf;
  struct sockaddr_nl addr;
  memset(&addr, 0, sizeof(addr));
  addr.nl_family = AF_NETLINK;
  unsigned n = sendto(sock, nlmsg.buf, hdr->nlmsg_len, 0,
                      (struct sockaddr*)&addr, sizeof(addr));
  if (n != hdr->nlmsg_len)
    exit(1);
  n = recv(sock, nlmsg.buf, sizeof(nlmsg.buf), 0);
  if (n < sizeof(struct nlmsghdr) + sizeof(struct nlmsgerr))
    exit(1);
  if (hdr->nlmsg_type != NLMSG_ERROR)
    exit(1);
  return -((struct nlmsgerr*)(hdr + 1))->error;
}

static void netlink_add_device_impl(const char* type, const char* name)
{
  struct ifinfomsg hdr;
  memset(&hdr, 0, sizeof(hdr));
  netlink_init(RTM_NEWLINK, NLM_F_EXCL | NLM_F_CREATE, &hdr, sizeof(hdr));
  if (name)
    netlink_attr(IFLA_IFNAME, name, strlen(name));
  netlink_nest(IFLA_LINKINFO);
  netlink_attr(IFLA_INFO_KIND, type, strlen(type));
}

static void netlink_add_device(int sock, const char* type, const char* name)
{
  netlink_add_device_impl(type, name);
  netlink_done();
  int err = netlink_send(sock);
  (void)err;
}

static void netlink_add_veth(int sock, const char* name, const char* peer)
{
  netlink_add_device_impl("veth", name);
  netlink_nest(IFLA_INFO_DATA);
  netlink_nest(VETH_INFO_PEER);
  nlmsg.pos += sizeof(struct ifinfomsg);
  netlink_attr(IFLA_IFNAME, peer, strlen(peer));
  netlink_done();
  netlink_done();
  netlink_done();
  int err = netlink_send(sock);
  (void)err;
}

static void netlink_add_hsr(int sock, const char* name, const char* slave1,
                            const char* slave2)
{
  netlink_add_device_impl("hsr", name);
  netlink_nest(IFLA_INFO_DATA);
  int ifindex1 = if_nametoindex(slave1);
  netlink_attr(IFLA_HSR_SLAVE1, &ifindex1, sizeof(ifindex1));
  int ifindex2 = if_nametoindex(slave2);
  netlink_attr(IFLA_HSR_SLAVE2, &ifindex2, sizeof(ifindex2));
  netlink_done();
  netlink_done();
  int err = netlink_send(sock);
  (void)err;
}

static void netlink_device_change(int sock, const char* name, bool up,
                                  const char* master, const void* mac,
                                  int macsize)
{
  struct ifinfomsg hdr;
  memset(&hdr, 0, sizeof(hdr));
  if (up)
    hdr.ifi_flags = hdr.ifi_change = IFF_UP;
  netlink_init(RTM_NEWLINK, 0, &hdr, sizeof(hdr));
  netlink_attr(IFLA_IFNAME, name, strlen(name));
  if (master) {
    int ifindex = if_nametoindex(master);
    netlink_attr(IFLA_MASTER, &ifindex, sizeof(ifindex));
  }
  if (macsize)
    netlink_attr(IFLA_ADDRESS, mac, macsize);
  int err = netlink_send(sock);
  (void)err;
}

static int netlink_add_addr(int sock, const char* dev, const void* addr,
                            int addrsize)
{
  struct ifaddrmsg hdr;
  memset(&hdr, 0, sizeof(hdr));
  hdr.ifa_family = addrsize == 4 ? AF_INET : AF_INET6;
  hdr.ifa_prefixlen = addrsize == 4 ? 24 : 120;
  hdr.ifa_scope = RT_SCOPE_UNIVERSE;
  hdr.ifa_index = if_nametoindex(dev);
  netlink_init(RTM_NEWADDR, NLM_F_CREATE | NLM_F_REPLACE, &hdr, sizeof(hdr));
  netlink_attr(IFA_LOCAL, addr, addrsize);
  netlink_attr(IFA_ADDRESS, addr, addrsize);
  return netlink_send(sock);
}

static void netlink_add_addr4(int sock, const char* dev, const char* addr)
{
  struct in_addr in_addr;
  inet_pton(AF_INET, addr, &in_addr);
  int err = netlink_add_addr(sock, dev, &in_addr, sizeof(in_addr));
  (void)err;
}

static void netlink_add_addr6(int sock, const char* dev, const char* addr)
{
  struct in6_addr in6_addr;
  inet_pton(AF_INET6, addr, &in6_addr);
  int err = netlink_add_addr(sock, dev, &in6_addr, sizeof(in6_addr));
  (void)err;
}

static void netlink_add_neigh(int sock, const char* name, const void* addr,
                              int addrsize, const void* mac, int macsize)
{
  struct ndmsg hdr;
  memset(&hdr, 0, sizeof(hdr));
  hdr.ndm_family = addrsize == 4 ? AF_INET : AF_INET6;
  hdr.ndm_ifindex = if_nametoindex(name);
  hdr.ndm_state = NUD_PERMANENT;
  netlink_init(RTM_NEWNEIGH, NLM_F_EXCL | NLM_F_CREATE, &hdr, sizeof(hdr));
  netlink_attr(NDA_DST, addr, addrsize);
  netlink_attr(NDA_LLADDR, mac, macsize);
  int err = netlink_send(sock);
  (void)err;
}

static int tunfd = -1;
static int tun_frags_enabled;
#define SYZ_TUN_MAX_PACKET_SIZE 1000

#define TUN_IFACE "syz_tun"

#define LOCAL_MAC 0xaaaaaaaaaaaa
#define REMOTE_MAC 0xaaaaaaaaaabb

#define LOCAL_IPV4 "172.20.20.170"
#define REMOTE_IPV4 "172.20.20.187"

#define LOCAL_IPV6 "fe80::aa"
#define REMOTE_IPV6 "fe80::bb"

#define IFF_NAPI 0x0010
#define IFF_NAPI_FRAGS 0x0020

static void initialize_tun(void)
{
  tunfd = open("/dev/net/tun", O_RDWR | O_NONBLOCK);
  if (tunfd == -1) {
    printf("tun: can't open /dev/net/tun: please enable CONFIG_TUN=y\n");
    printf("otherwise fuzzing or reproducing might not work as intended\n");
    return;
  }
  const int kTunFd = 240;
  if (dup2(tunfd, kTunFd) < 0)
    exit(1);
  close(tunfd);
  tunfd = kTunFd;
  struct ifreq ifr;
  memset(&ifr, 0, sizeof(ifr));
  strncpy(ifr.ifr_name, TUN_IFACE, IFNAMSIZ);
  ifr.ifr_flags = IFF_TAP | IFF_NO_PI | IFF_NAPI | IFF_NAPI_FRAGS;
  if (ioctl(tunfd, TUNSETIFF, (void*)&ifr) < 0) {
    ifr.ifr_flags = IFF_TAP | IFF_NO_PI;
    if (ioctl(tunfd, TUNSETIFF, (void*)&ifr) < 0)
      exit(1);
  }
  if (ioctl(tunfd, TUNGETIFF, (void*)&ifr) < 0)
    exit(1);
  tun_frags_enabled = (ifr.ifr_flags & IFF_NAPI_FRAGS) != 0;
  char sysctl[64];
  sprintf(sysctl, "/proc/sys/net/ipv6/conf/%s/accept_dad", TUN_IFACE);
  write_file(sysctl, "0");
  sprintf(sysctl, "/proc/sys/net/ipv6/conf/%s/router_solicitations", TUN_IFACE);
  write_file(sysctl, "0");
  int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
  if (sock == -1)
    exit(1);
  netlink_add_addr4(sock, TUN_IFACE, LOCAL_IPV4);
  netlink_add_addr6(sock, TUN_IFACE, LOCAL_IPV6);
  uint64_t macaddr = REMOTE_MAC;
  struct in_addr in_addr;
  inet_pton(AF_INET, REMOTE_IPV4, &in_addr);
  netlink_add_neigh(sock, TUN_IFACE, &in_addr, sizeof(in_addr), &macaddr,
                    ETH_ALEN);
  struct in6_addr in6_addr;
  inet_pton(AF_INET6, REMOTE_IPV6, &in6_addr);
  netlink_add_neigh(sock, TUN_IFACE, &in6_addr, sizeof(in6_addr), &macaddr,
                    ETH_ALEN);
  macaddr = LOCAL_MAC;
  netlink_device_change(sock, TUN_IFACE, true, 0, &macaddr, ETH_ALEN);
  close(sock);
}

#define DEV_IPV4 "172.20.20.%d"
#define DEV_IPV6 "fe80::%02x"
#define DEV_MAC 0x00aaaaaaaaaa
static void initialize_netdevices(void)
{
  char netdevsim[16];
  sprintf(netdevsim, "netdevsim%d", (int)procid);
  struct {
    const char* type;
    const char* dev;
  } devtypes[] = {
      {"ip6gretap", "ip6gretap0"}, {"bridge", "bridge0"},
      {"vcan", "vcan0"},           {"bond", "bond0"},
      {"team", "team0"},           {"dummy", "dummy0"},
      {"nlmon", "nlmon0"},         {"caif", "caif0"},
      {"batadv", "batadv0"},       {"vxcan", "vxcan1"},
      {"netdevsim", netdevsim},    {"veth", 0},
  };
  const char* devmasters[] = {"bridge", "bond", "team"};
  struct {
    const char* name;
    int macsize;
    bool noipv6;
  } devices[] = {
      {"lo", ETH_ALEN},
      {"sit0", 0},
      {"bridge0", ETH_ALEN},
      {"vcan0", 0, true},
      {"tunl0", 0},
      {"gre0", 0},
      {"gretap0", ETH_ALEN},
      {"ip_vti0", 0},
      {"ip6_vti0", 0},
      {"ip6tnl0", 0},
      {"ip6gre0", 0},
      {"ip6gretap0", ETH_ALEN},
      {"erspan0", ETH_ALEN},
      {"bond0", ETH_ALEN},
      {"veth0", ETH_ALEN},
      {"veth1", ETH_ALEN},
      {"team0", ETH_ALEN},
      {"veth0_to_bridge", ETH_ALEN},
      {"veth1_to_bridge", ETH_ALEN},
      {"veth0_to_bond", ETH_ALEN},
      {"veth1_to_bond", ETH_ALEN},
      {"veth0_to_team", ETH_ALEN},
      {"veth1_to_team", ETH_ALEN},
      {"veth0_to_hsr", ETH_ALEN},
      {"veth1_to_hsr", ETH_ALEN},
      {"hsr0", 0},
      {"dummy0", ETH_ALEN},
      {"nlmon0", 0},
      {"vxcan1", 0, true},
      {"caif0", ETH_ALEN},
      {"batadv0", ETH_ALEN},
      {netdevsim, ETH_ALEN},
  };
  int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
  if (sock == -1)
    exit(1);
  unsigned i;
  for (i = 0; i < sizeof(devtypes) / sizeof(devtypes[0]); i++)
    netlink_add_device(sock, devtypes[i].type, devtypes[i].dev);
  for (i = 0; i < sizeof(devmasters) / (sizeof(devmasters[0])); i++) {
    char master[32], slave0[32], veth0[32], slave1[32], veth1[32];
    sprintf(slave0, "%s_slave_0", devmasters[i]);
    sprintf(veth0, "veth0_to_%s", devmasters[i]);
    netlink_add_veth(sock, slave0, veth0);
    sprintf(slave1, "%s_slave_1", devmasters[i]);
    sprintf(veth1, "veth1_to_%s", devmasters[i]);
    netlink_add_veth(sock, slave1, veth1);
    sprintf(master, "%s0", devmasters[i]);
    netlink_device_change(sock, slave0, false, master, 0, 0);
    netlink_device_change(sock, slave1, false, master, 0, 0);
  }
  netlink_device_change(sock, "bridge_slave_0", true, 0, 0, 0);
  netlink_device_change(sock, "bridge_slave_1", true, 0, 0, 0);
  netlink_add_veth(sock, "hsr_slave_0", "veth0_to_hsr");
  netlink_add_veth(sock, "hsr_slave_1", "veth1_to_hsr");
  netlink_add_hsr(sock, "hsr0", "hsr_slave_0", "hsr_slave_1");
  netlink_device_change(sock, "hsr_slave_0", true, 0, 0, 0);
  netlink_device_change(sock, "hsr_slave_1", true, 0, 0, 0);
  for (i = 0; i < sizeof(devices) / (sizeof(devices[0])); i++) {
    char addr[32];
    sprintf(addr, DEV_IPV4, i + 10);
    netlink_add_addr4(sock, devices[i].name, addr);
    if (!devices[i].noipv6) {
      sprintf(addr, DEV_IPV6, i + 10);
      netlink_add_addr6(sock, devices[i].name, addr);
    }
    uint64_t macaddr = DEV_MAC + ((i + 10ull) << 40);
    netlink_device_change(sock, devices[i].name, true, 0, &macaddr,
                          devices[i].macsize);
  }
  close(sock);
}
static void initialize_netdevices_init(void)
{
  int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
  if (sock == -1)
    exit(1);
  struct {
    const char* type;
    int macsize;
    bool noipv6;
    bool noup;
  } devtypes[] = {
      {"nr", 7, true},
      {"rose", 5, true, true},
  };
  unsigned i;
  for (i = 0; i < sizeof(devtypes) / sizeof(devtypes[0]); i++) {
    char dev[32], addr[32];
    sprintf(dev, "%s%d", devtypes[i].type, (int)procid);
    sprintf(addr, "172.30.%d.%d", i, (int)procid + 1);
    netlink_add_addr4(sock, dev, addr);
    if (!devtypes[i].noipv6) {
      sprintf(addr, "fe88::%02x:%02x", i, (int)procid + 1);
      netlink_add_addr6(sock, dev, addr);
    }
    int macsize = devtypes[i].macsize;
    uint64_t macaddr = 0xbbbbbb +
                       ((unsigned long long)i << (8 * (macsize - 2))) +
                       (procid << (8 * (macsize - 1)));
    netlink_device_change(sock, dev, !devtypes[i].noup, 0, &macaddr, macsize);
  }
  close(sock);
}

static int read_tun(char* data, int size)
{
  if (tunfd < 0)
    return -1;
  int rv = read(tunfd, data, size);
  if (rv < 0) {
    if (errno == EAGAIN)
      return -1;
    if (errno == EBADFD)
      return -1;
    exit(1);
  }
  return rv;
}

static void flush_tun()
{
  char data[SYZ_TUN_MAX_PACKET_SIZE];
  while (read_tun(&data[0], sizeof(data)) != -1) {
  }
}

static long syz_open_dev(volatile long a0, volatile long a1, volatile long a2)
{
  if (a0 == 0xc || a0 == 0xb) {
    char buf[128];
    sprintf(buf, "/dev/%s/%d:%d", a0 == 0xc ? "char" : "block", (uint8_t)a1,
            (uint8_t)a2);
    return open(buf, O_RDWR, 0);
  } else {
    char buf[1024];
    char* hash;
    NONFAILING(strncpy(buf, (char*)a0, sizeof(buf) - 1));
    buf[sizeof(buf) - 1] = 0;
    while ((hash = strchr(buf, '#'))) {
      *hash = '0' + (char)(a1 % 10);
      a1 /= 10;
    }
    return open(buf, a2, 0);
  }
}

#define XT_TABLE_SIZE 1536
#define XT_MAX_ENTRIES 10

struct xt_counters {
  uint64_t pcnt, bcnt;
};

struct ipt_getinfo {
  char name[32];
  unsigned int valid_hooks;
  unsigned int hook_entry[5];
  unsigned int underflow[5];
  unsigned int num_entries;
  unsigned int size;
};

struct ipt_get_entries {
  char name[32];
  unsigned int size;
  void* entrytable[XT_TABLE_SIZE / sizeof(void*)];
};

struct ipt_replace {
  char name[32];
  unsigned int valid_hooks;
  unsigned int num_entries;
  unsigned int size;
  unsigned int hook_entry[5];
  unsigned int underflow[5];
  unsigned int num_counters;
  struct xt_counters* counters;
  char entrytable[XT_TABLE_SIZE];
};

struct ipt_table_desc {
  const char* name;
  struct ipt_getinfo info;
  struct ipt_replace replace;
};

static struct ipt_table_desc ipv4_tables[] = {
    {.name = "filter"}, {.name = "nat"},      {.name = "mangle"},
    {.name = "raw"},    {.name = "security"},
};

static struct ipt_table_desc ipv6_tables[] = {
    {.name = "filter"}, {.name = "nat"},      {.name = "mangle"},
    {.name = "raw"},    {.name = "security"},
};

#define IPT_BASE_CTL 64
#define IPT_SO_SET_REPLACE (IPT_BASE_CTL)
#define IPT_SO_GET_INFO (IPT_BASE_CTL)
#define IPT_SO_GET_ENTRIES (IPT_BASE_CTL + 1)

struct arpt_getinfo {
  char name[32];
  unsigned int valid_hooks;
  unsigned int hook_entry[3];
  unsigned int underflow[3];
  unsigned int num_entries;
  unsigned int size;
};

struct arpt_get_entries {
  char name[32];
  unsigned int size;
  void* entrytable[XT_TABLE_SIZE / sizeof(void*)];
};

struct arpt_replace {
  char name[32];
  unsigned int valid_hooks;
  unsigned int num_entries;
  unsigned int size;
  unsigned int hook_entry[3];
  unsigned int underflow[3];
  unsigned int num_counters;
  struct xt_counters* counters;
  char entrytable[XT_TABLE_SIZE];
};

struct arpt_table_desc {
  const char* name;
  struct arpt_getinfo info;
  struct arpt_replace replace;
};

static struct arpt_table_desc arpt_tables[] = {
    {.name = "filter"},
};

#define ARPT_BASE_CTL 96
#define ARPT_SO_SET_REPLACE (ARPT_BASE_CTL)
#define ARPT_SO_GET_INFO (ARPT_BASE_CTL)
#define ARPT_SO_GET_ENTRIES (ARPT_BASE_CTL + 1)

static void checkpoint_iptables(struct ipt_table_desc* tables, int num_tables,
                                int family, int level)
{
  struct ipt_get_entries entries;
  socklen_t optlen;
  int fd, i;
  fd = socket(family, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < num_tables; i++) {
    struct ipt_table_desc* table = &tables[i];
    strcpy(table->info.name, table->name);
    strcpy(table->replace.name, table->name);
    optlen = sizeof(table->info);
    if (getsockopt(fd, level, IPT_SO_GET_INFO, &table->info, &optlen)) {
      switch (errno) {
      case EPERM:
      case ENOENT:
      case ENOPROTOOPT:
        continue;
      }
      exit(1);
    }
    if (table->info.size > sizeof(table->replace.entrytable))
      exit(1);
    if (table->info.num_entries > XT_MAX_ENTRIES)
      exit(1);
    memset(&entries, 0, sizeof(entries));
    strcpy(entries.name, table->name);
    entries.size = table->info.size;
    optlen = sizeof(entries) - sizeof(entries.entrytable) + table->info.size;
    if (getsockopt(fd, level, IPT_SO_GET_ENTRIES, &entries, &optlen))
      exit(1);
    table->replace.valid_hooks = table->info.valid_hooks;
    table->replace.num_entries = table->info.num_entries;
    table->replace.size = table->info.size;
    memcpy(table->replace.hook_entry, table->info.hook_entry,
           sizeof(table->replace.hook_entry));
    memcpy(table->replace.underflow, table->info.underflow,
           sizeof(table->replace.underflow));
    memcpy(table->replace.entrytable, entries.entrytable, table->info.size);
  }
  close(fd);
}

static void reset_iptables(struct ipt_table_desc* tables, int num_tables,
                           int family, int level)
{
  struct xt_counters counters[XT_MAX_ENTRIES];
  struct ipt_get_entries entries;
  struct ipt_getinfo info;
  socklen_t optlen;
  int fd, i;
  fd = socket(family, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < num_tables; i++) {
    struct ipt_table_desc* table = &tables[i];
    if (table->info.valid_hooks == 0)
      continue;
    memset(&info, 0, sizeof(info));
    strcpy(info.name, table->name);
    optlen = sizeof(info);
    if (getsockopt(fd, level, IPT_SO_GET_INFO, &info, &optlen))
      exit(1);
    if (memcmp(&table->info, &info, sizeof(table->info)) == 0) {
      memset(&entries, 0, sizeof(entries));
      strcpy(entries.name, table->name);
      entries.size = table->info.size;
      optlen = sizeof(entries) - sizeof(entries.entrytable) + entries.size;
      if (getsockopt(fd, level, IPT_SO_GET_ENTRIES, &entries, &optlen))
        exit(1);
      if (memcmp(table->replace.entrytable, entries.entrytable,
                 table->info.size) == 0)
        continue;
    }
    table->replace.num_counters = info.num_entries;
    table->replace.counters = counters;
    optlen = sizeof(table->replace) - sizeof(table->replace.entrytable) +
             table->replace.size;
    if (setsockopt(fd, level, IPT_SO_SET_REPLACE, &table->replace, optlen))
      exit(1);
  }
  close(fd);
}

static void checkpoint_arptables(void)
{
  struct arpt_get_entries entries;
  socklen_t optlen;
  unsigned i;
  int fd;
  fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < sizeof(arpt_tables) / sizeof(arpt_tables[0]); i++) {
    struct arpt_table_desc* table = &arpt_tables[i];
    strcpy(table->info.name, table->name);
    strcpy(table->replace.name, table->name);
    optlen = sizeof(table->info);
    if (getsockopt(fd, SOL_IP, ARPT_SO_GET_INFO, &table->info, &optlen)) {
      switch (errno) {
      case EPERM:
      case ENOENT:
      case ENOPROTOOPT:
        continue;
      }
      exit(1);
    }
    if (table->info.size > sizeof(table->replace.entrytable))
      exit(1);
    if (table->info.num_entries > XT_MAX_ENTRIES)
      exit(1);
    memset(&entries, 0, sizeof(entries));
    strcpy(entries.name, table->name);
    entries.size = table->info.size;
    optlen = sizeof(entries) - sizeof(entries.entrytable) + table->info.size;
    if (getsockopt(fd, SOL_IP, ARPT_SO_GET_ENTRIES, &entries, &optlen))
      exit(1);
    table->replace.valid_hooks = table->info.valid_hooks;
    table->replace.num_entries = table->info.num_entries;
    table->replace.size = table->info.size;
    memcpy(table->replace.hook_entry, table->info.hook_entry,
           sizeof(table->replace.hook_entry));
    memcpy(table->replace.underflow, table->info.underflow,
           sizeof(table->replace.underflow));
    memcpy(table->replace.entrytable, entries.entrytable, table->info.size);
  }
  close(fd);
}

static void reset_arptables()
{
  struct xt_counters counters[XT_MAX_ENTRIES];
  struct arpt_get_entries entries;
  struct arpt_getinfo info;
  socklen_t optlen;
  unsigned i;
  int fd;
  fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < sizeof(arpt_tables) / sizeof(arpt_tables[0]); i++) {
    struct arpt_table_desc* table = &arpt_tables[i];
    if (table->info.valid_hooks == 0)
      continue;
    memset(&info, 0, sizeof(info));
    strcpy(info.name, table->name);
    optlen = sizeof(info);
    if (getsockopt(fd, SOL_IP, ARPT_SO_GET_INFO, &info, &optlen))
      exit(1);
    if (memcmp(&table->info, &info, sizeof(table->info)) == 0) {
      memset(&entries, 0, sizeof(entries));
      strcpy(entries.name, table->name);
      entries.size = table->info.size;
      optlen = sizeof(entries) - sizeof(entries.entrytable) + entries.size;
      if (getsockopt(fd, SOL_IP, ARPT_SO_GET_ENTRIES, &entries, &optlen))
        exit(1);
      if (memcmp(table->replace.entrytable, entries.entrytable,
                 table->info.size) == 0)
        continue;
    } else {
    }
    table->replace.num_counters = info.num_entries;
    table->replace.counters = counters;
    optlen = sizeof(table->replace) - sizeof(table->replace.entrytable) +
             table->replace.size;
    if (setsockopt(fd, SOL_IP, ARPT_SO_SET_REPLACE, &table->replace, optlen))
      exit(1);
  }
  close(fd);
}

#define NF_BR_NUMHOOKS 6
#define EBT_TABLE_MAXNAMELEN 32
#define EBT_CHAIN_MAXNAMELEN 32
#define EBT_BASE_CTL 128
#define EBT_SO_SET_ENTRIES (EBT_BASE_CTL)
#define EBT_SO_GET_INFO (EBT_BASE_CTL)
#define EBT_SO_GET_ENTRIES (EBT_SO_GET_INFO + 1)
#define EBT_SO_GET_INIT_INFO (EBT_SO_GET_ENTRIES + 1)
#define EBT_SO_GET_INIT_ENTRIES (EBT_SO_GET_INIT_INFO + 1)

struct ebt_replace {
  char name[EBT_TABLE_MAXNAMELEN];
  unsigned int valid_hooks;
  unsigned int nentries;
  unsigned int entries_size;
  struct ebt_entries* hook_entry[NF_BR_NUMHOOKS];
  unsigned int num_counters;
  struct ebt_counter* counters;
  char* entries;
};

struct ebt_entries {
  unsigned int distinguisher;
  char name[EBT_CHAIN_MAXNAMELEN];
  unsigned int counter_offset;
  int policy;
  unsigned int nentries;
  char data[0] __attribute__((aligned(__alignof__(struct ebt_replace))));
};

struct ebt_table_desc {
  const char* name;
  struct ebt_replace replace;
  char entrytable[XT_TABLE_SIZE];
};

static struct ebt_table_desc ebt_tables[] = {
    {.name = "filter"},
    {.name = "nat"},
    {.name = "broute"},
};

static void checkpoint_ebtables(void)
{
  socklen_t optlen;
  unsigned i;
  int fd;
  fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < sizeof(ebt_tables) / sizeof(ebt_tables[0]); i++) {
    struct ebt_table_desc* table = &ebt_tables[i];
    strcpy(table->replace.name, table->name);
    optlen = sizeof(table->replace);
    if (getsockopt(fd, SOL_IP, EBT_SO_GET_INIT_INFO, &table->replace,
                   &optlen)) {
      switch (errno) {
      case EPERM:
      case ENOENT:
      case ENOPROTOOPT:
        continue;
      }
      exit(1);
    }
    if (table->replace.entries_size > sizeof(table->entrytable))
      exit(1);
    table->replace.num_counters = 0;
    table->replace.entries = table->entrytable;
    optlen = sizeof(table->replace) + table->replace.entries_size;
    if (getsockopt(fd, SOL_IP, EBT_SO_GET_INIT_ENTRIES, &table->replace,
                   &optlen))
      exit(1);
  }
  close(fd);
}

static void reset_ebtables()
{
  struct ebt_replace replace;
  char entrytable[XT_TABLE_SIZE];
  socklen_t optlen;
  unsigned i, j, h;
  int fd;
  fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < sizeof(ebt_tables) / sizeof(ebt_tables[0]); i++) {
    struct ebt_table_desc* table = &ebt_tables[i];
    if (table->replace.valid_hooks == 0)
      continue;
    memset(&replace, 0, sizeof(replace));
    strcpy(replace.name, table->name);
    optlen = sizeof(replace);
    if (getsockopt(fd, SOL_IP, EBT_SO_GET_INFO, &replace, &optlen))
      exit(1);
    replace.num_counters = 0;
    table->replace.entries = 0;
    for (h = 0; h < NF_BR_NUMHOOKS; h++)
      table->replace.hook_entry[h] = 0;
    if (memcmp(&table->replace, &replace, sizeof(table->replace)) == 0) {
      memset(&entrytable, 0, sizeof(entrytable));
      replace.entries = entrytable;
      optlen = sizeof(replace) + replace.entries_size;
      if (getsockopt(fd, SOL_IP, EBT_SO_GET_ENTRIES, &replace, &optlen))
        exit(1);
      if (memcmp(table->entrytable, entrytable, replace.entries_size) == 0)
        continue;
    }
    for (j = 0, h = 0; h < NF_BR_NUMHOOKS; h++) {
      if (table->replace.valid_hooks & (1 << h)) {
        table->replace.hook_entry[h] =
            (struct ebt_entries*)table->entrytable + j;
        j++;
      }
    }
    table->replace.entries = table->entrytable;
    optlen = sizeof(table->replace) + table->replace.entries_size;
    if (setsockopt(fd, SOL_IP, EBT_SO_SET_ENTRIES, &table->replace, optlen))
      exit(1);
  }
  close(fd);
}

static void checkpoint_net_namespace(void)
{
  checkpoint_ebtables();
  checkpoint_arptables();
  checkpoint_iptables(ipv4_tables, sizeof(ipv4_tables) / sizeof(ipv4_tables[0]),
                      AF_INET, SOL_IP);
  checkpoint_iptables(ipv6_tables, sizeof(ipv6_tables) / sizeof(ipv6_tables[0]),
                      AF_INET6, SOL_IPV6);
}

static void reset_net_namespace(void)
{
  reset_ebtables();
  reset_arptables();
  reset_iptables(ipv4_tables, sizeof(ipv4_tables) / sizeof(ipv4_tables[0]),
                 AF_INET, SOL_IP);
  reset_iptables(ipv6_tables, sizeof(ipv6_tables) / sizeof(ipv6_tables[0]),
                 AF_INET6, SOL_IPV6);
}

static void setup_cgroups()
{
  if (mkdir("/syzcgroup", 0777)) {
  }
  if (mkdir("/syzcgroup/unified", 0777)) {
  }
  if (mount("none", "/syzcgroup/unified", "cgroup2", 0, NULL)) {
  }
  if (chmod("/syzcgroup/unified", 0777)) {
  }
  write_file("/syzcgroup/unified/cgroup.subtree_control",
             "+cpu +memory +io +pids +rdma");
  if (mkdir("/syzcgroup/cpu", 0777)) {
  }
  if (mount("none", "/syzcgroup/cpu", "cgroup", 0,
            "cpuset,cpuacct,perf_event,hugetlb")) {
  }
  write_file("/syzcgroup/cpu/cgroup.clone_children", "1");
  if (chmod("/syzcgroup/cpu", 0777)) {
  }
  if (mkdir("/syzcgroup/net", 0777)) {
  }
  if (mount("none", "/syzcgroup/net", "cgroup", 0,
            "net_cls,net_prio,devices,freezer")) {
  }
  if (chmod("/syzcgroup/net", 0777)) {
  }
}

static void setup_cgroups_loop()
{
  int pid = getpid();
  char file[128];
  char cgroupdir[64];
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/unified/syz%llu", procid);
  if (mkdir(cgroupdir, 0777)) {
  }
  snprintf(file, sizeof(file), "%s/pids.max", cgroupdir);
  write_file(file, "32");
  snprintf(file, sizeof(file), "%s/memory.low", cgroupdir);
  write_file(file, "%d", 298 << 20);
  snprintf(file, sizeof(file), "%s/memory.high", cgroupdir);
  write_file(file, "%d", 299 << 20);
  snprintf(file, sizeof(file), "%s/memory.max", cgroupdir);
  write_file(file, "%d", 300 << 20);
  snprintf(file, sizeof(file), "%s/cgroup.procs", cgroupdir);
  write_file(file, "%d", pid);
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/cpu/syz%llu", procid);
  if (mkdir(cgroupdir, 0777)) {
  }
  snprintf(file, sizeof(file), "%s/cgroup.procs", cgroupdir);
  write_file(file, "%d", pid);
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/net/syz%llu", procid);
  if (mkdir(cgroupdir, 0777)) {
  }
  snprintf(file, sizeof(file), "%s/cgroup.procs", cgroupdir);
  write_file(file, "%d", pid);
}

static void setup_cgroups_test()
{
  char cgroupdir[64];
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/unified/syz%llu", procid);
  if (symlink(cgroupdir, "./cgroup")) {
  }
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/cpu/syz%llu", procid);
  if (symlink(cgroupdir, "./cgroup.cpu")) {
  }
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/net/syz%llu", procid);
  if (symlink(cgroupdir, "./cgroup.net")) {
  }
}

static void setup_common()
{
  if (mount(0, "/sys/fs/fuse/connections", "fusectl", 0, 0)) {
  }
  setup_cgroups();
}

static void loop();

static void sandbox_common()
{
  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
  setpgrp();
  setsid();
  struct rlimit rlim;
  rlim.rlim_cur = rlim.rlim_max = (200 << 20);
  setrlimit(RLIMIT_AS, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 32 << 20;
  setrlimit(RLIMIT_MEMLOCK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 136 << 20;
  setrlimit(RLIMIT_FSIZE, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 1 << 20;
  setrlimit(RLIMIT_STACK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 0;
  setrlimit(RLIMIT_CORE, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 256;
  setrlimit(RLIMIT_NOFILE, &rlim);
  if (unshare(CLONE_NEWNS)) {
  }
  if (unshare(CLONE_NEWIPC)) {
  }
  if (unshare(0x02000000)) {
  }
  if (unshare(CLONE_NEWUTS)) {
  }
  if (unshare(CLONE_SYSVSEM)) {
  }
  typedef struct {
    const char* name;
    const char* value;
  } sysctl_t;
  static const sysctl_t sysctls[] = {
      {"/proc/sys/kernel/shmmax", "16777216"},
      {"/proc/sys/kernel/shmall", "536870912"},
      {"/proc/sys/kernel/shmmni", "1024"},
      {"/proc/sys/kernel/msgmax", "8192"},
      {"/proc/sys/kernel/msgmni", "1024"},
      {"/proc/sys/kernel/msgmnb", "1024"},
      {"/proc/sys/kernel/sem", "1024 1048576 500 1024"},
  };
  unsigned i;
  for (i = 0; i < sizeof(sysctls) / sizeof(sysctls[0]); i++)
    write_file(sysctls[i].name, sysctls[i].value);
}

int wait_for_loop(int pid)
{
  if (pid < 0)
    exit(1);
  int status = 0;
  while (waitpid(-1, &status, __WALL) != pid) {
  }
  return WEXITSTATUS(status);
}

static void drop_caps(void)
{
  struct __user_cap_header_struct cap_hdr = {};
  struct __user_cap_data_struct cap_data[2] = {};
  cap_hdr.version = _LINUX_CAPABILITY_VERSION_3;
  cap_hdr.pid = getpid();
  if (syscall(SYS_capget, &cap_hdr, &cap_data))
    exit(1);
  const int drop = (1 << CAP_SYS_PTRACE) | (1 << CAP_SYS_NICE);
  cap_data[0].effective &= ~drop;
  cap_data[0].permitted &= ~drop;
  cap_data[0].inheritable &= ~drop;
  if (syscall(SYS_capset, &cap_hdr, &cap_data))
    exit(1);
}

static int do_sandbox_none(void)
{
  if (unshare(CLONE_NEWPID)) {
  }
  int pid = fork();
  if (pid != 0)
    return wait_for_loop(pid);
  setup_common();
  sandbox_common();
  drop_caps();
  initialize_netdevices_init();
  if (unshare(CLONE_NEWNET)) {
  }
  initialize_tun();
  initialize_netdevices();
  loop();
  exit(1);
}

#define FS_IOC_SETFLAGS _IOW('f', 2, long)
static void remove_dir(const char* dir)
{
  DIR* dp;
  struct dirent* ep;
  int iter = 0;
retry:
  while (umount2(dir, MNT_DETACH) == 0) {
  }
  dp = opendir(dir);
  if (dp == NULL) {
    if (errno == EMFILE) {
      exit(1);
    }
    exit(1);
  }
  while ((ep = readdir(dp))) {
    if (strcmp(ep->d_name, ".") == 0 || strcmp(ep->d_name, "..") == 0)
      continue;
    char filename[FILENAME_MAX];
    snprintf(filename, sizeof(filename), "%s/%s", dir, ep->d_name);
    while (umount2(filename, MNT_DETACH) == 0) {
    }
    struct stat st;
    if (lstat(filename, &st))
      exit(1);
    if (S_ISDIR(st.st_mode)) {
      remove_dir(filename);
      continue;
    }
    int i;
    for (i = 0;; i++) {
      if (unlink(filename) == 0)
        break;
      if (errno == EPERM) {
        int fd = open(filename, O_RDONLY);
        if (fd != -1) {
          long flags = 0;
          if (ioctl(fd, FS_IOC_SETFLAGS, &flags) == 0)
            close(fd);
          continue;
        }
      }
      if (errno == EROFS) {
        break;
      }
      if (errno != EBUSY || i > 100)
        exit(1);
      if (umount2(filename, MNT_DETACH))
        exit(1);
    }
  }
  closedir(dp);
  int i;
  for (i = 0;; i++) {
    if (rmdir(dir) == 0)
      break;
    if (i < 100) {
      if (errno == EPERM) {
        int fd = open(dir, O_RDONLY);
        if (fd != -1) {
          long flags = 0;
          if (ioctl(fd, FS_IOC_SETFLAGS, &flags) == 0)
            close(fd);
          continue;
        }
      }
      if (errno == EROFS) {
        break;
      }
      if (errno == EBUSY) {
        if (umount2(dir, MNT_DETACH))
          exit(1);
        continue;
      }
      if (errno == ENOTEMPTY) {
        if (iter < 100) {
          iter++;
          goto retry;
        }
      }
    }
    exit(1);
  }
}

static void kill_and_wait(int pid, int* status)
{
  kill(-pid, SIGKILL);
  kill(pid, SIGKILL);
  int i;
  for (i = 0; i < 100; i++) {
    if (waitpid(-1, status, WNOHANG | __WALL) == pid)
      return;
    usleep(1000);
  }
  DIR* dir = opendir("/sys/fs/fuse/connections");
  if (dir) {
    for (;;) {
      struct dirent* ent = readdir(dir);
      if (!ent)
        break;
      if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
        continue;
      char abort[300];
      snprintf(abort, sizeof(abort), "/sys/fs/fuse/connections/%s/abort",
               ent->d_name);
      int fd = open(abort, O_WRONLY);
      if (fd == -1) {
        continue;
      }
      if (write(fd, abort, 1) < 0) {
      }
      close(fd);
    }
    closedir(dir);
  } else {
  }
  while (waitpid(-1, status, __WALL) != pid) {
  }
}

static void setup_loop()
{
  setup_cgroups_loop();
  checkpoint_net_namespace();
}

static void reset_loop()
{
  reset_net_namespace();
}

static void setup_test()
{
  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
  setpgrp();
  setup_cgroups_test();
  write_file("/proc/self/oom_score_adj", "1000");
  flush_tun();
}

static void close_fds()
{
  int fd;
  for (fd = 3; fd < 30; fd++)
    close(fd);
}

static void setup_binfmt_misc()
{
  if (mount(0, "/proc/sys/fs/binfmt_misc", "binfmt_misc", 0, 0)) {
  }
  write_file("/proc/sys/fs/binfmt_misc/register", ":syz0:M:0:\x01::./file0:");
  write_file("/proc/sys/fs/binfmt_misc/register",
             ":syz1:M:1:\x02::./file0:POC");
}

struct thread_t {
  int created, call;
  event_t ready, done;
};

static struct thread_t threads[16];
static void execute_call(int call);
static int running;

static void* thr(void* arg)
{
  struct thread_t* th = (struct thread_t*)arg;
  for (;;) {
    event_wait(&th->ready);
    event_reset(&th->ready);
    execute_call(th->call);
    __atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
    event_set(&th->done);
  }
  return 0;
}

static void execute_one(void)
{
  int i, call, thread;
  int collide = 0;
again:
  for (call = 0; call < 6; call++) {
    for (thread = 0; thread < (int)(sizeof(threads) / sizeof(threads[0]));
         thread++) {
      struct thread_t* th = &threads[thread];
      if (!th->created) {
        th->created = 1;
        event_init(&th->ready);
        event_init(&th->done);
        event_set(&th->done);
        thread_start(thr, th);
      }
      if (!event_isset(&th->done))
        continue;
      event_reset(&th->done);
      th->call = call;
      __atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
      event_set(&th->ready);
      if (collide && (call % 2) == 0)
        break;
      event_timedwait(&th->done, 45);
      break;
    }
  }
  for (i = 0; i < 100 && __atomic_load_n(&running, __ATOMIC_RELAXED); i++)
    sleep_ms(1);
  close_fds();
  if (!collide) {
    collide = 1;
    goto again;
  }
}

static void execute_one(void);

#define WAIT_FLAGS __WALL

static void loop(void)
{
  setup_loop();
  int iter;
  for (iter = 0;; iter++) {
    char cwdbuf[32];
    sprintf(cwdbuf, "./%d", iter);
    if (mkdir(cwdbuf, 0777))
      exit(1);
    reset_loop();
    int pid = fork();
    if (pid < 0)
      exit(1);
    if (pid == 0) {
      if (chdir(cwdbuf))
        exit(1);
      setup_test();
      execute_one();
      exit(0);
    }
    int status = 0;
    uint64_t start = current_time_ms();
    for (;;) {
      if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
        break;
      sleep_ms(1);
      if (current_time_ms() - start < 5 * 1000)
        continue;
      kill_and_wait(pid, &status);
      break;
    }
    remove_dir(cwdbuf);
  }
}

uint64_t r[3] = {0xffffffffffffffff, 0xffffffffffffffff, 0x0};

void execute_call(int call)
{
  intptr_t res;
  switch (call) {
  case 0:
    res = syz_open_dev(0, 6, 0x200c0);
    if (res != -1)
      r[0] = res;
    break;
  case 1:
    NONFAILING(*(uint32_t*)0x20000080 = 2);
    NONFAILING(*(uint32_t*)0x20000084 = 0x70);
    NONFAILING(*(uint8_t*)0x20000088 = 0x6d);
    NONFAILING(*(uint8_t*)0x20000089 = 0);
    NONFAILING(*(uint8_t*)0x2000008a = 0);
    NONFAILING(*(uint8_t*)0x2000008b = 0);
    NONFAILING(*(uint32_t*)0x2000008c = 0);
    NONFAILING(*(uint64_t*)0x20000090 = 0);
    NONFAILING(*(uint64_t*)0x20000098 = 0);
    NONFAILING(*(uint64_t*)0x200000a0 = 0);
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 0, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 1, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 2, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, -1, 3, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 4, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 5, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 6, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 7, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 8, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 7, 9, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 10, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 11, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 12, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 13, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 14, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 15, 2));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 17, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 18, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 19, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 20, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 21, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 22, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 23, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 24, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 25, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 1, 26, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 27, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 28, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x200000a8, 0, 29, 35));
    NONFAILING(*(uint32_t*)0x200000b0 = 0);
    NONFAILING(*(uint32_t*)0x200000b4 = 0);
    NONFAILING(*(uint64_t*)0x200000b8 = 0);
    NONFAILING(*(uint64_t*)0x200000c0 = 0);
    NONFAILING(*(uint64_t*)0x200000c8 = 0);
    NONFAILING(*(uint64_t*)0x200000d0 = 0x7fffffff);
    NONFAILING(*(uint32_t*)0x200000d8 = 0);
    NONFAILING(*(uint32_t*)0x200000dc = 0);
    NONFAILING(*(uint64_t*)0x200000e0 = 0);
    NONFAILING(*(uint32_t*)0x200000e8 = 0);
    NONFAILING(*(uint16_t*)0x200000ec = 0);
    NONFAILING(*(uint16_t*)0x200000ee = 0);
    res = syscall(__NR_perf_event_open, 0x20000080, -1, 0, r[0], 0);
    if (res != -1)
      r[1] = res;
    break;
  case 2:
    NONFAILING(*(uint32_t*)0x20000200 = 7);
    NONFAILING(*(uint32_t*)0x20000204 = 0x70);
    NONFAILING(*(uint8_t*)0x20000208 = 4);
    NONFAILING(*(uint8_t*)0x20000209 = 0);
    NONFAILING(*(uint8_t*)0x2000020a = 0);
    NONFAILING(*(uint8_t*)0x2000020b = 0);
    NONFAILING(*(uint32_t*)0x2000020c = 0);
    NONFAILING(*(uint64_t*)0x20000210 = 0);
    NONFAILING(*(uint64_t*)0x20000218 = 0);
    NONFAILING(*(uint64_t*)0x20000220 = 0);
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 0, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 1, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 2, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 3, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 4, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 5, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 6, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 7, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 8, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 9, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 10, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 11, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 12, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 13, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 14, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 15, 2));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 17, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 18, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 19, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 20, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 21, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 22, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 23, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 24, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 25, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 26, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 27, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 28, 1));
    NONFAILING(STORE_BY_BITMASK(uint64_t, , 0x20000228, 0, 29, 35));
    NONFAILING(*(uint32_t*)0x20000230 = 0);
    NONFAILING(*(uint32_t*)0x20000234 = 0);
    NONFAILING(*(uint64_t*)0x20000238 = 0);
    NONFAILING(*(uint64_t*)0x20000240 = 0);
    NONFAILING(*(uint64_t*)0x20000248 = 0);
    NONFAILING(*(uint64_t*)0x20000250 = 0);
    NONFAILING(*(uint32_t*)0x20000258 = 0);
    NONFAILING(*(uint32_t*)0x2000025c = 0);
    NONFAILING(*(uint64_t*)0x20000260 = 0);
    NONFAILING(*(uint32_t*)0x20000268 = 0);
    NONFAILING(*(uint16_t*)0x2000026c = 0);
    NONFAILING(*(uint16_t*)0x2000026e = 0);
    syscall(__NR_perf_event_open, 0x20000200, -1, 0, r[1], 0);
    break;
  case 3:
    NONFAILING(*(uint32_t*)0x20000100 = 1);
    NONFAILING(*(uint32_t*)0x20000104 = 1);
    NONFAILING(*(uint32_t*)0x20000108 = 0);
    NONFAILING(*(uint32_t*)0x2000010c = 1);
    NONFAILING(*(uint32_t*)0x20000110 = 6);
    NONFAILING(*(uint64_t*)0x20000118 = 0);
    NONFAILING(*(uint64_t*)0x20000120 = 4);
    NONFAILING(*(uint8_t*)0x20000128 = 0);
    NONFAILING(*(uint8_t*)0x20000129 = 0);
    NONFAILING(*(uint8_t*)0x2000012a = 0);
    NONFAILING(*(uint8_t*)0x2000012b = 0);
    NONFAILING(*(uint8_t*)0x2000012c = 0);
    NONFAILING(*(uint8_t*)0x2000012d = 0);
    NONFAILING(*(uint8_t*)0x2000012e = 0);
    NONFAILING(*(uint8_t*)0x2000012f = 0);
    NONFAILING(*(uint8_t*)0x20000130 = 0);
    NONFAILING(*(uint8_t*)0x20000131 = 0);
    NONFAILING(*(uint8_t*)0x20000132 = 0);
    NONFAILING(*(uint8_t*)0x20000133 = 0);
    NONFAILING(*(uint8_t*)0x20000134 = 0);
    NONFAILING(*(uint8_t*)0x20000135 = 0);
    NONFAILING(*(uint8_t*)0x20000136 = 0);
    NONFAILING(*(uint8_t*)0x20000137 = 0);
    NONFAILING(*(uint8_t*)0x20000138 = 0);
    NONFAILING(*(uint8_t*)0x20000139 = 0);
    NONFAILING(*(uint8_t*)0x2000013a = 0);
    NONFAILING(*(uint8_t*)0x2000013b = 0);
    NONFAILING(*(uint8_t*)0x2000013c = 0);
    NONFAILING(*(uint8_t*)0x2000013d = 0);
    NONFAILING(*(uint8_t*)0x2000013e = 0);
    NONFAILING(*(uint8_t*)0x2000013f = 0);
    NONFAILING(*(uint8_t*)0x20000140 = 0);
    NONFAILING(*(uint8_t*)0x20000141 = 0);
    NONFAILING(*(uint8_t*)0x20000142 = 0);
    NONFAILING(*(uint8_t*)0x20000143 = 0);
    NONFAILING(*(uint8_t*)0x20000144 = 0);
    NONFAILING(*(uint8_t*)0x20000145 = 0);
    NONFAILING(*(uint8_t*)0x20000146 = 0);
    NONFAILING(*(uint8_t*)0x20000147 = 0);
    syscall(__NR_ioctl, r[0], 0x40485404, 0x20000100);
    break;
  case 4:
    res = syscall(__NR_ioctl, r[0], 0x8904, 0x20000180);
    if (res != -1)
      NONFAILING(r[2] = *(uint32_t*)0x20000180);
    break;
  case 5:
    NONFAILING(*(uint64_t*)0x200016c0 = 0x20000040);
    NONFAILING(*(uint16_t*)0x20000040 = 0x10);
    NONFAILING(*(uint16_t*)0x20000042 = 0);
    NONFAILING(*(uint32_t*)0x20000044 = 0);
    NONFAILING(*(uint32_t*)0x20000048 = 0x10000000);
    NONFAILING(*(uint32_t*)0x200016c8 = 0xc);
    NONFAILING(*(uint64_t*)0x200016d0 = 0x200001c0);
    NONFAILING(*(uint64_t*)0x200001c0 = 0x20000280);
    NONFAILING(*(uint32_t*)0x20000280 = 0x1388);
    NONFAILING(*(uint8_t*)0x20000284 = 0xa);
    NONFAILING(*(uint8_t*)0x20000285 = 5);
    NONFAILING(*(uint16_t*)0x20000286 = 0x400);
    NONFAILING(*(uint32_t*)0x20000288 = 0x70bd2a);
    NONFAILING(*(uint32_t*)0x2000028c = 0x25dfdbfd);
    NONFAILING(*(uint8_t*)0x20000290 = 0xa);
    NONFAILING(*(uint8_t*)0x20000291 = 0);
    NONFAILING(*(uint16_t*)0x20000292 = htobe16(3));
    NONFAILING(*(uint16_t*)0x20000294 = 0xa0);
    NONFAILING(*(uint16_t*)0x20000296 = 0x5e);
    NONFAILING(memcpy(
        (void*)0x20000298,
        "\xd0\xa6\xfb\x40\x7d\x9c\xf2\xd1\x85\x26\x29\xb0\xc7\xe5\x85\x8d\xd5"
        "\xa4\x6d\xc4\x93\xa6\xab\x21\x50\x8c\x56\xe2\xd9\xcd\x98\xd6\xc6\x85"
        "\xb7\x9d\xe8\xf8\x85\xe0\xaf\x84\xa9\x18\x1e\xd8\x4a\xef\x86\xeb\xda"
        "\xa3\x9b\x96\x54\xaf\xac\xcb\x02\xd7\xd2\x6c\x00\xf2\xbd\xe8\x38\x2c"
        "\xf1\x4a\x7e\x02\xd3\xc5\xe5\xae\x9a\x88\x60\xe3\xcd\x5b\x89\x8a\x81"
        "\x58\xd7\x16\x1e\xdd\x55\xe7\xaa\x9f\xe9\x60\x8d\x34\xf9\x17\xa6\x95"
        "\x35\x50\x01\x13\x88\xdb\x0c\x89\xea\xa1\x72\xfb\x12\xcd\x50\x25\x6a"
        "\x9a\x19\x5c\xb6\x42\x85\x79\x67\xe3\x68\x1f\xcf\xda\xfb\x14\x74\xf4"
        "\xd0\xe2\xc7\x02\xb5\x27\xfe\x25\x9b\xce\x1d\xb0\x92\xac\x6e\x9a\x58"
        "\xe2",
        154));
    NONFAILING(memcpy(
        (void*)0x20000334,
        "\x20\x43\x9b\x1f\xd8\x90\x20\xe2\xf6\x51\xff\xed\x69\x04\x7c\xbc\x0d"
        "\x61\xd1\x16\x70\x7d\x50\x11\xbd\x31\x23\x5d\x6e\xe8\xd7\xc8\x1e\x0e"
        "\xba\xf4\xbd\x04\x6b\x98\x3a\x59\x66\x28\x08\x62\x30",
        47));
    NONFAILING(memcpy(
        (void*)0x20000363,
        "\x2b\x13\xbe\x15\x07\x43\x23\x01\x56\xee\x5b\xc5\x10\xba\x5b\x65\xec"
        "\x29\x6d\x9e\x8e\x82\xd5\x09\x5f\x65\xd5\x7f\x28\x63\xad\x77\x5d\xc9"
        "\x4a\xae\x36\x63\x94\x3a\xc0\xfa\x5b\xa2\x86\xc4\xb0\x8b\x13\xc5\x3a"
        "\x8d\x96\xbd\x0a\xa6\xf4\xca\x26\x9c\x69\x04\x23\xf6\x91\xca\x19\x67"
        "\xee\xe4\x8f\x3e\xba\x3b\x9f\xb8\xcd\xbb\x33\xee\x4a\x0f\xd3\xa9\xc3"
        "\x3e\xf6\x9b\xec\x96\xf3\xec\xa0\xb1\xf0\x82\x01\x40\xfd\xb4\xc9\x0b"
        "\x11\x56\xcc\x0e\x70\x4a\xa2\xbd\x84\x82\xe2\x5c\x47\x4a\x2d\xd2\x1b"
        "\x98\x12\xfd\xf8\x4f\x46\xda\x87\x1c\x44\x91\xce\x16\xa7\xff\xe4\x7e"
        "\xb5\xbf\x08\x50\x94\xca\xcc\x91\x67\xe3\x91\x59\x64\x4d\x70\x34\x19"
        "\x97\xd1\x7c\x9b\xe4\x13\xef\xaf\x5d\x46\xdd\x52\x6e\x00\xb8\x22\x63"
        "\xbd\xaa\x83\x15\xf5\x9a\x14\xcf\xcf\x82\xac\xd2\x54\x32\xb3\xb8\x6e"
        "\xa9\x59\xed\xf2\x8f\xb2\xca\x01\xd5\xe7\x43\x65\xa1\xe2\x08\xf8\xb7"
        "\x8f\x00\x98\x81\x19\x99\x7a\x6b\x1c\xbf\x7a\x40\x05\x6e\x43\x35\xbf"
        "\x8c\x4f\x2b\x7b\xbe\x91\x9a\xef\xa5\xce\x71\x2c\x37\xa3\x35\x8c\xc1"
        "\x90\x1d\xf4\x8b\x7e",
        243));
    NONFAILING(*(uint16_t*)0x20000456 = 8);
    NONFAILING(*(uint16_t*)0x20000458 = 0x92);
    NONFAILING(*(uint32_t*)0x2000045a = r[2]);
    NONFAILING(memcpy(
        (void*)0x2000045e,
        "\x21\x67\x97\x0a\xf2\xa4\xec\x5f\x67\x45\xfb\xbf\x1d\x1a\xb7\x5c\x69"
        "\x5a\xf1\xb1\x04\x78\xa0\x46\x57\x3b\x7d\xa5\x83\xcf\xb6\x32\xda\x1f"
        "\x66\xde\x17\x09\xf1\x2b\x71\x46\x83\xad\xd0\xba\xf0\x77\xe9\xf4\xcc"
        "\xd0\xd0\xe5\x76\xd8\x17\x1c\xcf\x21\x85\x92\x22\x42\x08\x16\x2b\xde"
        "\xd3\xdc\x7b\x0a\x75\x01\x0e\x7e\x3d\x4d\xe4\xf8\x57\xef\x60\x85\xee"
        "\x5b\xab\x19\x04\xed\x11\x1b\xe4\x28\x04\x75\xaf\xfb\x82\x39\xb3\x64"
        "\xfc\xdc\x4b\x2d\xb8\x59\xce\x52\x7f\x32\x68\x48\xb9\x5d\x9a\x73\xbf"
        "\x60\xb0\xe5\x7a\x20\x58\xdc\xf8\x42\x1d\xa4\x4e\xc3\x7d\xb0\xa5\x21"
        "\xed\xea\x8d\x0e\x94\x44\xf2\xb5\x04\xdc\xe9\xb9\x17\x7a\x50\x59\x67"
        "\x0b\x51\x55\xed\x0b\xf9\x91\x85\xa5\xed\xb4\x56\x69\x7c\xe9\xb6\x34"
        "\x15\xe3\xc6\x4a\xf3\xe0\x68\xa7\x0c\xd5\xc9\x5b\x5f\xe4\x20\x00\xa9"
        "\x72\x1e\x42\x27\x03\xdf\x7f\xba\x45\x7b\xc6\xee\xe5\x4d\x9b\x03\x2d"
        "\xc7\x32\xc1\x68\x74\xa8\xee\xa7\x52\x18\x60\x7b\x4e\x74\x22\x04\xed"
        "\x75\x97\x91\x5e\xe3\xc3\x2a\xdf\x5f\x76\xb0\xb9\xaf\xb7\xa9\x40\x84"
        "\xdb\x1e\x72\x3f\xc0\x7f\x42\x16\xac\x31\x90\xef\x9d\x4c\xc3\x0f\x9f"
        "\xd9\xa5\x06\x1f\xd2\xdd\x65\x47\x19\xe4\x7c\x0e\x3f\xad\xd9\xbf\xb7"
        "\x81\x03\x2e\x9a\xc0\x19\xa2\x12\xfb\x35\x63\xac\x51\xc9\x89\x52\xb5"
        "\x4c\x10\x02\xe0\x24\xbc\x3c\x66\x2f\xcc\x9d\x87\x79\x21\xb5\x20\x44"
        "\x23\xe3\x9a\x24\x6a\xc3\x42\xe1\xc3\xd3\xbf\x8e\xeb\x13\xd4\x57\xdd"
        "\xa3\x99\xee\xf4\x30\xcc\xd5\x20\x3a\xba\xc0\xeb\x89\x6a\x11\x79\x5c"
        "\xee\xcd\xd0\xa7\x1d\x33\x17\x16\xc1\x60\x4f\x3a\xe7\xb3\xb5\x71\x40"
        "\x49\xc0\x97\x42\x72\x8c\x9f\x9e\xba\x31\x63\xda\x85\x7b\xab\x9d\x61"
        "\xdb\x59\xa5\x95\xdb\xee\xbc\x63\x8c\x3f\x2c\xc4\xea\x40\x22\x4a\xfe"
        "\xd3\x25\xea\x73\x11\xdd\x62\x82\xed\x0d\x43\x40\xb7\xc7\xa1\xa7\x37"
        "\xeb\x06\x52\x7b\xf3\x23\x83\xac\xf1\xa3\x95\xb6\x75\x4a\x68\x9a\x69"
        "\x3b\xb5\x14\x93\xe4\xa6\xe5\x28\x79\x92\x8d\x65\x46\xeb\x7d\x2a\xb3"
        "\xe9\xde\xef\xd7\xa0\xc0\xef\xd9\xf2\xaf\x92\x4e\xde\x42\x41\x68\x4a"
        "\xd7\x44\x39\xdb\x39\x01\xd8\xce\x00\x1f\x02\xe3\x32\x76\x1b\xb2\xab"
        "\x2d\xab\xb1\x77\x28\x7d\xf8\x83\x72\x1e\xaa\xc8\x5f\xdf\xce\x87\x51"
        "\x5e\xaa\xb0\x28\x30\x60\x5f\x0e\xf2\x4f\x25\x0d\xff\x8d\x0a\x17\x40"
        "\x3d\xfd\x81\x2f\xea\x43\x94\x37\xb0\xc0\x01\x5f\x71\x4a\x1f\x17\x42"
        "\x52\x91\x14\xb0\x79\xc0\xcf\xf5\xfa\xe4\xe5\x52\xf6\x82\x13\x7a\xa2"
        "\xc0\x79\xbb\xbe\x9a\x58\x9a\xbb\xab\x75\xa0\x80\x6c\xcc\x0a\x8e\xc0"
        "\xf8\x81\xcf\x8f\x30\x50\x37\xfa\xf8\xc9\xbb\x42\x55\xea\x4d\xed\xc4"
        "\x79\xb0\xa4\x2b\x42\x5f\x4e\xc1\x54\xad\x08\xfe\x1a\x95\x7c\x65\xaf"
        "\xca\x84\xce\x69\x51\x6f\x32\x86\xe6\x84\x7e\x71\x0d\xf0\x02\x1b\x6b"
        "\x00\xda\x2c\x37\xed\x18\xf3\x35\x30\x78\xbd\xb8\x94\xd8\x64\xb9\xea"
        "\xe0\x90\x18\xd3\xbf\x17\x0f\x6e\x55\xec\x0c\x83\x40\x63\x92\xb4\x8e"
        "\x8c\x4d\xa0\x29\x43\xac\xa9\xac\xda\x75\x34\xf8\x94\xba\x26\x98\x23"
        "\x15\xef\xf4\x0c\xf8\xa4\x00\xa5\x8a\x03\x39\x21\x14\x93\x43\xab\x1c"
        "\x39\xf9\x84\x8f\xc9\xd7\x1c\xdb\x9c\x52\x28\x83\x12\x21\x63\x6d\x88"
        "\x7a\x57\x99\x3d\x98\x59\x56\xe1\xab\xb2\x45\xf2\x61\x23\x37\xaa\xe2"
        "\x0d\xb8\x30\x6e\x09\x09\x08\xa8\x36\x8c\x22\x52\xae\x8e\x27\xbc\x88"
        "\xa2\xb3\x3d\x7c\xf8\xde\x4f\x9b\x4c\xb1\xc5\x24\xd0\x1d\x04\x2a\x47"
        "\xef\x1f\x61\xb5\x53\x11\x37\x10\xfd\xc2\x78\x11\xd4\xb0\x35\xbb\x92"
        "\x4b\xf0\x2f\x55\x15\xe4\xb6\xc8\x8a\xdc\x05\x5a\x23\xe3\x53\x55\x0b"
        "\x21\xa5\xa4\x8e\x04\xb3\x9f\xf4\x1c\xd1\xc0\xab\xd1\x90\x8c\x46\x1b"
        "\x21\xd2\x4b\x5a\x2c\x3f\xae\xb4\x42\x96\xe7\x13\x19\x28\x44\x7b\xef"
        "\x4a\xaf\x20\x0e\xd6\xfb\xd4\xe9\x30\xcd\x79\x8e\xf5\x03\x5d\x69\x72"
        "\x84\x23\x61\x2f\x05\xe0\x09\xe7\xb2\xa1\x0a\x3f\x1d\x74\x5c\x8d\xae"
        "\x43\xbc\xc6\x50\x5c\xd2\x4e\xec\x0d\x17\xbd\xa7\xd7\xc0\x9c\x9c\x38"
        "\x8c\x30\xcb\xe8\x4e\xce\x7d\x71\x34\xc0\x44\x36\xf2\x11\x1f\x9c\xdb"
        "\x84\xa3\xec\x27\x6c\x50\xc5\x44\xff\xb9\xca\x72\x04\xa4\xda\x45\xdd"
        "\xa6\x1d\xf7\x47\x9f\x5d\x9f\x89\x8f\x0b\x0c\x51\xa6\x23\xfe\xb7\x1f"
        "\x51\xce\x2f\x64\xfc\x02\x3a\x94\xc0\xaf\xcd\x11\x9c\x2d\xa9\x1a\xc8"
        "\xf0\xea\x10\x2e\xc7\xb8\x8f\x8a\x10\x9c\x7c\x95\x0f\xe1\x64\xea\xc8"
        "\x50\x50\x10\x46\xf0\x18\x12\x03\x8e\x51\xc3\x69\xcd\xd2\xb8\xa6\xdf"
        "\x15\x19\xf5\x53\x6f\xfb\x33\xdb\x5c\x56\x4f\xa6\xcd\xbb\xc9\xcd\x86"
        "\xd1\xc9\x1b\xbd\xae\x36\xcd\xf3\xe8\x58\xd7\x20\x25\xd3\x79\x9b\xce"
        "\x66\x05\x35\x2a\x8a\x3b\x1f\x07\x62\xed\x58\xfd\x10\xd6\x70\x7f\x1e"
        "\x6b\x73\xcc\x52\x58\xe9\xc7\xad\x5a\x65\x5d\xe1\x4c\x89\xc4\xc8\x9f"
        "\x39\x30\x18\xa8\xe7\xa3\x4a\xfd\xb4\x08\x07\xb8\x43\x01\xd2\x2b\xf5"
        "\xcb\x10\x7e\x96\x3d\x96\x01\x7e\x36\x5d\x39\x0b\x82\x16\xc9\x68\x80"
        "\x1c\xf9\xa1\x4c\x7a\x2e\x22\xe1\x2b\x5e\x48\x92\x40\xc5\xda\xbb\xa3"
        "\x6d\x42\x32\x92\x2d\x80\xc3\x33\xc8\xff\x54\xcb\xec\x9f\xb3\x85\x99"
        "\xd2\xe3\x32\x53\x7e\x2a\xee\x09\x74\xbc\xb9\x4b\x7c\x1b\xf6\x8b\x77"
        "\xf2\xd8\xf3\x77\x11\x5e\x32\xc0\x36\x2d\x2f\xff\xfa\x69\xd5\x4c\x15"
        "\xf8\x5b\x25\xc6\xcc\x33\x20\x74\xf4\x47\x3b\xe6\xf6\x6b\xcd\xdd\x37"
        "\x34\x1f\x5f\x98\x9d\x0d\xd0\x31\x10\x09\x48\x8b\x6a\x86\x74\x6a\x75"
        "\x2e\xde\x17\xef\x11\x5a\x9f\xf5\x73\xdd\xf8\xd1\xca\x57\xc8\x29\xf9"
        "\x7e\xa0\x90\x83\x11\x04\x00\x55\x2a\x3c\x14\x7c\xdb\x20\xfc\x13\x6c"
        "\x38\x22\x71\xf6\xb3\x45\x29\x9d\x7b\x13\xb7\xe8\x96\xea\x0e\x9b\xd7"
        "\xe1\x44\x85\x40\xbf\xad\xd1\xa6\xdb\xf3\x0b\xae\x4a\x5e\xeb\x8c\x66"
        "\xf7\x24\x88\x4a\x40\x7b\x7e\x74\x3f\xef\x0a\xdd\x33\x1b\x5b\xf2\x11"
        "\x32\x7a\x76\xf6\x32\xe2\x2e\x62\xae\x0f\xf0\xfa\x36\x15\xc8\x85\x93"
        "\x72\x66\xab\xc0\x2d\xc3\x5d\x34\x9b\xa5\x98\x75\x36\x0a\x5b\x00\x49"
        "\xf6\x87\x4f\x69\xa5\x81\x6c\xd9\xce\xbe\xd3\xe6\x5b\xa3\x23\x01\x61"
        "\xf8\x8f\x12\xc4\x5b\x2d\x95\xac\x20\xec\xb3\xe9\xc6\xfc\x32\x41\x35"
        "\xff\xd3\xb8\xb5\x23\x5f\xe9\xb0\x0c\x5e\x1a\xc2\xae\x36\x53\x46\x60"
        "\x5f\x6c\x95\xed\xfd\x3f\x53\xf2\xff\x2f\x88\x90\x82\x60\x26\x8f\x0f"
        "\xb5\xa5\x52\x2f\x55\xa5\x92\x97\xe3\xfd\xba\xe7\x16\xdc\xcf\x09\x9b"
        "\x7e\x88\xac\xbd\x30\x84\x85\x11\xec\xc8\x11\xc4\x6d\x22\xc0\x84\x90"
        "\x2b\x91\xcd\x0f\x49\xd2\x09\x03\x50\xc3\x73\x4b\x21\xcd\xb5\x2f\x78"
        "\x55\xa7\x10\x67\x5c\xb4\x47\x3a\x9d\x38\xc3\x2b\x31\xa5\x8c\xdb\xb4"
        "\x32\x08\x08\x90\x65\x16\x9c\xc6\x34\x6e\x72\xba\x0f\x8e\xe7\xa3\x6f"
        "\x56\x38\xc5\xc9\x91\x1c\x9a\xbd\x69\xcf\x6a\xa7\x15\x87\x1d\x18\x86"
        "\xcc\xcd\x8c\x9e\x9b\xcf\xac\xd8\x16\xc6\xd9\x4d\x09\x0b\xec\xe4\x61"
        "\x3b\xb6\x94\xa6\xb7\xf8\x7b\x1c\xae\x9a\xb0\x93\x6c\x39\xd7\x35\x08"
        "\x28\xa6\x88\x85\xfa\x8a\x20\xd6\x4b\xb6\x38\xe9\x54\x67\x55\x32\x2b"
        "\xc3\x97\xae\x17\x55\x4d\xcc\x25\x98\x3d\xa6\x2a\x2f\x02\x4a\xbf\xee"
        "\x13\x6d\x0f\x36\xa6\x00\xf4\xcb\x90\x57\x29\xb9\xeb\x21\x26\xf7\x4d"
        "\x4c\x02\xf0\xbc\x5d\xaa\x59\x6d\x15\xff\x90\x61\xc5\x86\x1a\xa2\xf0"
        "\x61\x08\x8b\xdd\xbb\x68\xeb\x3a\xac\x87\x65\xb2\xfb\x75\x99\x77\x70"
        "\x5c\x2c\x6b\x6f\x1a\xab\xd3\x63\x67\xea\xba\x39\xbb\x8f\x18\xef\xef"
        "\x6c\xcd\xc6\xa1\x0d\xfa\x7f\x0f\x83\x86\xf9\xe9\x28\xb3\x6c\x7e\xd0"
        "\x9c\x7f\x73\xf7\xda\x55\x3c\x63\xc9\x6f\xaf\xa7\xfb\xf6\x2c\x79\xe8"
        "\xf9\x7c\x52\xad\x94\xb2\x86\xde\x21\xa8\xc6\x5a\x20\x47\xf5\x77\xf1"
        "\x3f\xc9\x85\x61\xc5\x38\x3d\xc8\x13\xbf\xf4\x07\x8f\x7d\xa1\x57\xc2"
        "\x26\x2d\x0f\x04\x6d\x83\xdd\x8c\x1a\x1a\x2b\xf4\x67\x1b\x6e\x01\xa9"
        "\xa7\x77\x88\x3c\xc6\xa5\x46\x87\xff\x77\xf4\x67\x98\x74\xd8\x1e\x08"
        "\x34\xf6\x3c\xd1\x8f\xba\xe2\x89\x66\xe8\xf4\x0c\x8c\xf3\xc0\x3b\x22"
        "\x9a\x44\x41\x3a\x86\x4a\x67\x17\xd9\x5f\x5b\xe2\x99\xed\x7a\x95\x29"
        "\xe4\xff\x8d\xc2\xcb\xcb\xce\xa7\x42\xeb\x13\xef\x45\x64\x31\xb2\xb1"
        "\x94\x5b\x2a\x88\xed\xf2\xdf\x71\x88\x7b\x78\xe8\xc7\x8c\x98\x6f\xd2"
        "\x15\xf9\xd8\x99\x8e\x42\x15\x8b\x5c\xbf\x20\xad\x17\x33\x7e\x44\x43"
        "\x86\x63\x8c\x21\xf5\x4e\x1e\x97\x7c\x60\x66\xa0\xa8\xcf\x92\xce\xd1"
        "\xf3\x14\xc3\x39\x73\xbb\x7d\xcf\xeb\x8c\x6a\x96\xf2\x0d\x92\x1d\xaa"
        "\x92\x75\x9f\x6c\xd0\x14\x92\xf0\x57\x23\x9b\x68\x42\x0a\x0c\x5a\x61"
        "\x9e\x32\xaf\x67\xd1\xc6\x17\x35\x98\x97\x13\xcb\xaa\x20\xfd\xe3\xb7"
        "\xec\xdb\xa0\xaa\x5e\x25\x89\x06\x7f\xc3\xdc\xcb\x6c\x36\x06\x0e\x22"
        "\xd2\x9b\x2f\x74\xb1\xfe\xf4\xb5\x24\x4c\x0c\x8d\x5b\x8f\x5f\x2c\xab"
        "\x94\xf9\xb3\x0e\x9d\x73\xca\x72\x6d\x25\x6f\xf8\x9d\x82\x45\x96\x1e"
        "\x6a\x66\x56\x21\x6c\x68\x99\xe2\x82\x45\xaa\x27\x53\xb0\x59\xba\xd3"
        "\x1e\xd5\x75\xa6\x4d\x78\x21\x03\xc4\x45\x00\x2a\x07\x63\x36\x56\x7a"
        "\x21\x10\xdd\x1c\x62\x87\x45\x8b\xc2\x6d\x61\x8b\x53\xd4\xb0\x5b\xff"
        "\xe9\xfa\x6a\x87\x6b\x4f\x35\xc9\xe8\x26\x07\x04\x1c\x3e\xc7\x07\x74"
        "\xae\xc7\x8e\x1f\xcf\x4a\xa2\xf8\x66\x35\xf1\x8f\x8b\x15\xa0\x7d\x6c"
        "\xa6\x1f\x56\x2e\x02\x98\x0e\xd5\x39\x99\xe4\xeb\x0e\x2b\xbb\x89\xde"
        "\xfb\xee\x02\xde\x85\x3f\x16\xf0\x74\xf7\x1a\x8c\x44\xec\x75\x99\x0e"
        "\x65\xdb\x95\xc7\xc0\xb1\x1d\x10\x17\x14\x57\x2c\x1a\xd0\x94\x28\xd5"
        "\xe9\xb2\xbf\x0c\x07\x01\xfd\x25\x19\x43\x63\x90\x03\x50\xf8\x48\xd5"
        "\x5f\x20\x20\xf6\xf1\x5f\xf6\x33\x1e\x9a\x79\xed\x6d\x75\x5b\x30\x6a"
        "\xa1\xa0\xed\xda\xff\x4d\x08\x86\xdb\xd8\x71\xcb\xd1\xa8\xa1\x38\xd4"
        "\xa3\x0d\x91\x4e\x06\x80\xa8\xff\x2a\x2f\x59\xa3\x90\xe9\x92\x92\x54"
        "\xeb\xbe\x08\xfa\x1e\x09\xaf\x6c\x9d\xed\xca\x3f\x8e\x42\xce\x15\x39"
        "\x04\xb9\x00\x38\xe8\x05\x50\xb8\x08\xca\x83\xcb\xdf\xd9\x45\x3d\xb5"
        "\x22\xc6\x66\xc0\xcc\xda\xb8\xdf\xd6\x4b\x43\x59\xd9\x5e\x80\x1b\x8a"
        "\x56\xed\x67\xc8\x0d\x2e\xd4\x90\xf9\x87\xc7\x60\x59\xa6\x0e\x23\x51"
        "\x87\x55\xa0\x03\xa8\xd1\x1b\x94\x57\x1b\xbc\x1b\x84\x7f\x1b\xc9\xd5"
        "\x7e\xf2\x38\xdd\x90\x07\xb2\xdd\x92\xdc\x35\xf0\x96\xd4\x29\xd8\x63"
        "\x74\xa1\x1f\x61\xa2\x5c\x71\x6e\x3f\x2e\xeb\x31\x28\xd2\x47\xa8\x36"
        "\x54\x25\x5e\x34\xf6\x1b\xf6\x31\xc0\x15\x9f\xef\xfd\x99\x90\x74\x9c"
        "\x27\x34\xa5\xb0\xc8\x95\xa4\xc3\x40\x5b\xad\xe2\xce\x54\x9a\x01\x43"
        "\xa4\xe3\xe8\x69\xed\xf7\xa0\x9e\x52\xda\xf0\xa6\x12\x3c\x3b\xbf\xf7"
        "\x62\xd9\x7a\x1d\xf9\xb0\x33\x7e\x0b\xe2\xf8\xc4\x33\xbc\x75\xb1\x5f"
        "\xb4\xac\x63\x95\x3f\xb5\x19\xb6\x84\xf0\x33\x5f\x61\x11\x0c\x66\xb8"
        "\x8f\xcb\x3b\x25\xf4\xfb\x0d\x89\x19\xda\x7e\x86\x2a\x48\x92\x32\xcf"
        "\x20\xc7\x37\xfa\x56\x4c\x42\x8f\x21\x99\x30\xa3\xd1\x6c\x03\x1d\xfb"
        "\x35\x70\x47\x2f\xc5\x13\x3c\x4d\xeb\x0d\x8a\x23\x60\x2d\xd3\x29\x26"
        "\xc6\x82\x7f\x19\xca\x7f\x68\x70\x8b\xc2\x9e\x2c\xb9\x8a\xc1\x2c\x20"
        "\x97\x01\x4a\x64\xba\x3e\xb6\xc7\x9f\x1b\x32\x0e\xc5\xf1\xcf\xef\x0a"
        "\x88\x22\x51\x7d\x99\x4f\xa6\xf8\x87\x9b\x98\x54\xbe\xf4\x9d\x7e\xb1"
        "\x70\xa0\x96\x52\x4d\x36\x71\xaa\xed\x69\x68\xee\xeb\x4f\xfe\xec\xeb"
        "\x9e\xe8\xde\xbf\xec\xa9\x96\x17\x9a\x06\xe2\x29\xfe\x8b\x55\x75\xf4"
        "\x17\x9e\x8b\x39\x9b\xbb\x9d\xc5\xb4\x55\xff\x73\x07\x5f\x20\xc6\x27"
        "\xfb\x07\xf8\xb8\xa1\x6c\xd2\x1e\x13\x99\xeb\x57\xc3\x31\x04\x9e\x89"
        "\x62\x69\x57\x43\xad\xaf\xe9\xcc\xfd\x9e\x5b\x97\xc6\x22\x86\x55\x46"
        "\xaa\x1f\x98\xcb\x5a\x66\x13\x93\xb4\x05\xab\xbe\x59\x63\xf0\xb1\xe1"
        "\x04\xc0\x17\x27\xf5\x72\xbd\xf7\x73\x9a\x16\x80\x00\xa4\xca\x41\x4e"
        "\xbc\xc6\xe6\xac\xaf\xee\x21\xa7\x01\x89\x31\x6b\xc8\x22\x1a\x58\x21"
        "\x7f\xa7\x64\x3d\x8a\x5a\x3c\x87\x52\xbb\x3e\xf7\xad\x2e\x27\xfd\x1d"
        "\xae\xea\x76\x4c\xbb\x46\xb9\x35\xf4\x4b\xf7\xa7\x0d\x28\xa0\x2c\x35"
        "\x02\x32\xc4\xa1\x5b\xe5\x8b\x99\x9e\xb9\x58\xea\x2c\x4a\x9e\xc1\x35"
        "\x67\x2f\x9d\x71\x93\x3a\x37\x50\xbb\xdc\x22\x0e\x9f\xc0\x6f\xe2\xa3"
        "\x3a\x4c\x60\xbb\x27\xe0\x9f\x81\x3a\x60\xa6\x99\x89\x3c\xc2\x9a\xea"
        "\xd8\xe4\x93\x97\x2e\x21\xac\x83\x40\x20\xeb\x73\x15\x6b\x4a\xce\x34"
        "\x22\x94\x27\x63\xa7\x1d\xcf\xba\x17\x97\x64\x08\x6e\xe5\x12\xc5\xe0"
        "\x6a\x7e\x56\x6f\x18\x12\x3c\x13\x6d\xe3\xcb\x03\xf5\x5f\xe1\x77\x7e"
        "\xfe\x78\x26\x72\x2a\xbe\x02\x42\x52\x8f\xa2\x3c\x91\xf8\xe1\x4c\xf3"
        "\x6c\x47\xe8\x08\xee\x46\x4c\x27\x01\x2d\x98\x36\x15\xbd\x94\x50\x93"
        "\xfd\xc7\x0a\x28\x26\x66\xfa\x2b\x08\x83\x6a\x39\x77\xc1\x60\x59\xae"
        "\x2d\x4b\xbf\x01\x82\x24\x38\xb1\xf7\x59\xd6\xa0\x7a\x89\x97\xc4\x6b"
        "\x64\x1a\x49\x2e\x8f\xf1\x08\xc3\x2a\x7d\xba\xe5\xee\xb3\x89\x4f\x63"
        "\x74\x7f\xaf\x92\x53\x22\xc6\x6d\x3a\xc2\x29\xfc\x45\xaf\x04\xf4\x5a"
        "\xb3\x1f\x54\x6f\x43\xb1\x8d\x42\x77\x8f\x63\xeb\xfe\xf2\xdd\xa8\xd1"
        "\x55\x6e\xa3\x79\x89\xe4\xdf\xb7\x7b\x2b\x61\x94\xe0\x69\x41\x7c\xfb"
        "\x7e\xf0\x16\xa3\x6c\x76\x8c\x64\x5a\x9a\x63\x75\x4c\xd2\x8c\x5b\xf4"
        "\x38\xa5\x1b\x36\x61\x5b\x36\xb6\xcf\x85\xc0\x94\xce\x42\xce\x50\xf4"
        "\xca\xa6\xf5\x05\xfd\x08\xc8\x5a\xed\x39\xba\x9b\x8f\x10\x32\x08\xaf"
        "\x2c\x07\xcd\xef\x4c\x84\xe1\x4a\x8d\xf6\x9b\x19\x71\x78\x3b\x8c\xdb"
        "\x53\x6e\xcb\x6b\x9e\x1f\xa4\xd2\x3e\xaf\x12\x06\x4d\x36\xa0\x58\xda"
        "\x9f\xf1\x9a\x17\x87\x61\x81\x0d\x95\x4d\x86\xa3\x03\xe1\xa6\x6f\xc2"
        "\x30\x2f\x1e\x40\x3d\x26\xa3\xfa\x02\xaa\xca\x33\x28\x36\x1d\x0c\x1b"
        "\x2d\xac\x0e\x77\x08\x48\xb5\x0e\x80\x71\x01\xc7\x39\x66\xa6\x11\x3d"
        "\x91\x3b\xc6\x12\x7f\xb5\xe2\x62\x6f\x25\xb8\xc9\x03\x13\x78\xfb\x17"
        "\x72\xd4\xb7\x73\xcb\x8c\x72\x05\xb1\xc2\x59\xb9\xce\x17\x07\xf8\x0a"
        "\xd2\xb4\x8e\xa9\x44\x59\x74\xbf\x1c\xd7\x73\x74\xc1\x9a\x12\xdd\xf3"
        "\xfe\xd3\x43\x47\x9d\x1b\x79\xf7\xa6\x94\xd7\x87\x11\x1a\x1f\xea\x11"
        "\xa1\xd5\xc5\x37\x98\xf7\xdf\xf3\x12\x28\x69\xa6\x84\xd6\x91\x48\x3b"
        "\x0c\x0b\x96\x4a\x99\x35\x4b\xc5\xf9\x90\x37\x1e\x14\xe4\x3a\x3d\x8f"
        "\x15\x50\xe5\x09\xc4\x42\x24\x94\xa2\x98\x56\x8b\xe6\x06\xeb\x95\x49"
        "\x3e\x28\x8c\xb7\x13\x75\x3c\xa2\xe8\x7f\xca\xeb\xf7\x4a\xc1\x85\x2a"
        "\xaa\x68\xbc\x13\x42\xc8\x0e\x52\x87\xe0\xf0\xa9\x1f\x6b\x6b\x58\xb5"
        "\x5a\x4c\x39\xcf\x3c\x0c\x19\x8f\x1a\xbf\x37\xa2\x98\x8e\x5a\xf6\x45"
        "\x67\x88\x9e\x68\x9f\x13\x88\xc9\xfe\xb8\x7b\x08\x57\x55\xf7\xde\xb8"
        "\x9d\x4d\xae\xce\x79\x7d\xf0\xa9\x6c\xa7\x4e\xbd\x98\x19\xdc\x78\x17"
        "\x36\x90\xf6\x1d\x26\xdc\x17\x51\x01\x66\xad\x2f\xb4\x37\xad\xec\x13"
        "\x20\x58\x27\x8f\x63\x7f\x09\x8f\x36\x35\x7a\xbb\xa6\x35\xa6\x48\xca"
        "\xa8\xbb\xc9\xbd\xf9\x95\x11\xd0\x44\xa1\x6b\xff\x9b\x58\xd3\x8f\xa0"
        "\x56\x65\xfd\xc9\x54\x2b\x56\x54\xce\xef\x53\xa4\x02\x85\xc6\x62\x38"
        "\x1d\x30\xbd\x00\x73\x25\x4e\x6b\x9e\x32\xc0\xa3\xa2\xe8\xa7\x10\x29"
        "\x38\x1e\x58\xf8\x93\xb6\x00\x88\x71\xfb\x91\x8d\xdb\x62\x3e\x6b\xa0"
        "\x28\xa1\x6f\xa5\x41\xa8\x61\xe3\xa5\x2f\x9d\x53\xde\x40\xf1\x82\xf5"
        "\x05\x3a\xe7\xb1\x2b\x68\x1e\x6f\x56\x87\x0c\x56\x86\x89\x41\x91\x14"
        "\xd0\xa3\x18\x17\xc6\x3b\x34\x70\xec\xf3\x75\x5c\x12\xcb\xbe\x9a\x37"
        "\x82\x59\x32\x98\x77\x31\x6b\x61\x83\x8d\xe0\xca\x1c\xdb\xef\x62\x63"
        "\xf6\x10\x7b\xed\x8c\x2e\x7b\x9c\x56\x02\xf2\x05\xb8\x31\xc6\xed\x18"
        "\x6d\x76\xda\x84\x10\xe9\x16\xb6\x2b\x80\x44\x35\x50\x11\x94\xf0\x14"
        "\x1b\xb2\x2b\xe7\x90\xfc\xad\xfc\x06\x11\x2f\x53\x1e\x9e\x1a\xfe\xab"
        "\xd7\x21\xba\x73\x91\x66\x09\x5f\x3e\x1e\xb4\x91\x55\xb8\xe3\xc9\x39"
        "\xf6\xf4\xcb\x15\xf8\x03\xfe\x87\xbb\xdb\x60\x4c\x5e\xc5\xf8\x71\x68"
        "\x9c\x7d\x05\x2a\xf9\xdb\x12\xd0\x13\xae\x23\x49\x3c\x88\x2f\x80\xe5"
        "\x8e\xc2\xf5\x51\xb8\x8a\x52\x64\x24\x8d\xc1\xa1\x68\x59\x53\xe3\x4e"
        "\x6f\x56\x0f\xf6\x14\x24\x13\xd8\xd2\x04\x85\x6f\x86\x4c\x2a\xab\x45"
        "\xd3\x70\x16\xb7\xf7\xb4\x31\xa0\xe1\x76\xaa\x1a\x2c\xa3\x25\xc3\xdb"
        "\x25\x37\xaf\x8a\xc0\xf0\x45\xc8\xcc\x09\x7c\x2e\xf8\x70\x50\x31\x00"
        "\x58\xc2\x03\xfb\xb0\x85\x2b\x9c\xa2\x3e\x8a\x9b\x42\x93\x83\xbe\x97"
        "\x8b\xba\x2c\xed\x46\x1a\x5a\x04\x69\x18\x6b\x53\xbd\x0b\x80\x7e\xa9"
        "\xc7\xcc\x9b\x72\x50\x0b\xdc\x8a\x19\xc3\x3b\xb8\x81\x8a\x4f\x68\x8b"
        "\x3d\xbb\x48\x67\x22\x2c\x2f\x57\xd5\xfd\x99\x49\xe7\xc1\x4f\x53\x10"
        "\xc9\xb3\x06\x88\x3d\x7f\x04\x38\x84\x65\xee\x8c\xcf\xe7\x83\x32\x65"
        "\xc4\xf4\x5f\xe4\x5b\xd1\xeb\x3a\x78\x8b\x86\xeb\x9c\xd0\x69\x98\xa6"
        "\xbd\x6a\xd0\x98\xc5\xff\xa2\x3d\x37\x68\xe0\xe5\x03\x8b\x75\x0e\x8a"
        "\x33\xe6\x6e\x80\x19\xe8\x71\x27\xd1\x4b\x6a\x56\xd6\x25\xd7\xcb\x88"
        "\x0c\xfa\xa5\x3e\x0f\xf9\xa2\x32\xd3\x98\x59\x6b\x60\x29\x35\x64\x97"
        "\xe0\x23\xe6\xb4\x03\xc8\x84\x1d\x44\x79\x5b\x44\xa7\xa5\x9e\xed\x8d"
        "\x7b\x1b\x89\x6d\xae\x4e\x8e\xe5\x8e\xa7\x71\xa9\x8b\x87\x52\xb0\x84"
        "\xdd\xd9\x1f\xed\xaa\xc3\xc6\x09\x1b\xd4\x33\x4d\xf3\xa4\x45\x42\xc2"
        "\xad\x9c\x14\x7c\x31\xa8\x34\x71\xcf\x90\xe6\x77\xfb\xb5\x92\x22\x20"
        "\x5a\x89\xe6\x29\xb6\x4c\xc6\xac\x67\x2c\xfa\xca\xd6\x0f\xea\x93\x4a"
        "\x58\x5b\x39\x14\x6f\x72\xbd\x88\xf5\xd8\x55\x62\xb7\x7a\x52\xf4\x3c"
        "\x58\x15\xe0\x1c\x31\x0f\xae\xde\xe1\xa9\x82\x94\x65\x89\x67\x6e\x58"
        "\xdd\x70\x14\x04\x61\x5d\xb5\xe0\xd4\x4f\x2b\x9e\xbc\x9b\xba\x12\x22"
        "\x17\x94\x49\x62\x22\xc0\xd5\x00\x3a\x0f\x60\x36\xfc\x79\xd4\x3e\x78"
        "\x3f\xd8\x9c\xe0\x13\xbb\x0b\x78\xe2\xec\x52\xdc\x0f\xe6\x88\x18\xbd"
        "\xb6\x94\x0f\x17\x57\x75\xd1\x31\xdd\x9b\x5f\xd2\x67\x17\x7e\x50\xc6"
        "\x36\x18\x1f\xa4\xba\xfe\x22\xa6\x20\x2b\x75\x18\xc4\xed\x40\x7b\xc6"
        "\x1b\xc4\x7c\xd0\xe0\xec\x5e\xc6\x9c\xb6\xf6\x26\x13\x3d\x3f\x0f\xda"
        "\x4f\x1e\x4d\x76\xc8\x62\x53\x81\x7e\x28\xea\xd6\xea\x3d\x72\x26\x39"
        "\xf3\x52\x56\xc4\x08\x25\x3e\xf7\xb0\x12\xdd\x7e\x26\x7a\x3e\xef\x92"
        "\xc3\x40\x6b\x92\x31\x85\x56\xb5\xfe\x91\x32\x91\xed\xba\x5c\xcd\xdc"
        "\xc9\x4c\x84\x6a\x42\xe4\x93\xa0\xf8\x33\xdb\xbf\x3a\xb8\x21\x8b\x7a"
        "\xbb\xf7\xb7\xdf\x6f\xa0\x53\x46\x16\x54\x94\x89\x17\x02\x62\xd6\xc1"
        "\x6e\xf4\x8f\x4b\x6e\xee\xf8\x17\x1b\xaf\xc5\x48\x69\xa6\xcf\x2c\xd2"
        "\xbe\x5a\x99\x1b\x8d\x61\xfc\x52\x10\xea\x8e\x91\x4f\x1c\x6f\x06\xb4"
        "\x86\x64\xe8\x25\x47\x6a\xdd\x1c\x65\x4a\xf5\x33\xc1\xca\xda\x00\x8b"
        "\x4e\x57\xe3\xf5\xf0\xcf\xbe\x1c\x4e\xee\x49\xbe\xff\x35\x7f\x7c\xed"
        "\x18\x6b\xe6\xf3\xca\x55\x58\xea\x66\x10\x29\x67\x22\x27\x7e\xb8\x27"
        "\xe2\x2f\xd4\x38\x92\x23\xff\x1e\x3a\x27\x33\x79\x0d\x12\xab\xb1\x27"
        "\x47\x2b\x6d\x1b\x66\xa8\x2f\x5b\x4d\x65\xba\xa5\x09\x6d\x8f\x8b\x35"
        "\x2c\x70\x79\x7d\x56\xbe\xd5\x37\x1b\x08\xb0\x2d\x01\x46\x96\x12",
        4096));
    NONFAILING(memcpy(
        (void*)0x2000145e,
        "\x5c\xdc\x21\xd4\xa4\xca\xa2\x2e\xcc\x5f\x2b\x29\x1a\x7a\x01\x4c\x62"
        "\xb4\xc1\xe3\x45\x99\x65\x3a\xa4\xea\x0c\xa3\x7e\x19\x2d\xc1\xe0\x76"
        "\xc9\xe5\xe9\x4b\x40\x1c\xd2\x1d\x35\xa0\xee\xe0\xd9\xb2\x5f\xe6\x2c"
        "\xa9\x67\x39\x04\x1b\xd5\x0c\xcd\x90\x75\x14\xa5\x86\xd9\x48\x66\x22"
        "\xa9\x2b\xc1\xa2\x6e\x25\xb9\x00\x66\xee\x48\xda\x80\xc6\x2c\x11\xc8"
        "\x79\xef\xf7\x20\x11\x25\x9c\x81\xc4\x97\x55\xe2\x19\x40\x29\xad\xb4"
        "\x86\xfd\xf5\xc8\xcf\x2f\x71\x61\xcc\x82\x7c\xa4\x88\xba\x51\x79\x5e"
        "\x35\xee\x47\x50\x85\x56\xd1\x8c\x62\x1f\xbc\xfe\x70\xe2\xef\xa9\xe0"
        "\x1b\x61\x97\xd8\x44\xcf\x3d\xf2\x7b\x4d\x54\x63\x4c\x0d\x3c\xcc\x61"
        "\x8d\x6c\xb3\xe7\xcd\x5c\x7c\x45\x4f\x26\x72\x73\x03\x23\x09\x7d\x0a"
        "\x81\x2c\x9e\xa3\xae\x85\xc1\x03\x37\x83\xaf\xdc\x53\x47\xaf\xda\xdc"
        "\x3c\x71\x9d\x61\x79\x4a\xa3\xa0\x9f\xce\x9c\xd8\x54\x6d\x26\xb1\xdf"
        "\x74\x01\xc8\xfe\xa3\x4c\x8e\xac\x52\xec\x14\xbf\x3c\xfb\xea\xcf\x16"
        "\xa0\xa4\xc9\x78\x9b\xfa\xd3\xcc\x4a\x53\xd4\x96\xf9\xd5\x67\x73\x0d"
        "\xd8\xd4\x48\x61\x72\x06\x6a\x38\xf8\x05\xfe\x65\xa7",
        251));
    NONFAILING(memcpy(
        (void*)0x20001559,
        "\xea\xf9\x6f\x56\xac\x20\x8d\xb1\x6d\xfc\xed\x86\x17\x27\xb2\x44\xe8"
        "\x5b\xda\x3e\x86\xa4\x68\x09\x53\x0a\x9d\x25\x3d\x9b\x3d\x1f\xdc\x5f"
        "\x01\x42\x88\x11\x0f\xe4\x55\x01\xf4\xb7\x0d\x24\x38\xc8\x7b\x50\x82"
        "\xb5\x77\x03\xf5\x49\x82\x3c\x96\xa6\x5b\xae\xdf\xc6\x7c\xb9\xc5\x1a"
        "\xf1\xa4\x8c\x54\x8b\xe0\x2a\xbb\x94\xe6\x4d\x2c\xa9\xb5\x9e\x31\xbe"
        "\x38\x54\x87\xc7\x20\x74\xd6\x3d\x38\x51\x2c\x24\x60\xf9\x25\x81\x2b"
        "\x34\x6f\x9a\x1b\x6c\x39\xd6\x13\xdc\xfd\x8a\xb3\x1a\x5e\xea\x20\x15"
        "\x0c\x7b\x23\xb3\xec\xef\xe3\x6d\xb0\x71\xa6\xd1\x9b\xf2\xfe\x82\xb3"
        "\xcd\xdf\xb3\x16\x32\x27\x70\x94\x44\xb2\x9c\x12\x0e\x54\x35\xeb\x14"
        "\xe7\xd8\xcc\x74\x74\x57\x6b\x4a\x7b\xe1\x0d\x11\x94\xce",
        167));
    NONFAILING(*(uint16_t*)0x20001600 = 8);
    NONFAILING(*(uint16_t*)0x20001602 = 0x65);
    NONFAILING(*(uint32_t*)0x20001604 = 0xfff);
    NONFAILING(*(uint64_t*)0x200001c8 = 0x1388);
    NONFAILING(*(uint64_t*)0x200016d8 = 1);
    NONFAILING(*(uint64_t*)0x200016e0 = 0);
    NONFAILING(*(uint64_t*)0x200016e8 = 0);
    NONFAILING(*(uint32_t*)0x200016f0 = 4);
    syscall(__NR_sendmsg, r[0], 0x200016c0, 0x40000);
    break;
  }
}
int main(void)
{
  syscall(__NR_mmap, 0x20000000, 0x1000000, 3, 0x32, -1, 0);
  setup_binfmt_misc();
  install_segv_handler();
  for (procid = 0; procid < 6; procid++) {
    if (fork() == 0) {
      use_temporary_dir();
      do_sandbox_none();
    }
  }
  sleep(1000000);
  return 0;
}
