// KASAN: slab-out-of-bounds Read in usb_reset_and_verify_device
// https://syzkaller.appspot.com/bug?id=5cf912d59e0b1ddec0c958028bce8d102f6de3c4
// status:open
// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <arpa/inet.h>
#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <net/if.h>
#include <net/if_arp.h>
#include <netinet/in.h>
#include <pthread.h>
#include <sched.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#include <linux/capability.h>
#include <linux/futex.h>
#include <linux/if_addr.h>
#include <linux/if_ether.h>
#include <linux/if_link.h>
#include <linux/if_tun.h>
#include <linux/in6.h>
#include <linux/ip.h>
#include <linux/neighbour.h>
#include <linux/net.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/tcp.h>
#include <linux/usb/ch9.h>
#include <linux/veth.h>

unsigned long long procid;

static __thread int skip_segv;
static __thread jmp_buf segv_env;

static void segv_handler(int sig, siginfo_t* info, void* ctx)
{
  uintptr_t addr = (uintptr_t)info->si_addr;
  const uintptr_t prog_start = 1 << 20;
  const uintptr_t prog_end = 100 << 20;
  if (__atomic_load_n(&skip_segv, __ATOMIC_RELAXED) &&
      (addr < prog_start || addr > prog_end)) {
    _longjmp(segv_env, 1);
  }
  exit(sig);
}

static void install_segv_handler(void)
{
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  syscall(SYS_rt_sigaction, 0x20, &sa, NULL, 8);
  syscall(SYS_rt_sigaction, 0x21, &sa, NULL, 8);
  memset(&sa, 0, sizeof(sa));
  sa.sa_sigaction = segv_handler;
  sa.sa_flags = SA_NODEFER | SA_SIGINFO;
  sigaction(SIGSEGV, &sa, NULL);
  sigaction(SIGBUS, &sa, NULL);
}

#define NONFAILING(...)                                                        \
  {                                                                            \
    __atomic_fetch_add(&skip_segv, 1, __ATOMIC_SEQ_CST);                       \
    if (_setjmp(segv_env) == 0) {                                              \
      __VA_ARGS__;                                                             \
    }                                                                          \
    __atomic_fetch_sub(&skip_segv, 1, __ATOMIC_SEQ_CST);                       \
  }

static void sleep_ms(uint64_t ms)
{
  usleep(ms * 1000);
}

static uint64_t current_time_ms(void)
{
  struct timespec ts;
  if (clock_gettime(CLOCK_MONOTONIC, &ts))
    exit(1);
  return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}

static void use_temporary_dir(void)
{
  char tmpdir_template[] = "./syzkaller.XXXXXX";
  char* tmpdir = mkdtemp(tmpdir_template);
  if (!tmpdir)
    exit(1);
  if (chmod(tmpdir, 0777))
    exit(1);
  if (chdir(tmpdir))
    exit(1);
}

static void thread_start(void* (*fn)(void*), void* arg)
{
  pthread_t th;
  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 128 << 10);
  int i;
  for (i = 0; i < 100; i++) {
    if (pthread_create(&th, &attr, fn, arg) == 0) {
      pthread_attr_destroy(&attr);
      return;
    }
    if (errno == EAGAIN) {
      usleep(50);
      continue;
    }
    break;
  }
  exit(1);
}

#define BITMASK(bf_off, bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
#define STORE_BY_BITMASK(type, htobe, addr, val, bf_off, bf_len)               \
  *(type*)(addr) =                                                             \
      htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) |           \
            (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))

typedef struct {
  int state;
} event_t;

static void event_init(event_t* ev)
{
  ev->state = 0;
}

static void event_reset(event_t* ev)
{
  ev->state = 0;
}

static void event_set(event_t* ev)
{
  if (ev->state)
    exit(1);
  __atomic_store_n(&ev->state, 1, __ATOMIC_RELEASE);
  syscall(SYS_futex, &ev->state, FUTEX_WAKE | FUTEX_PRIVATE_FLAG);
}

static void event_wait(event_t* ev)
{
  while (!__atomic_load_n(&ev->state, __ATOMIC_ACQUIRE))
    syscall(SYS_futex, &ev->state, FUTEX_WAIT | FUTEX_PRIVATE_FLAG, 0, 0);
}

static int event_isset(event_t* ev)
{
  return __atomic_load_n(&ev->state, __ATOMIC_ACQUIRE);
}

static int event_timedwait(event_t* ev, uint64_t timeout)
{
  uint64_t start = current_time_ms();
  uint64_t now = start;
  for (;;) {
    uint64_t remain = timeout - (now - start);
    struct timespec ts;
    ts.tv_sec = remain / 1000;
    ts.tv_nsec = (remain % 1000) * 1000 * 1000;
    syscall(SYS_futex, &ev->state, FUTEX_WAIT | FUTEX_PRIVATE_FLAG, 0, &ts);
    if (__atomic_load_n(&ev->state, __ATOMIC_RELAXED))
      return 1;
    now = current_time_ms();
    if (now - start > timeout)
      return 0;
  }
}

static bool write_file(const char* file, const char* what, ...)
{
  char buf[1024];
  va_list args;
  va_start(args, what);
  vsnprintf(buf, sizeof(buf), what, args);
  va_end(args);
  buf[sizeof(buf) - 1] = 0;
  int len = strlen(buf);
  int fd = open(file, O_WRONLY | O_CLOEXEC);
  if (fd == -1)
    return false;
  if (write(fd, buf, len) != len) {
    int err = errno;
    close(fd);
    errno = err;
    return false;
  }
  close(fd);
  return true;
}

static struct {
  char* pos;
  int nesting;
  struct nlattr* nested[8];
  char buf[1024];
} nlmsg;

static void netlink_init(int typ, int flags, const void* data, int size)
{
  memset(&nlmsg, 0, sizeof(nlmsg));
  struct nlmsghdr* hdr = (struct nlmsghdr*)nlmsg.buf;
  hdr->nlmsg_type = typ;
  hdr->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | flags;
  memcpy(hdr + 1, data, size);
  nlmsg.pos = (char*)(hdr + 1) + NLMSG_ALIGN(size);
}

static void netlink_attr(int typ, const void* data, int size)
{
  struct nlattr* attr = (struct nlattr*)nlmsg.pos;
  attr->nla_len = sizeof(*attr) + size;
  attr->nla_type = typ;
  memcpy(attr + 1, data, size);
  nlmsg.pos += NLMSG_ALIGN(attr->nla_len);
}

static void netlink_nest(int typ)
{
  struct nlattr* attr = (struct nlattr*)nlmsg.pos;
  attr->nla_type = typ;
  nlmsg.pos += sizeof(*attr);
  nlmsg.nested[nlmsg.nesting++] = attr;
}

static void netlink_done(void)
{
  struct nlattr* attr = nlmsg.nested[--nlmsg.nesting];
  attr->nla_len = nlmsg.pos - (char*)attr;
}

static int netlink_send(int sock)
{
  if (nlmsg.pos > nlmsg.buf + sizeof(nlmsg.buf) || nlmsg.nesting)
    exit(1);
  struct nlmsghdr* hdr = (struct nlmsghdr*)nlmsg.buf;
  hdr->nlmsg_len = nlmsg.pos - nlmsg.buf;
  struct sockaddr_nl addr;
  memset(&addr, 0, sizeof(addr));
  addr.nl_family = AF_NETLINK;
  unsigned n = sendto(sock, nlmsg.buf, hdr->nlmsg_len, 0,
                      (struct sockaddr*)&addr, sizeof(addr));
  if (n != hdr->nlmsg_len)
    exit(1);
  n = recv(sock, nlmsg.buf, sizeof(nlmsg.buf), 0);
  if (n < sizeof(struct nlmsghdr) + sizeof(struct nlmsgerr))
    exit(1);
  if (hdr->nlmsg_type != NLMSG_ERROR)
    exit(1);
  return -((struct nlmsgerr*)(hdr + 1))->error;
}

static void netlink_add_device_impl(const char* type, const char* name)
{
  struct ifinfomsg hdr;
  memset(&hdr, 0, sizeof(hdr));
  netlink_init(RTM_NEWLINK, NLM_F_EXCL | NLM_F_CREATE, &hdr, sizeof(hdr));
  if (name)
    netlink_attr(IFLA_IFNAME, name, strlen(name));
  netlink_nest(IFLA_LINKINFO);
  netlink_attr(IFLA_INFO_KIND, type, strlen(type));
}

static void netlink_add_device(int sock, const char* type, const char* name)
{
  netlink_add_device_impl(type, name);
  netlink_done();
  int err = netlink_send(sock);
  (void)err;
}

static void netlink_add_veth(int sock, const char* name, const char* peer)
{
  netlink_add_device_impl("veth", name);
  netlink_nest(IFLA_INFO_DATA);
  netlink_nest(VETH_INFO_PEER);
  nlmsg.pos += sizeof(struct ifinfomsg);
  netlink_attr(IFLA_IFNAME, peer, strlen(peer));
  netlink_done();
  netlink_done();
  netlink_done();
  int err = netlink_send(sock);
  (void)err;
}

static void netlink_add_hsr(int sock, const char* name, const char* slave1,
                            const char* slave2)
{
  netlink_add_device_impl("hsr", name);
  netlink_nest(IFLA_INFO_DATA);
  int ifindex1 = if_nametoindex(slave1);
  netlink_attr(IFLA_HSR_SLAVE1, &ifindex1, sizeof(ifindex1));
  int ifindex2 = if_nametoindex(slave2);
  netlink_attr(IFLA_HSR_SLAVE2, &ifindex2, sizeof(ifindex2));
  netlink_done();
  netlink_done();
  int err = netlink_send(sock);
  (void)err;
}

static void netlink_device_change(int sock, const char* name, bool up,
                                  const char* master, const void* mac,
                                  int macsize)
{
  struct ifinfomsg hdr;
  memset(&hdr, 0, sizeof(hdr));
  if (up)
    hdr.ifi_flags = hdr.ifi_change = IFF_UP;
  netlink_init(RTM_NEWLINK, 0, &hdr, sizeof(hdr));
  netlink_attr(IFLA_IFNAME, name, strlen(name));
  if (master) {
    int ifindex = if_nametoindex(master);
    netlink_attr(IFLA_MASTER, &ifindex, sizeof(ifindex));
  }
  if (macsize)
    netlink_attr(IFLA_ADDRESS, mac, macsize);
  int err = netlink_send(sock);
  (void)err;
}

static int netlink_add_addr(int sock, const char* dev, const void* addr,
                            int addrsize)
{
  struct ifaddrmsg hdr;
  memset(&hdr, 0, sizeof(hdr));
  hdr.ifa_family = addrsize == 4 ? AF_INET : AF_INET6;
  hdr.ifa_prefixlen = addrsize == 4 ? 24 : 120;
  hdr.ifa_scope = RT_SCOPE_UNIVERSE;
  hdr.ifa_index = if_nametoindex(dev);
  netlink_init(RTM_NEWADDR, NLM_F_CREATE | NLM_F_REPLACE, &hdr, sizeof(hdr));
  netlink_attr(IFA_LOCAL, addr, addrsize);
  netlink_attr(IFA_ADDRESS, addr, addrsize);
  return netlink_send(sock);
}

static void netlink_add_addr4(int sock, const char* dev, const char* addr)
{
  struct in_addr in_addr;
  inet_pton(AF_INET, addr, &in_addr);
  int err = netlink_add_addr(sock, dev, &in_addr, sizeof(in_addr));
  (void)err;
}

static void netlink_add_addr6(int sock, const char* dev, const char* addr)
{
  struct in6_addr in6_addr;
  inet_pton(AF_INET6, addr, &in6_addr);
  int err = netlink_add_addr(sock, dev, &in6_addr, sizeof(in6_addr));
  (void)err;
}

static void netlink_add_neigh(int sock, const char* name, const void* addr,
                              int addrsize, const void* mac, int macsize)
{
  struct ndmsg hdr;
  memset(&hdr, 0, sizeof(hdr));
  hdr.ndm_family = addrsize == 4 ? AF_INET : AF_INET6;
  hdr.ndm_ifindex = if_nametoindex(name);
  hdr.ndm_state = NUD_PERMANENT;
  netlink_init(RTM_NEWNEIGH, NLM_F_EXCL | NLM_F_CREATE, &hdr, sizeof(hdr));
  netlink_attr(NDA_DST, addr, addrsize);
  netlink_attr(NDA_LLADDR, mac, macsize);
  int err = netlink_send(sock);
  (void)err;
}

static int tunfd = -1;
static int tun_frags_enabled;
#define SYZ_TUN_MAX_PACKET_SIZE 1000

#define TUN_IFACE "syz_tun"

#define LOCAL_MAC 0xaaaaaaaaaaaa
#define REMOTE_MAC 0xaaaaaaaaaabb

#define LOCAL_IPV4 "172.20.20.170"
#define REMOTE_IPV4 "172.20.20.187"

#define LOCAL_IPV6 "fe80::aa"
#define REMOTE_IPV6 "fe80::bb"

#define IFF_NAPI 0x0010
#define IFF_NAPI_FRAGS 0x0020

static void initialize_tun(void)
{
  tunfd = open("/dev/net/tun", O_RDWR | O_NONBLOCK);
  if (tunfd == -1) {
    printf("tun: can't open /dev/net/tun: please enable CONFIG_TUN=y\n");
    printf("otherwise fuzzing or reproducing might not work as intended\n");
    return;
  }
  const int kTunFd = 240;
  if (dup2(tunfd, kTunFd) < 0)
    exit(1);
  close(tunfd);
  tunfd = kTunFd;
  struct ifreq ifr;
  memset(&ifr, 0, sizeof(ifr));
  strncpy(ifr.ifr_name, TUN_IFACE, IFNAMSIZ);
  ifr.ifr_flags = IFF_TAP | IFF_NO_PI | IFF_NAPI | IFF_NAPI_FRAGS;
  if (ioctl(tunfd, TUNSETIFF, (void*)&ifr) < 0) {
    ifr.ifr_flags = IFF_TAP | IFF_NO_PI;
    if (ioctl(tunfd, TUNSETIFF, (void*)&ifr) < 0)
      exit(1);
  }
  if (ioctl(tunfd, TUNGETIFF, (void*)&ifr) < 0)
    exit(1);
  tun_frags_enabled = (ifr.ifr_flags & IFF_NAPI_FRAGS) != 0;
  char sysctl[64];
  sprintf(sysctl, "/proc/sys/net/ipv6/conf/%s/accept_dad", TUN_IFACE);
  write_file(sysctl, "0");
  sprintf(sysctl, "/proc/sys/net/ipv6/conf/%s/router_solicitations", TUN_IFACE);
  write_file(sysctl, "0");
  int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
  if (sock == -1)
    exit(1);
  netlink_add_addr4(sock, TUN_IFACE, LOCAL_IPV4);
  netlink_add_addr6(sock, TUN_IFACE, LOCAL_IPV6);
  uint64_t macaddr = REMOTE_MAC;
  struct in_addr in_addr;
  inet_pton(AF_INET, REMOTE_IPV4, &in_addr);
  netlink_add_neigh(sock, TUN_IFACE, &in_addr, sizeof(in_addr), &macaddr,
                    ETH_ALEN);
  struct in6_addr in6_addr;
  inet_pton(AF_INET6, REMOTE_IPV6, &in6_addr);
  netlink_add_neigh(sock, TUN_IFACE, &in6_addr, sizeof(in6_addr), &macaddr,
                    ETH_ALEN);
  macaddr = LOCAL_MAC;
  netlink_device_change(sock, TUN_IFACE, true, 0, &macaddr, ETH_ALEN);
  close(sock);
}

#define DEV_IPV4 "172.20.20.%d"
#define DEV_IPV6 "fe80::%02x"
#define DEV_MAC 0x00aaaaaaaaaa
static void initialize_netdevices(void)
{
  char netdevsim[16];
  sprintf(netdevsim, "netdevsim%d", (int)procid);
  struct {
    const char* type;
    const char* dev;
  } devtypes[] = {
      {"ip6gretap", "ip6gretap0"}, {"bridge", "bridge0"},
      {"vcan", "vcan0"},           {"bond", "bond0"},
      {"team", "team0"},           {"dummy", "dummy0"},
      {"nlmon", "nlmon0"},         {"caif", "caif0"},
      {"batadv", "batadv0"},       {"vxcan", "vxcan1"},
      {"netdevsim", netdevsim},    {"veth", 0},
  };
  const char* devmasters[] = {"bridge", "bond", "team"};
  struct {
    const char* name;
    int macsize;
    bool noipv6;
  } devices[] = {
      {"lo", ETH_ALEN},
      {"sit0", 0},
      {"bridge0", ETH_ALEN},
      {"vcan0", 0, true},
      {"tunl0", 0},
      {"gre0", 0},
      {"gretap0", ETH_ALEN},
      {"ip_vti0", 0},
      {"ip6_vti0", 0},
      {"ip6tnl0", 0},
      {"ip6gre0", 0},
      {"ip6gretap0", ETH_ALEN},
      {"erspan0", ETH_ALEN},
      {"bond0", ETH_ALEN},
      {"veth0", ETH_ALEN},
      {"veth1", ETH_ALEN},
      {"team0", ETH_ALEN},
      {"veth0_to_bridge", ETH_ALEN},
      {"veth1_to_bridge", ETH_ALEN},
      {"veth0_to_bond", ETH_ALEN},
      {"veth1_to_bond", ETH_ALEN},
      {"veth0_to_team", ETH_ALEN},
      {"veth1_to_team", ETH_ALEN},
      {"veth0_to_hsr", ETH_ALEN},
      {"veth1_to_hsr", ETH_ALEN},
      {"hsr0", 0},
      {"dummy0", ETH_ALEN},
      {"nlmon0", 0},
      {"vxcan1", 0, true},
      {"caif0", ETH_ALEN},
      {"batadv0", ETH_ALEN},
      {netdevsim, ETH_ALEN},
  };
  int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
  if (sock == -1)
    exit(1);
  unsigned i;
  for (i = 0; i < sizeof(devtypes) / sizeof(devtypes[0]); i++)
    netlink_add_device(sock, devtypes[i].type, devtypes[i].dev);
  for (i = 0; i < sizeof(devmasters) / (sizeof(devmasters[0])); i++) {
    char master[32], slave0[32], veth0[32], slave1[32], veth1[32];
    sprintf(slave0, "%s_slave_0", devmasters[i]);
    sprintf(veth0, "veth0_to_%s", devmasters[i]);
    netlink_add_veth(sock, slave0, veth0);
    sprintf(slave1, "%s_slave_1", devmasters[i]);
    sprintf(veth1, "veth1_to_%s", devmasters[i]);
    netlink_add_veth(sock, slave1, veth1);
    sprintf(master, "%s0", devmasters[i]);
    netlink_device_change(sock, slave0, false, master, 0, 0);
    netlink_device_change(sock, slave1, false, master, 0, 0);
  }
  netlink_device_change(sock, "bridge_slave_0", true, 0, 0, 0);
  netlink_device_change(sock, "bridge_slave_1", true, 0, 0, 0);
  netlink_add_veth(sock, "hsr_slave_0", "veth0_to_hsr");
  netlink_add_veth(sock, "hsr_slave_1", "veth1_to_hsr");
  netlink_add_hsr(sock, "hsr0", "hsr_slave_0", "hsr_slave_1");
  netlink_device_change(sock, "hsr_slave_0", true, 0, 0, 0);
  netlink_device_change(sock, "hsr_slave_1", true, 0, 0, 0);
  for (i = 0; i < sizeof(devices) / (sizeof(devices[0])); i++) {
    char addr[32];
    sprintf(addr, DEV_IPV4, i + 10);
    netlink_add_addr4(sock, devices[i].name, addr);
    if (!devices[i].noipv6) {
      sprintf(addr, DEV_IPV6, i + 10);
      netlink_add_addr6(sock, devices[i].name, addr);
    }
    uint64_t macaddr = DEV_MAC + ((i + 10ull) << 40);
    netlink_device_change(sock, devices[i].name, true, 0, &macaddr,
                          devices[i].macsize);
  }
  close(sock);
}
static void initialize_netdevices_init(void)
{
  int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
  if (sock == -1)
    exit(1);
  struct {
    const char* type;
    int macsize;
    bool noipv6;
    bool noup;
  } devtypes[] = {
      {"nr", 7, true},
      {"rose", 5, true, true},
  };
  unsigned i;
  for (i = 0; i < sizeof(devtypes) / sizeof(devtypes[0]); i++) {
    char dev[32], addr[32];
    sprintf(dev, "%s%d", devtypes[i].type, (int)procid);
    sprintf(addr, "172.30.%d.%d", i, (int)procid + 1);
    netlink_add_addr4(sock, dev, addr);
    if (!devtypes[i].noipv6) {
      sprintf(addr, "fe88::%02x:%02x", i, (int)procid + 1);
      netlink_add_addr6(sock, dev, addr);
    }
    int macsize = devtypes[i].macsize;
    uint64_t macaddr = 0xbbbbbb +
                       ((unsigned long long)i << (8 * (macsize - 2))) +
                       (procid << (8 * (macsize - 1)));
    netlink_device_change(sock, dev, !devtypes[i].noup, 0, &macaddr, macsize);
  }
  close(sock);
}

static int read_tun(char* data, int size)
{
  if (tunfd < 0)
    return -1;
  int rv = read(tunfd, data, size);
  if (rv < 0) {
    if (errno == EAGAIN)
      return -1;
    if (errno == EBADFD)
      return -1;
    exit(1);
  }
  return rv;
}

static void flush_tun()
{
  char data[SYZ_TUN_MAX_PACKET_SIZE];
  while (read_tun(&data[0], sizeof(data)) != -1) {
  }
}

#define USB_DEBUG 0

#define USB_MAX_EP_NUM 32

struct usb_device_index {
  struct usb_device_descriptor* dev;
  struct usb_config_descriptor* config;
  unsigned config_length;
  struct usb_interface_descriptor* iface;
  struct usb_endpoint_descriptor* eps[USB_MAX_EP_NUM];
  unsigned eps_num;
};

static bool parse_usb_descriptor(char* buffer, size_t length,
                                 struct usb_device_index* index)
{
  if (length <
      sizeof(*index->dev) + sizeof(*index->config) + sizeof(*index->iface))
    return false;
  index->dev = (struct usb_device_descriptor*)buffer;
  index->config = (struct usb_config_descriptor*)(buffer + sizeof(*index->dev));
  index->config_length = length - sizeof(*index->dev);
  index->iface =
      (struct usb_interface_descriptor*)(buffer + sizeof(*index->dev) +
                                         sizeof(*index->config));
  index->eps_num = 0;
  size_t offset = 0;
  while (true) {
    if (offset + 1 >= length)
      break;
    uint8_t desc_length = buffer[offset];
    uint8_t desc_type = buffer[offset + 1];
    if (desc_length <= 2)
      break;
    if (offset + desc_length > length)
      break;
    if (desc_type == USB_DT_ENDPOINT) {
      index->eps[index->eps_num] =
          (struct usb_endpoint_descriptor*)(buffer + offset);
      index->eps_num++;
    }
    if (index->eps_num == USB_MAX_EP_NUM)
      break;
    offset += desc_length;
  }
  return true;
}

enum usb_fuzzer_event_type {
  USB_FUZZER_EVENT_INVALID,
  USB_FUZZER_EVENT_CONNECT,
  USB_FUZZER_EVENT_DISCONNECT,
  USB_FUZZER_EVENT_SUSPEND,
  USB_FUZZER_EVENT_RESUME,
  USB_FUZZER_EVENT_CONTROL,
};

struct usb_fuzzer_event {
  uint32_t type;
  uint32_t length;
  char data[0];
};

struct usb_fuzzer_init {
  uint64_t speed;
  const char* driver_name;
  const char* device_name;
};

struct usb_fuzzer_ep_io {
  uint16_t ep;
  uint16_t flags;
  uint32_t length;
  char data[0];
};

#define USB_FUZZER_IOCTL_INIT _IOW('U', 0, struct usb_fuzzer_init)
#define USB_FUZZER_IOCTL_RUN _IO('U', 1)
#define USB_FUZZER_IOCTL_EVENT_FETCH _IOR('U', 2, struct usb_fuzzer_event)
#define USB_FUZZER_IOCTL_EP0_WRITE _IOW('U', 3, struct usb_fuzzer_ep_io)
#define USB_FUZZER_IOCTL_EP0_READ _IOWR('U', 4, struct usb_fuzzer_ep_io)
#define USB_FUZZER_IOCTL_EP_ENABLE _IOW('U', 5, struct usb_endpoint_descriptor)
#define USB_FUZZER_IOCTL_EP_WRITE _IOW('U', 7, struct usb_fuzzer_ep_io)
#define USB_FUZZER_IOCTL_EP_READ _IOWR('U', 8, struct usb_fuzzer_ep_io)
#define USB_FUZZER_IOCTL_CONFIGURE _IO('U', 9)
#define USB_FUZZER_IOCTL_VBUS_DRAW _IOW('U', 10, uint32_t)

int usb_fuzzer_open()
{
  return open("/sys/kernel/debug/usb-fuzzer", O_RDWR);
}

int usb_fuzzer_init(int fd, uint32_t speed, const char* driver,
                    const char* device)
{
  struct usb_fuzzer_init arg;
  arg.speed = speed;
  arg.driver_name = driver;
  arg.device_name = device;
  return ioctl(fd, USB_FUZZER_IOCTL_INIT, &arg);
}

int usb_fuzzer_run(int fd)
{
  return ioctl(fd, USB_FUZZER_IOCTL_RUN, 0);
}

int usb_fuzzer_event_fetch(int fd, struct usb_fuzzer_event* event)
{
  return ioctl(fd, USB_FUZZER_IOCTL_EVENT_FETCH, event);
}

int usb_fuzzer_ep0_write(int fd, struct usb_fuzzer_ep_io* io)
{
  return ioctl(fd, USB_FUZZER_IOCTL_EP0_WRITE, io);
}

int usb_fuzzer_ep0_read(int fd, struct usb_fuzzer_ep_io* io)
{
  return ioctl(fd, USB_FUZZER_IOCTL_EP0_READ, io);
}

int usb_fuzzer_ep_write(int fd, struct usb_fuzzer_ep_io* io)
{
  return ioctl(fd, USB_FUZZER_IOCTL_EP_WRITE, io);
}

int usb_fuzzer_ep_read(int fd, struct usb_fuzzer_ep_io* io)
{
  return ioctl(fd, USB_FUZZER_IOCTL_EP_READ, io);
}

int usb_fuzzer_ep_enable(int fd, struct usb_endpoint_descriptor* desc)
{
  return ioctl(fd, USB_FUZZER_IOCTL_EP_ENABLE, desc);
}

int usb_fuzzer_configure(int fd)
{
  return ioctl(fd, USB_FUZZER_IOCTL_CONFIGURE, 0);
}

int usb_fuzzer_vbus_draw(int fd, uint32_t power)
{
  return ioctl(fd, USB_FUZZER_IOCTL_VBUS_DRAW, power);
}

#define USB_MAX_PACKET_SIZE 1024

struct usb_fuzzer_control_event {
  struct usb_fuzzer_event inner;
  struct usb_ctrlrequest ctrl;
  char data[USB_MAX_PACKET_SIZE];
};

struct usb_fuzzer_ep_io_data {
  struct usb_fuzzer_ep_io inner;
  char data[USB_MAX_PACKET_SIZE];
};

struct vusb_connect_string_descriptor {
  uint32_t len;
  char* str;
} __attribute__((packed));

struct vusb_connect_descriptors {
  uint32_t qual_len;
  char* qual;
  uint32_t bos_len;
  char* bos;
  uint32_t strs_len;
  struct vusb_connect_string_descriptor strs[0];
} __attribute__((packed));

static const char* default_string = "syzkaller";

static bool lookup_connect_response(struct vusb_connect_descriptors* descs,
                                    struct usb_device_index* index,
                                    struct usb_ctrlrequest* ctrl,
                                    char** response_data,
                                    uint32_t* response_length)
{
  uint8_t str_idx;
  switch (ctrl->bRequestType & USB_TYPE_MASK) {
  case USB_TYPE_STANDARD:
    switch (ctrl->bRequest) {
    case USB_REQ_GET_DESCRIPTOR:
      switch (ctrl->wValue >> 8) {
      case USB_DT_DEVICE:
        *response_data = (char*)index->dev;
        *response_length = sizeof(*index->dev);
        return true;
      case USB_DT_CONFIG:
        *response_data = (char*)index->config;
        *response_length = index->config_length;
        return true;
      case USB_DT_STRING:
        str_idx = (uint8_t)ctrl->wValue;
        if (str_idx >= descs->strs_len) {
          *response_data = (char*)default_string;
          *response_length = strlen(default_string);
        } else {
          *response_data = descs->strs[str_idx].str;
          *response_length = descs->strs[str_idx].len;
        }
        return true;
      case USB_DT_BOS:
        *response_data = descs->bos;
        *response_length = descs->bos_len;
        return true;
      case USB_DT_DEVICE_QUALIFIER:
        *response_data = descs->qual;
        *response_length = descs->qual_len;
        return true;
      default:
        exit(1);
        return false;
      }
      break;
    default:
      exit(1);
      return false;
    }
    break;
  default:
    exit(1);
    return false;
  }
  return false;
}

static volatile long syz_usb_connect(volatile long a0, volatile long a1,
                                     volatile long a2, volatile long a3)
{
  uint64_t speed = a0;
  uint64_t dev_len = a1;
  char* dev = (char*)a2;
  struct vusb_connect_descriptors* descs = (struct vusb_connect_descriptors*)a3;
  if (!dev) {
    return -1;
  }
  struct usb_device_index index;
  memset(&index, 0, sizeof(index));
  int rv = 0;
  NONFAILING(rv = parse_usb_descriptor(dev, dev_len, &index));
  if (!rv) {
    return rv;
  }
  int fd = usb_fuzzer_open();
  if (fd < 0) {
    return fd;
  }
  char device[32];
  sprintf(&device[0], "dummy_udc.%llu", procid);
  rv = usb_fuzzer_init(fd, speed, "dummy_udc", &device[0]);
  if (rv < 0) {
    return rv;
  }
  rv = usb_fuzzer_run(fd);
  if (rv < 0) {
    return rv;
  }
  bool done = false;
  while (!done) {
    struct usb_fuzzer_control_event event;
    event.inner.type = 0;
    event.inner.length = sizeof(event.ctrl);
    rv = usb_fuzzer_event_fetch(fd, (struct usb_fuzzer_event*)&event);
    if (rv < 0) {
      return rv;
    }
    if (event.inner.type != USB_FUZZER_EVENT_CONTROL)
      continue;
    bool response_found = false;
    char* response_data = NULL;
    uint32_t response_length = 0;
    if (event.ctrl.bRequestType & USB_DIR_IN) {
      NONFAILING(response_found =
                     lookup_connect_response(descs, &index, &event.ctrl,
                                             &response_data, &response_length));
      if (!response_found) {
        return -1;
      }
    } else {
      if ((event.ctrl.bRequestType & USB_TYPE_MASK) != USB_TYPE_STANDARD ||
          event.ctrl.bRequest != USB_REQ_SET_CONFIGURATION) {
        exit(1);
        return -1;
      }
      done = true;
    }
    if (done) {
      rv = usb_fuzzer_vbus_draw(fd, index.config->bMaxPower);
      if (rv < 0) {
        return rv;
      }
      rv = usb_fuzzer_configure(fd);
      if (rv < 0) {
        return rv;
      }
      unsigned ep;
      for (ep = 0; ep < index.eps_num; ep++) {
        rv = usb_fuzzer_ep_enable(fd, index.eps[ep]);
        if (rv < 0) {
        } else {
        }
      }
    }
    struct usb_fuzzer_ep_io_data response;
    response.inner.ep = 0;
    response.inner.flags = 0;
    if (response_length > sizeof(response.data))
      response_length = 0;
    if (event.ctrl.wLength < response_length)
      response_length = event.ctrl.wLength;
    response.inner.length = response_length;
    if (response_data)
      memcpy(&response.data[0], response_data, response_length);
    else
      memset(&response.data[0], 0, response_length);
    if (event.ctrl.bRequestType & USB_DIR_IN) {
      rv = usb_fuzzer_ep0_write(fd, (struct usb_fuzzer_ep_io*)&response);
    } else {
      rv = usb_fuzzer_ep0_read(fd, (struct usb_fuzzer_ep_io*)&response);
    }
    if (rv < 0) {
      return rv;
    }
  }
  sleep_ms(200);
  return fd;
}

struct vusb_descriptor {
  uint8_t req_type;
  uint8_t desc_type;
  uint32_t len;
  char data[0];
} __attribute__((packed));

struct vusb_descriptors {
  uint32_t len;
  struct vusb_descriptor* generic;
  struct vusb_descriptor* descs[0];
} __attribute__((packed));

struct vusb_response {
  uint8_t type;
  uint8_t req;
  uint32_t len;
  char data[0];
} __attribute__((packed));

struct vusb_responses {
  uint32_t len;
  struct vusb_response* generic;
  struct vusb_response* resps[0];
} __attribute__((packed));

static bool lookup_control_response(struct vusb_descriptors* descs,
                                    struct vusb_responses* resps,
                                    struct usb_ctrlrequest* ctrl,
                                    char** response_data,
                                    uint32_t* response_length)
{
  int descs_num = (descs->len - offsetof(struct vusb_descriptors, descs)) /
                  sizeof(descs->descs[0]);
  int resps_num = (resps->len - offsetof(struct vusb_responses, resps)) /
                  sizeof(resps->resps[0]);
  uint8_t req = ctrl->bRequest;
  uint8_t req_type = ctrl->bRequestType & USB_TYPE_MASK;
  uint8_t desc_type = ctrl->wValue >> 8;
  if (req == USB_REQ_GET_DESCRIPTOR) {
    int i;
    for (i = 0; i < descs_num; i++) {
      struct vusb_descriptor* desc = descs->descs[i];
      if (!desc)
        continue;
      if (desc->req_type == req_type && desc->desc_type == desc_type) {
        *response_length = desc->len;
        if (*response_length != 0)
          *response_data = &desc->data[0];
        else
          *response_data = NULL;
        return true;
      }
    }
    if (descs->generic) {
      *response_data = &descs->generic->data[0];
      *response_length = descs->generic->len;
      return true;
    }
  } else {
    int i;
    for (i = 0; i < resps_num; i++) {
      struct vusb_response* resp = resps->resps[i];
      if (!resp)
        continue;
      if (resp->type == req_type && resp->req == req) {
        *response_length = resp->len;
        if (*response_length != 0)
          *response_data = &resp->data[0];
        else
          *response_data = NULL;
        return true;
      }
    }
    if (resps->generic) {
      *response_data = &resps->generic->data[0];
      *response_length = resps->generic->len;
      return true;
    }
  }
  return false;
}

static volatile long syz_usb_control_io(volatile long a0, volatile long a1,
                                        volatile long a2)
{
  int fd = a0;
  struct vusb_descriptors* descs = (struct vusb_descriptors*)a1;
  struct vusb_responses* resps = (struct vusb_responses*)a2;
  struct usb_fuzzer_control_event event;
  event.inner.type = 0;
  event.inner.length = USB_MAX_PACKET_SIZE;
  int rv = usb_fuzzer_event_fetch(fd, (struct usb_fuzzer_event*)&event);
  if (rv < 0) {
    return rv;
  }
  if (event.inner.type != USB_FUZZER_EVENT_CONTROL) {
    return -1;
  }
  bool response_found = false;
  char* response_data = NULL;
  uint32_t response_length = 0;
  if (event.ctrl.bRequestType & USB_DIR_IN) {
    NONFAILING(response_found =
                   lookup_control_response(descs, resps, &event.ctrl,
                                           &response_data, &response_length));
    if (!response_found) {
      return -1;
    }
  } else {
    response_length = event.ctrl.wLength;
  }
  struct usb_fuzzer_ep_io_data response;
  response.inner.ep = 0;
  response.inner.flags = 0;
  if (response_length > sizeof(response.data))
    response_length = 0;
  if (event.ctrl.wLength < response_length)
    response_length = event.ctrl.wLength;
  response.inner.length = response_length;
  if (response_data)
    memcpy(&response.data[0], response_data, response_length);
  else
    memset(&response.data[0], 0, response_length);
  if (event.ctrl.bRequestType & USB_DIR_IN) {
    rv = usb_fuzzer_ep0_write(fd, (struct usb_fuzzer_ep_io*)&response);
  } else {
    rv = usb_fuzzer_ep0_read(fd, (struct usb_fuzzer_ep_io*)&response);
  }
  if (rv < 0) {
    return rv;
  }
  sleep_ms(200);
  return 0;
}

static volatile long syz_usb_disconnect(volatile long a0)
{
  int fd = a0;
  int rv = close(fd);
  sleep_ms(200);
  return rv;
}

#define XT_TABLE_SIZE 1536
#define XT_MAX_ENTRIES 10

struct xt_counters {
  uint64_t pcnt, bcnt;
};

struct ipt_getinfo {
  char name[32];
  unsigned int valid_hooks;
  unsigned int hook_entry[5];
  unsigned int underflow[5];
  unsigned int num_entries;
  unsigned int size;
};

struct ipt_get_entries {
  char name[32];
  unsigned int size;
  void* entrytable[XT_TABLE_SIZE / sizeof(void*)];
};

struct ipt_replace {
  char name[32];
  unsigned int valid_hooks;
  unsigned int num_entries;
  unsigned int size;
  unsigned int hook_entry[5];
  unsigned int underflow[5];
  unsigned int num_counters;
  struct xt_counters* counters;
  char entrytable[XT_TABLE_SIZE];
};

struct ipt_table_desc {
  const char* name;
  struct ipt_getinfo info;
  struct ipt_replace replace;
};

static struct ipt_table_desc ipv4_tables[] = {
    {.name = "filter"}, {.name = "nat"},      {.name = "mangle"},
    {.name = "raw"},    {.name = "security"},
};

static struct ipt_table_desc ipv6_tables[] = {
    {.name = "filter"}, {.name = "nat"},      {.name = "mangle"},
    {.name = "raw"},    {.name = "security"},
};

#define IPT_BASE_CTL 64
#define IPT_SO_SET_REPLACE (IPT_BASE_CTL)
#define IPT_SO_GET_INFO (IPT_BASE_CTL)
#define IPT_SO_GET_ENTRIES (IPT_BASE_CTL + 1)

struct arpt_getinfo {
  char name[32];
  unsigned int valid_hooks;
  unsigned int hook_entry[3];
  unsigned int underflow[3];
  unsigned int num_entries;
  unsigned int size;
};

struct arpt_get_entries {
  char name[32];
  unsigned int size;
  void* entrytable[XT_TABLE_SIZE / sizeof(void*)];
};

struct arpt_replace {
  char name[32];
  unsigned int valid_hooks;
  unsigned int num_entries;
  unsigned int size;
  unsigned int hook_entry[3];
  unsigned int underflow[3];
  unsigned int num_counters;
  struct xt_counters* counters;
  char entrytable[XT_TABLE_SIZE];
};

struct arpt_table_desc {
  const char* name;
  struct arpt_getinfo info;
  struct arpt_replace replace;
};

static struct arpt_table_desc arpt_tables[] = {
    {.name = "filter"},
};

#define ARPT_BASE_CTL 96
#define ARPT_SO_SET_REPLACE (ARPT_BASE_CTL)
#define ARPT_SO_GET_INFO (ARPT_BASE_CTL)
#define ARPT_SO_GET_ENTRIES (ARPT_BASE_CTL + 1)

static void checkpoint_iptables(struct ipt_table_desc* tables, int num_tables,
                                int family, int level)
{
  struct ipt_get_entries entries;
  socklen_t optlen;
  int fd, i;
  fd = socket(family, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < num_tables; i++) {
    struct ipt_table_desc* table = &tables[i];
    strcpy(table->info.name, table->name);
    strcpy(table->replace.name, table->name);
    optlen = sizeof(table->info);
    if (getsockopt(fd, level, IPT_SO_GET_INFO, &table->info, &optlen)) {
      switch (errno) {
      case EPERM:
      case ENOENT:
      case ENOPROTOOPT:
        continue;
      }
      exit(1);
    }
    if (table->info.size > sizeof(table->replace.entrytable))
      exit(1);
    if (table->info.num_entries > XT_MAX_ENTRIES)
      exit(1);
    memset(&entries, 0, sizeof(entries));
    strcpy(entries.name, table->name);
    entries.size = table->info.size;
    optlen = sizeof(entries) - sizeof(entries.entrytable) + table->info.size;
    if (getsockopt(fd, level, IPT_SO_GET_ENTRIES, &entries, &optlen))
      exit(1);
    table->replace.valid_hooks = table->info.valid_hooks;
    table->replace.num_entries = table->info.num_entries;
    table->replace.size = table->info.size;
    memcpy(table->replace.hook_entry, table->info.hook_entry,
           sizeof(table->replace.hook_entry));
    memcpy(table->replace.underflow, table->info.underflow,
           sizeof(table->replace.underflow));
    memcpy(table->replace.entrytable, entries.entrytable, table->info.size);
  }
  close(fd);
}

static void reset_iptables(struct ipt_table_desc* tables, int num_tables,
                           int family, int level)
{
  struct xt_counters counters[XT_MAX_ENTRIES];
  struct ipt_get_entries entries;
  struct ipt_getinfo info;
  socklen_t optlen;
  int fd, i;
  fd = socket(family, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < num_tables; i++) {
    struct ipt_table_desc* table = &tables[i];
    if (table->info.valid_hooks == 0)
      continue;
    memset(&info, 0, sizeof(info));
    strcpy(info.name, table->name);
    optlen = sizeof(info);
    if (getsockopt(fd, level, IPT_SO_GET_INFO, &info, &optlen))
      exit(1);
    if (memcmp(&table->info, &info, sizeof(table->info)) == 0) {
      memset(&entries, 0, sizeof(entries));
      strcpy(entries.name, table->name);
      entries.size = table->info.size;
      optlen = sizeof(entries) - sizeof(entries.entrytable) + entries.size;
      if (getsockopt(fd, level, IPT_SO_GET_ENTRIES, &entries, &optlen))
        exit(1);
      if (memcmp(table->replace.entrytable, entries.entrytable,
                 table->info.size) == 0)
        continue;
    }
    table->replace.num_counters = info.num_entries;
    table->replace.counters = counters;
    optlen = sizeof(table->replace) - sizeof(table->replace.entrytable) +
             table->replace.size;
    if (setsockopt(fd, level, IPT_SO_SET_REPLACE, &table->replace, optlen))
      exit(1);
  }
  close(fd);
}

static void checkpoint_arptables(void)
{
  struct arpt_get_entries entries;
  socklen_t optlen;
  unsigned i;
  int fd;
  fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < sizeof(arpt_tables) / sizeof(arpt_tables[0]); i++) {
    struct arpt_table_desc* table = &arpt_tables[i];
    strcpy(table->info.name, table->name);
    strcpy(table->replace.name, table->name);
    optlen = sizeof(table->info);
    if (getsockopt(fd, SOL_IP, ARPT_SO_GET_INFO, &table->info, &optlen)) {
      switch (errno) {
      case EPERM:
      case ENOENT:
      case ENOPROTOOPT:
        continue;
      }
      exit(1);
    }
    if (table->info.size > sizeof(table->replace.entrytable))
      exit(1);
    if (table->info.num_entries > XT_MAX_ENTRIES)
      exit(1);
    memset(&entries, 0, sizeof(entries));
    strcpy(entries.name, table->name);
    entries.size = table->info.size;
    optlen = sizeof(entries) - sizeof(entries.entrytable) + table->info.size;
    if (getsockopt(fd, SOL_IP, ARPT_SO_GET_ENTRIES, &entries, &optlen))
      exit(1);
    table->replace.valid_hooks = table->info.valid_hooks;
    table->replace.num_entries = table->info.num_entries;
    table->replace.size = table->info.size;
    memcpy(table->replace.hook_entry, table->info.hook_entry,
           sizeof(table->replace.hook_entry));
    memcpy(table->replace.underflow, table->info.underflow,
           sizeof(table->replace.underflow));
    memcpy(table->replace.entrytable, entries.entrytable, table->info.size);
  }
  close(fd);
}

static void reset_arptables()
{
  struct xt_counters counters[XT_MAX_ENTRIES];
  struct arpt_get_entries entries;
  struct arpt_getinfo info;
  socklen_t optlen;
  unsigned i;
  int fd;
  fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < sizeof(arpt_tables) / sizeof(arpt_tables[0]); i++) {
    struct arpt_table_desc* table = &arpt_tables[i];
    if (table->info.valid_hooks == 0)
      continue;
    memset(&info, 0, sizeof(info));
    strcpy(info.name, table->name);
    optlen = sizeof(info);
    if (getsockopt(fd, SOL_IP, ARPT_SO_GET_INFO, &info, &optlen))
      exit(1);
    if (memcmp(&table->info, &info, sizeof(table->info)) == 0) {
      memset(&entries, 0, sizeof(entries));
      strcpy(entries.name, table->name);
      entries.size = table->info.size;
      optlen = sizeof(entries) - sizeof(entries.entrytable) + entries.size;
      if (getsockopt(fd, SOL_IP, ARPT_SO_GET_ENTRIES, &entries, &optlen))
        exit(1);
      if (memcmp(table->replace.entrytable, entries.entrytable,
                 table->info.size) == 0)
        continue;
    } else {
    }
    table->replace.num_counters = info.num_entries;
    table->replace.counters = counters;
    optlen = sizeof(table->replace) - sizeof(table->replace.entrytable) +
             table->replace.size;
    if (setsockopt(fd, SOL_IP, ARPT_SO_SET_REPLACE, &table->replace, optlen))
      exit(1);
  }
  close(fd);
}

#define NF_BR_NUMHOOKS 6
#define EBT_TABLE_MAXNAMELEN 32
#define EBT_CHAIN_MAXNAMELEN 32
#define EBT_BASE_CTL 128
#define EBT_SO_SET_ENTRIES (EBT_BASE_CTL)
#define EBT_SO_GET_INFO (EBT_BASE_CTL)
#define EBT_SO_GET_ENTRIES (EBT_SO_GET_INFO + 1)
#define EBT_SO_GET_INIT_INFO (EBT_SO_GET_ENTRIES + 1)
#define EBT_SO_GET_INIT_ENTRIES (EBT_SO_GET_INIT_INFO + 1)

struct ebt_replace {
  char name[EBT_TABLE_MAXNAMELEN];
  unsigned int valid_hooks;
  unsigned int nentries;
  unsigned int entries_size;
  struct ebt_entries* hook_entry[NF_BR_NUMHOOKS];
  unsigned int num_counters;
  struct ebt_counter* counters;
  char* entries;
};

struct ebt_entries {
  unsigned int distinguisher;
  char name[EBT_CHAIN_MAXNAMELEN];
  unsigned int counter_offset;
  int policy;
  unsigned int nentries;
  char data[0] __attribute__((aligned(__alignof__(struct ebt_replace))));
};

struct ebt_table_desc {
  const char* name;
  struct ebt_replace replace;
  char entrytable[XT_TABLE_SIZE];
};

static struct ebt_table_desc ebt_tables[] = {
    {.name = "filter"},
    {.name = "nat"},
    {.name = "broute"},
};

static void checkpoint_ebtables(void)
{
  socklen_t optlen;
  unsigned i;
  int fd;
  fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < sizeof(ebt_tables) / sizeof(ebt_tables[0]); i++) {
    struct ebt_table_desc* table = &ebt_tables[i];
    strcpy(table->replace.name, table->name);
    optlen = sizeof(table->replace);
    if (getsockopt(fd, SOL_IP, EBT_SO_GET_INIT_INFO, &table->replace,
                   &optlen)) {
      switch (errno) {
      case EPERM:
      case ENOENT:
      case ENOPROTOOPT:
        continue;
      }
      exit(1);
    }
    if (table->replace.entries_size > sizeof(table->entrytable))
      exit(1);
    table->replace.num_counters = 0;
    table->replace.entries = table->entrytable;
    optlen = sizeof(table->replace) + table->replace.entries_size;
    if (getsockopt(fd, SOL_IP, EBT_SO_GET_INIT_ENTRIES, &table->replace,
                   &optlen))
      exit(1);
  }
  close(fd);
}

static void reset_ebtables()
{
  struct ebt_replace replace;
  char entrytable[XT_TABLE_SIZE];
  socklen_t optlen;
  unsigned i, j, h;
  int fd;
  fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < sizeof(ebt_tables) / sizeof(ebt_tables[0]); i++) {
    struct ebt_table_desc* table = &ebt_tables[i];
    if (table->replace.valid_hooks == 0)
      continue;
    memset(&replace, 0, sizeof(replace));
    strcpy(replace.name, table->name);
    optlen = sizeof(replace);
    if (getsockopt(fd, SOL_IP, EBT_SO_GET_INFO, &replace, &optlen))
      exit(1);
    replace.num_counters = 0;
    table->replace.entries = 0;
    for (h = 0; h < NF_BR_NUMHOOKS; h++)
      table->replace.hook_entry[h] = 0;
    if (memcmp(&table->replace, &replace, sizeof(table->replace)) == 0) {
      memset(&entrytable, 0, sizeof(entrytable));
      replace.entries = entrytable;
      optlen = sizeof(replace) + replace.entries_size;
      if (getsockopt(fd, SOL_IP, EBT_SO_GET_ENTRIES, &replace, &optlen))
        exit(1);
      if (memcmp(table->entrytable, entrytable, replace.entries_size) == 0)
        continue;
    }
    for (j = 0, h = 0; h < NF_BR_NUMHOOKS; h++) {
      if (table->replace.valid_hooks & (1 << h)) {
        table->replace.hook_entry[h] =
            (struct ebt_entries*)table->entrytable + j;
        j++;
      }
    }
    table->replace.entries = table->entrytable;
    optlen = sizeof(table->replace) + table->replace.entries_size;
    if (setsockopt(fd, SOL_IP, EBT_SO_SET_ENTRIES, &table->replace, optlen))
      exit(1);
  }
  close(fd);
}

static void checkpoint_net_namespace(void)
{
  checkpoint_ebtables();
  checkpoint_arptables();
  checkpoint_iptables(ipv4_tables, sizeof(ipv4_tables) / sizeof(ipv4_tables[0]),
                      AF_INET, SOL_IP);
  checkpoint_iptables(ipv6_tables, sizeof(ipv6_tables) / sizeof(ipv6_tables[0]),
                      AF_INET6, SOL_IPV6);
}

static void reset_net_namespace(void)
{
  reset_ebtables();
  reset_arptables();
  reset_iptables(ipv4_tables, sizeof(ipv4_tables) / sizeof(ipv4_tables[0]),
                 AF_INET, SOL_IP);
  reset_iptables(ipv6_tables, sizeof(ipv6_tables) / sizeof(ipv6_tables[0]),
                 AF_INET6, SOL_IPV6);
}

static void setup_cgroups()
{
  if (mkdir("/syzcgroup", 0777)) {
  }
  if (mkdir("/syzcgroup/unified", 0777)) {
  }
  if (mount("none", "/syzcgroup/unified", "cgroup2", 0, NULL)) {
  }
  if (chmod("/syzcgroup/unified", 0777)) {
  }
  write_file("/syzcgroup/unified/cgroup.subtree_control",
             "+cpu +memory +io +pids +rdma");
  if (mkdir("/syzcgroup/cpu", 0777)) {
  }
  if (mount("none", "/syzcgroup/cpu", "cgroup", 0,
            "cpuset,cpuacct,perf_event,hugetlb")) {
  }
  write_file("/syzcgroup/cpu/cgroup.clone_children", "1");
  if (chmod("/syzcgroup/cpu", 0777)) {
  }
  if (mkdir("/syzcgroup/net", 0777)) {
  }
  if (mount("none", "/syzcgroup/net", "cgroup", 0,
            "net_cls,net_prio,devices,freezer")) {
  }
  if (chmod("/syzcgroup/net", 0777)) {
  }
}

static void setup_cgroups_loop()
{
  int pid = getpid();
  char file[128];
  char cgroupdir[64];
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/unified/syz%llu", procid);
  if (mkdir(cgroupdir, 0777)) {
  }
  snprintf(file, sizeof(file), "%s/pids.max", cgroupdir);
  write_file(file, "32");
  snprintf(file, sizeof(file), "%s/memory.low", cgroupdir);
  write_file(file, "%d", 298 << 20);
  snprintf(file, sizeof(file), "%s/memory.high", cgroupdir);
  write_file(file, "%d", 299 << 20);
  snprintf(file, sizeof(file), "%s/memory.max", cgroupdir);
  write_file(file, "%d", 300 << 20);
  snprintf(file, sizeof(file), "%s/cgroup.procs", cgroupdir);
  write_file(file, "%d", pid);
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/cpu/syz%llu", procid);
  if (mkdir(cgroupdir, 0777)) {
  }
  snprintf(file, sizeof(file), "%s/cgroup.procs", cgroupdir);
  write_file(file, "%d", pid);
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/net/syz%llu", procid);
  if (mkdir(cgroupdir, 0777)) {
  }
  snprintf(file, sizeof(file), "%s/cgroup.procs", cgroupdir);
  write_file(file, "%d", pid);
}

static void setup_cgroups_test()
{
  char cgroupdir[64];
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/unified/syz%llu", procid);
  if (symlink(cgroupdir, "./cgroup")) {
  }
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/cpu/syz%llu", procid);
  if (symlink(cgroupdir, "./cgroup.cpu")) {
  }
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/net/syz%llu", procid);
  if (symlink(cgroupdir, "./cgroup.net")) {
  }
}

static void setup_common()
{
  if (mount(0, "/sys/fs/fuse/connections", "fusectl", 0, 0)) {
  }
  setup_cgroups();
}

static void loop();

static void sandbox_common()
{
  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
  setpgrp();
  setsid();
  struct rlimit rlim;
  rlim.rlim_cur = rlim.rlim_max = (200 << 20);
  setrlimit(RLIMIT_AS, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 32 << 20;
  setrlimit(RLIMIT_MEMLOCK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 136 << 20;
  setrlimit(RLIMIT_FSIZE, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 1 << 20;
  setrlimit(RLIMIT_STACK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 0;
  setrlimit(RLIMIT_CORE, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 256;
  setrlimit(RLIMIT_NOFILE, &rlim);
  if (unshare(CLONE_NEWNS)) {
  }
  if (unshare(CLONE_NEWIPC)) {
  }
  if (unshare(0x02000000)) {
  }
  if (unshare(CLONE_NEWUTS)) {
  }
  if (unshare(CLONE_SYSVSEM)) {
  }
  typedef struct {
    const char* name;
    const char* value;
  } sysctl_t;
  static const sysctl_t sysctls[] = {
      {"/proc/sys/kernel/shmmax", "16777216"},
      {"/proc/sys/kernel/shmall", "536870912"},
      {"/proc/sys/kernel/shmmni", "1024"},
      {"/proc/sys/kernel/msgmax", "8192"},
      {"/proc/sys/kernel/msgmni", "1024"},
      {"/proc/sys/kernel/msgmnb", "1024"},
      {"/proc/sys/kernel/sem", "1024 1048576 500 1024"},
  };
  unsigned i;
  for (i = 0; i < sizeof(sysctls) / sizeof(sysctls[0]); i++)
    write_file(sysctls[i].name, sysctls[i].value);
}

int wait_for_loop(int pid)
{
  if (pid < 0)
    exit(1);
  int status = 0;
  while (waitpid(-1, &status, __WALL) != pid) {
  }
  return WEXITSTATUS(status);
}

static void drop_caps(void)
{
  struct __user_cap_header_struct cap_hdr = {};
  struct __user_cap_data_struct cap_data[2] = {};
  cap_hdr.version = _LINUX_CAPABILITY_VERSION_3;
  cap_hdr.pid = getpid();
  if (syscall(SYS_capget, &cap_hdr, &cap_data))
    exit(1);
  const int drop = (1 << CAP_SYS_PTRACE) | (1 << CAP_SYS_NICE);
  cap_data[0].effective &= ~drop;
  cap_data[0].permitted &= ~drop;
  cap_data[0].inheritable &= ~drop;
  if (syscall(SYS_capset, &cap_hdr, &cap_data))
    exit(1);
}

static int do_sandbox_none(void)
{
  if (unshare(CLONE_NEWPID)) {
  }
  int pid = fork();
  if (pid != 0)
    return wait_for_loop(pid);
  setup_common();
  sandbox_common();
  drop_caps();
  initialize_netdevices_init();
  if (unshare(CLONE_NEWNET)) {
  }
  initialize_tun();
  initialize_netdevices();
  loop();
  exit(1);
}

#define FS_IOC_SETFLAGS _IOW('f', 2, long)
static void remove_dir(const char* dir)
{
  DIR* dp;
  struct dirent* ep;
  int iter = 0;
retry:
  while (umount2(dir, MNT_DETACH) == 0) {
  }
  dp = opendir(dir);
  if (dp == NULL) {
    if (errno == EMFILE) {
      exit(1);
    }
    exit(1);
  }
  while ((ep = readdir(dp))) {
    if (strcmp(ep->d_name, ".") == 0 || strcmp(ep->d_name, "..") == 0)
      continue;
    char filename[FILENAME_MAX];
    snprintf(filename, sizeof(filename), "%s/%s", dir, ep->d_name);
    while (umount2(filename, MNT_DETACH) == 0) {
    }
    struct stat st;
    if (lstat(filename, &st))
      exit(1);
    if (S_ISDIR(st.st_mode)) {
      remove_dir(filename);
      continue;
    }
    int i;
    for (i = 0;; i++) {
      if (unlink(filename) == 0)
        break;
      if (errno == EPERM) {
        int fd = open(filename, O_RDONLY);
        if (fd != -1) {
          long flags = 0;
          if (ioctl(fd, FS_IOC_SETFLAGS, &flags) == 0)
            close(fd);
          continue;
        }
      }
      if (errno == EROFS) {
        break;
      }
      if (errno != EBUSY || i > 100)
        exit(1);
      if (umount2(filename, MNT_DETACH))
        exit(1);
    }
  }
  closedir(dp);
  int i;
  for (i = 0;; i++) {
    if (rmdir(dir) == 0)
      break;
    if (i < 100) {
      if (errno == EPERM) {
        int fd = open(dir, O_RDONLY);
        if (fd != -1) {
          long flags = 0;
          if (ioctl(fd, FS_IOC_SETFLAGS, &flags) == 0)
            close(fd);
          continue;
        }
      }
      if (errno == EROFS) {
        break;
      }
      if (errno == EBUSY) {
        if (umount2(dir, MNT_DETACH))
          exit(1);
        continue;
      }
      if (errno == ENOTEMPTY) {
        if (iter < 100) {
          iter++;
          goto retry;
        }
      }
    }
    exit(1);
  }
}

static void kill_and_wait(int pid, int* status)
{
  kill(-pid, SIGKILL);
  kill(pid, SIGKILL);
  int i;
  for (i = 0; i < 100; i++) {
    if (waitpid(-1, status, WNOHANG | __WALL) == pid)
      return;
    usleep(1000);
  }
  DIR* dir = opendir("/sys/fs/fuse/connections");
  if (dir) {
    for (;;) {
      struct dirent* ent = readdir(dir);
      if (!ent)
        break;
      if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
        continue;
      char abort[300];
      snprintf(abort, sizeof(abort), "/sys/fs/fuse/connections/%s/abort",
               ent->d_name);
      int fd = open(abort, O_WRONLY);
      if (fd == -1) {
        continue;
      }
      if (write(fd, abort, 1) < 0) {
      }
      close(fd);
    }
    closedir(dir);
  } else {
  }
  while (waitpid(-1, status, __WALL) != pid) {
  }
}

static void setup_loop()
{
  setup_cgroups_loop();
  checkpoint_net_namespace();
}

static void reset_loop()
{
  reset_net_namespace();
}

static void setup_test()
{
  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
  setpgrp();
  setup_cgroups_test();
  write_file("/proc/self/oom_score_adj", "1000");
  flush_tun();
}

static void close_fds()
{
  int fd;
  for (fd = 3; fd < 30; fd++)
    close(fd);
}

static void setup_binfmt_misc()
{
  if (mount(0, "/proc/sys/fs/binfmt_misc", "binfmt_misc", 0, 0)) {
  }
  write_file("/proc/sys/fs/binfmt_misc/register", ":syz0:M:0:\x01::./file0:");
  write_file("/proc/sys/fs/binfmt_misc/register",
             ":syz1:M:1:\x02::./file0:POC");
}

struct thread_t {
  int created, call;
  event_t ready, done;
};

static struct thread_t threads[16];
static void execute_call(int call);
static int running;

static void* thr(void* arg)
{
  struct thread_t* th = (struct thread_t*)arg;
  for (;;) {
    event_wait(&th->ready);
    event_reset(&th->ready);
    execute_call(th->call);
    __atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
    event_set(&th->done);
  }
  return 0;
}

static void execute_one(void)
{
  int i, call, thread;
  int collide = 0;
again:
  for (call = 0; call < 6; call++) {
    for (thread = 0; thread < (int)(sizeof(threads) / sizeof(threads[0]));
         thread++) {
      struct thread_t* th = &threads[thread];
      if (!th->created) {
        th->created = 1;
        event_init(&th->ready);
        event_init(&th->done);
        event_set(&th->done);
        thread_start(thr, th);
      }
      if (!event_isset(&th->done))
        continue;
      event_reset(&th->done);
      th->call = call;
      __atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
      event_set(&th->ready);
      if (collide && (call % 2) == 0)
        break;
      event_timedwait(&th->done,
                      45 + (call == 0 ? 2000 : 0) + (call == 1 ? 2000 : 0) +
                          (call == 2 ? 300 : 0) + (call == 3 ? 300 : 0) +
                          (call == 4 ? 300 : 0) + (call == 5 ? 300 : 0));
      break;
    }
  }
  for (i = 0; i < 100 && __atomic_load_n(&running, __ATOMIC_RELAXED); i++)
    sleep_ms(1);
  close_fds();
  if (!collide) {
    collide = 1;
    goto again;
  }
}

static void execute_one(void);

#define WAIT_FLAGS __WALL

static void loop(void)
{
  setup_loop();
  int iter;
  for (iter = 0;; iter++) {
    char cwdbuf[32];
    sprintf(cwdbuf, "./%d", iter);
    if (mkdir(cwdbuf, 0777))
      exit(1);
    reset_loop();
    int pid = fork();
    if (pid < 0)
      exit(1);
    if (pid == 0) {
      if (chdir(cwdbuf))
        exit(1);
      setup_test();
      execute_one();
      exit(0);
    }
    int status = 0;
    uint64_t start = current_time_ms();
    for (;;) {
      if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
        break;
      sleep_ms(1);
      if (current_time_ms() - start < 5 * 1000)
        continue;
      kill_and_wait(pid, &status);
      break;
    }
    remove_dir(cwdbuf);
  }
}

uint64_t r[1] = {0xffffffffffffffff};

void execute_call(int call)
{
  intptr_t res;
  switch (call) {
  case 0:
    NONFAILING(*(uint8_t*)0x20003480 = 0x12);
    NONFAILING(*(uint8_t*)0x20003481 = 1);
    NONFAILING(*(uint16_t*)0x20003482 = 0x110);
    NONFAILING(*(uint8_t*)0x20003484 = 0xb9);
    NONFAILING(*(uint8_t*)0x20003485 = 0xf0);
    NONFAILING(*(uint8_t*)0x20003486 = 0x1f);
    NONFAILING(*(uint8_t*)0x20003487 = 0x10);
    NONFAILING(*(uint16_t*)0x20003488 = 0x1b3d);
    NONFAILING(*(uint16_t*)0x2000348a = 0x127);
    NONFAILING(*(uint16_t*)0x2000348c = 0xc21);
    NONFAILING(*(uint8_t*)0x2000348e = 0);
    NONFAILING(*(uint8_t*)0x2000348f = -1);
    NONFAILING(*(uint8_t*)0x20003490 = 0);
    NONFAILING(*(uint8_t*)0x20003491 = 1);
    NONFAILING(*(uint8_t*)0x20003492 = 9);
    NONFAILING(*(uint8_t*)0x20003493 = 2);
    NONFAILING(*(uint16_t*)0x20003494 = 0xeeb3);
    NONFAILING(*(uint8_t*)0x20003496 = 1);
    NONFAILING(*(uint8_t*)0x20003497 = 0);
    NONFAILING(*(uint8_t*)0x20003498 = 0);
    NONFAILING(*(uint8_t*)0x20003499 = 0);
    NONFAILING(*(uint8_t*)0x2000349a = 0);
    NONFAILING(*(uint8_t*)0x2000349b = 9);
    NONFAILING(*(uint8_t*)0x2000349c = 4);
    NONFAILING(*(uint8_t*)0x2000349d = 0x4c);
    NONFAILING(*(uint8_t*)0x2000349e = 0);
    NONFAILING(*(uint8_t*)0x2000349f = 0);
    NONFAILING(*(uint8_t*)0x200034a0 = 0xc);
    NONFAILING(*(uint8_t*)0x200034a1 = 0x4d);
    NONFAILING(*(uint8_t*)0x200034a2 = 0x10);
    NONFAILING(*(uint8_t*)0x200034a3 = 0);
    NONFAILING(*(uint8_t*)0x200034a4 = 9);
    NONFAILING(*(uint8_t*)0x200034a5 = 5);
    NONFAILING(*(uint8_t*)0x200034a6 = 0xa8);
    NONFAILING(*(uint8_t*)0x200034a7 = 0xc);
    NONFAILING(*(uint16_t*)0x200034a8 = 0x132);
    NONFAILING(*(uint8_t*)0x200034aa = 2);
    NONFAILING(*(uint8_t*)0x200034ab = 0xf8);
    NONFAILING(*(uint8_t*)0x200034ac = 3);
    NONFAILING(*(uint8_t*)0x200034ad = 0);
    NONFAILING(*(uint8_t*)0x200034ae = 0x10);
    NONFAILING(*(uint8_t*)0x200034af = 0);
    NONFAILING(*(uint8_t*)0x200034b0 = 6);
    NONFAILING(memcpy(
        (void*)0x200034b1,
        "\x67\xb0\x5a\xc3\x98\xf3\x9b\xdc\x61\xf3\x56\xa3\xd2\x9c\xef\x7f\xfe"
        "\x2a\x5b\xcf\xc7\x29\x41\xe8\x43\xb9\x2d\x47\xd3\xe7\x76\x34\xed\x59"
        "\xb7\x2c\xd0\x79\x51\xa8\x42\x9a\x47\x05\xe2\xe7\x7b\xdf\xcb\x5c\x5e"
        "\xe6\x54\xa7\x62\xfe\x86\x18\x9a\xdd\x41\x42\x9a\xdf\xe6\xbe\x05\x23"
        "\x92\xe9\x21\x31\x74\x39\xa2\x55\x45\xdc\x0d\xd4\xb8\xdb\x29\xcf\x72"
        "\x41\x50\xde\x6a\xd1\x13\x93\x84\xab\x87\xdb\x47\xb5\x16\xde\x51\x9a"
        "\x5f\x71\xf0\xd7\xc5\x16\x00\xf9\xb6\x3b\x0e\xa3\x46\xd6\x91\xb9\x71"
        "\x9a\x5e\xf3\x04\x59\x00\xd5\xef\x32\x89\x8b\xe1\xdc\x79\x09\x0d\xed"
        "\x9c\xfe\x77\xb2\x1c\x26\xdc\xa1\xb6\x7e\x9b\x22\x01\x8b\x53\x5f\xca"
        "\xc4\x68\x77\xa9\x0b\x40\x6d\x4e\x3f\x75\x69\x99\x12\x41\xe0\xf8\x52"
        "\xbf\x71\xb4\x02\x8c\xf9\x62\x49\xff\xae\x18\x1d\xb5\x83\x93\x9b\x5b"
        "\xf9\x9a\xf5\x98\xb7\x7e\x77\x9d\x90\x84\x55",
        198));
    NONFAILING(*(uint8_t*)0x20003577 = 9);
    NONFAILING(*(uint8_t*)0x20003578 = 5);
    NONFAILING(*(uint8_t*)0x20003579 = 0x8f);
    NONFAILING(*(uint8_t*)0x2000357a = 0);
    NONFAILING(*(uint16_t*)0x2000357b = 0x27b);
    NONFAILING(*(uint8_t*)0x2000357d = 0);
    NONFAILING(*(uint8_t*)0x2000357e = 3);
    NONFAILING(*(uint8_t*)0x2000357f = 0);
    NONFAILING(*(uint8_t*)0x20003580 = 0);
    NONFAILING(*(uint8_t*)0x20003581 = 0x22);
    NONFAILING(memcpy(
        (void*)0x20003582,
        "\x9f\xb4\xdb\x50\x10\x22\x2e\x0a\xb8\x2a\xe3\x24\x46\xc9\xcc\x98\x81"
        "\x7b\x6f\x71\x94\xe3\xc9\x78\x22\x8d\x84\xc7\xe7\xe0\x2f\xa7\x6d\x6e"
        "\x50\x20\x08\x01\xe8\x19\xee\x7b\xdb\xdd\x0b\xc7\x32\xb9\x70\x28\x05"
        "\x33\x52\x87\x04\x10\xdd\x11\x09\x45\x53\x82\x76\x06\xc9\xb1\xb5\x85"
        "\xe1\xd6\x7f\x8a\x07\x1c\xfb\x7d\x5f\xf4\x80\xf7\x39\x79\x0e\x6f\x23"
        "\xb2\x6f\xb2\x50\xe0\xf4\x6c\xcd\xa6\xd9\x6d\x94\x1e\xda\x2d\x88\x45"
        "\xa1\x5e\xa3\x95\x0a\xad\x06\x60\xbe\xa0\xfa\xef\x85\xd4\xc0\x21\xb5"
        "\xa2\x8d\xa0\xfd\xe9\xb7\x9e\xf8\x95\xa8\x63\x51\x17\x20\xc7\xbb\x64"
        "\x0f\xf4\x9d\xd1\xb9\x05",
        142));
    NONFAILING(*(uint8_t*)0x20003610 = 9);
    NONFAILING(*(uint8_t*)0x20003611 = 5);
    NONFAILING(*(uint8_t*)0x20003612 = 0);
    NONFAILING(*(uint8_t*)0x20003613 = 0);
    NONFAILING(*(uint16_t*)0x20003614 = 0x360);
    NONFAILING(*(uint8_t*)0x20003616 = 0x22);
    NONFAILING(*(uint8_t*)0x20003617 = -1);
    NONFAILING(*(uint8_t*)0x20003618 = 7);
    NONFAILING(*(uint8_t*)0x20003619 = 9);
    NONFAILING(*(uint8_t*)0x2000361a = 5);
    NONFAILING(*(uint8_t*)0x2000361b = 3);
    NONFAILING(*(uint8_t*)0x2000361c = 0x10);
    NONFAILING(*(uint16_t*)0x2000361d = 0x2df);
    NONFAILING(*(uint8_t*)0x2000361f = 1);
    NONFAILING(*(uint8_t*)0x20003620 = 1);
    NONFAILING(*(uint8_t*)0x20003621 = 3);
    NONFAILING(*(uint8_t*)0x20003622 = 9);
    NONFAILING(*(uint8_t*)0x20003623 = 5);
    NONFAILING(*(uint8_t*)0x20003624 = 0xa);
    NONFAILING(*(uint8_t*)0x20003625 = 4);
    NONFAILING(*(uint16_t*)0x20003626 = 0x1f1);
    NONFAILING(*(uint8_t*)0x20003628 = 0);
    NONFAILING(*(uint8_t*)0x20003629 = 0xfb);
    NONFAILING(*(uint8_t*)0x2000362a = -1);
    NONFAILING(*(uint8_t*)0x2000362b = 0);
    NONFAILING(*(uint8_t*)0x2000362c = 0x23);
    NONFAILING(memcpy(
        (void*)0x2000362d,
        "\x1c\x50\xbf\x6a\x58\x47\x65\x20\x70\x86\x43\xd8\xfa\xa3\x48\x17\xa8"
        "\x6c\x3a\xd9\x3a\xd5\xc8\xdf\xd0\x42\x29\xed\x45\x15\xc8\xfe\x30\x46"
        "\x8a\xf2\xfa\x0e\x0e\xac\xc3\xd7\xa0\x0d\xe6\x16\xc6\x34\x20\x76\xcf"
        "\x35\xd4\x13\x86\x89\xb8\x5d\x72\x1e\xb9\xe8\xc1\x19\x79\xa2\x39\xe1"
        "\xe7\xcb\xcc\x8a\xb7\x24\x13\x3d\xa7\x53\xc8\x45\xf2\x32\xf2\x80\x05"
        "\x68\x4d\x01\xf4\x4e\x99\x32\x7e\xa7\x5a\x3e\x41\xf0\xd2\x73\xa6\x38"
        "\xdd\x64\x1e\xd4\x00\x6a\x22\xf6\xf7\x98\x02\x2d\x55\xb4\x22\xae\x84"
        "\xa8\x94\x0a\x4c\x35\x19\x01\x3b\xb8",
        128));
    NONFAILING(*(uint8_t*)0x200036ad = 9);
    NONFAILING(*(uint8_t*)0x200036ae = 5);
    NONFAILING(*(uint8_t*)0x200036af = 8);
    NONFAILING(*(uint8_t*)0x200036b0 = 0xe7);
    NONFAILING(*(uint16_t*)0x200036b1 = 0x2c3);
    NONFAILING(*(uint8_t*)0x200036b3 = 4);
    NONFAILING(*(uint8_t*)0x200036b4 = 0x81);
    NONFAILING(*(uint8_t*)0x200036b5 = 0x99);
    NONFAILING(*(uint8_t*)0x200036b6 = 9);
    NONFAILING(*(uint8_t*)0x200036b7 = 5);
    NONFAILING(*(uint8_t*)0x200036b8 = 1);
    NONFAILING(*(uint8_t*)0x200036b9 = 0x10);
    NONFAILING(*(uint16_t*)0x200036ba = 0xa8);
    NONFAILING(*(uint8_t*)0x200036bc = 5);
    NONFAILING(*(uint8_t*)0x200036bd = 8);
    NONFAILING(*(uint8_t*)0x200036be = 1);
    NONFAILING(*(uint8_t*)0x200036bf = 0);
    NONFAILING(*(uint8_t*)0x200036c0 = 4);
    NONFAILING(memcpy(
        (void*)0x200036c1,
        "\xd5\x6f\x24\x07\x79\x93\x77\xbd\xe7\xea\x7f\x71\x55\xcf\xc0\xfd\x0c"
        "\x2c\xc7\xc7\x2f\x82\x07\x8f\x79\x58\xe4\xb4\x2c\x37\x87\xfc\x76\x60"
        "\x72\xf4\xc2\x25\x0b\xda\x03\x06\xa3\x07\x4d\x98\x4f\xd5\x45\x1d\x0d"
        "\xa3\x00\x1d\x04\x8f\x3e\x30\xee\xe7\x5a\xc6\x46",
        63));
    NONFAILING(*(uint8_t*)0x20003700 = 0x69);
    NONFAILING(*(uint8_t*)0x20003701 = 0x23);
    NONFAILING(memcpy(
        (void*)0x20003702,
        "\xb8\xb3\x7c\xa9\x81\xa7\xa4\x1f\x35\x1d\xb0\xdc\xc9\x7b\xc6\xb1\x27"
        "\x3a\x18\xb1\xb1\xbb\xae\x1a\xd1\x8c\x95\x3a\x94\xd3\xcf\x22\x50\x8e"
        "\x15\x76\x17\x4d\xfc\x0e\x86\x95\x6a\x07\x47\xb8\x6f\x57\x8c\x5d\xb4"
        "\x56\xb9\x75\xfe\xa0\xb9\x35\xb8\xef\x00\x30\x51\x45\xda\xc2\x35\x41"
        "\x9b\x81\x18\x4c\xee\x83\x08\x7f\x9b\x23\x51\xfc\x12\x36\xe6\x99\x17"
        "\x96\xea\x34\xc8\xd8\x6f\x84\x42\xf4\xac\x2f\xf0\x4f\x74\x7b\x09\x6a"
        "\x7e\x71\x27\x82\x88\xed\x86\x4c\xdf\xb9\x95\x05\x1b\x3d\x62\xcf\xc5"
        "\xd6\x2f\x92\x20\x18\x8c\x5e\x83\x6f\xc2\x9e\xc8\x23\x99\x34\x68\xae"
        "\x25\x20\xa8\x7d\x7f\xe8\x3e\x23\x9b\x38\xab\xfc\xa1\xa8\xe9\x12\xcf"
        "\xe9\xe6\x6e\x54\xad\xb8\x74\xfc\x98\x2c\xab\xac\x30\x37\xba\x52\x8d"
        "\xc9\x8c\x2d\x7a\x93\x49",
        176));
    NONFAILING(*(uint8_t*)0x200037b2 = 9);
    NONFAILING(*(uint8_t*)0x200037b3 = 5);
    NONFAILING(*(uint8_t*)0x200037b4 = 0x80);
    NONFAILING(*(uint8_t*)0x200037b5 = 8);
    NONFAILING(*(uint16_t*)0x200037b6 = 0x377);
    NONFAILING(*(uint8_t*)0x200037b8 = 1);
    NONFAILING(*(uint8_t*)0x200037b9 = 1);
    NONFAILING(*(uint8_t*)0x200037ba = -1);
    NONFAILING(*(uint8_t*)0x200037bb = 0);
    NONFAILING(*(uint8_t*)0x200037bc = 0x21);
    NONFAILING(memcpy(
        (void*)0x200037bd,
        "\xf0\xdf\x30\xf6\xc9\xaf\x83\xe0\xec\xe8\x7c\xd1\x0f\xa7\x8d\x62\x0f"
        "\x82\xac\xc2\xdf\xeb\x4d\x8d\x80\x39\xb0\x27\x35\xff\x77\xd5\xbf\xa8"
        "\x96\x2c\x0d\x13\x54\x30\x3a\xec\xa6\x60\x83\xef\x35\x48\x90\xa4\xbc"
        "\x25\x63\x13\xa0\x79\x02\x19\xba\xa4\xbf\x71\x69\xb2\x90\x28\x63\x3a"
        "\xdf\x38\x69\x5f\x34\xd7\xf5\xc4\x8a\xf3\x2d\x9d\xaa\x8a\xc8\xc7\x4c"
        "\xb5\x2d\x80\x5d\xa9\x63\x9f\x2f\xe2\x1c\x05\xa9\x9d\xcc\xc4\x4e\x27"
        "\x3b\x38\x95\x35\x19\xbe\x22\xa6\x9e\xcb\x05\x0f\x12\xaa\xb7\x8e\x9b"
        "\x30\x32\xc7\x10\x33\x85\x26\x61\x43\x51\x91\x5b\xeb\x71\x94\x53\xa3"
        "\x79\x06\xde\xfc\x4b\x9f\x5b\x4e\x8f\x06\x52\x6f\x24",
        149));
    NONFAILING(*(uint8_t*)0x20003852 = 9);
    NONFAILING(*(uint8_t*)0x20003853 = 5);
    NONFAILING(*(uint8_t*)0x20003854 = 4);
    NONFAILING(*(uint8_t*)0x20003855 = 3);
    NONFAILING(*(uint16_t*)0x20003856 = 0x252);
    NONFAILING(*(uint8_t*)0x20003858 = 3);
    NONFAILING(*(uint8_t*)0x20003859 = 5);
    NONFAILING(*(uint8_t*)0x2000385a = 0x53);
    NONFAILING(*(uint8_t*)0x2000385b = 9);
    NONFAILING(*(uint8_t*)0x2000385c = 5);
    NONFAILING(*(uint8_t*)0x2000385d = 0xb);
    NONFAILING(*(uint8_t*)0x2000385e = 2);
    NONFAILING(*(uint16_t*)0x2000385f = 0x25f);
    NONFAILING(*(uint8_t*)0x20003861 = 0x4c);
    NONFAILING(*(uint8_t*)0x20003862 = 0);
    NONFAILING(*(uint8_t*)0x20003863 = 0);
    NONFAILING(*(uint8_t*)0x20003864 = 0);
    NONFAILING(*(uint8_t*)0x20003865 = 0xf);
    NONFAILING(
        memcpy((void*)0x20003866,
               "\xea\xdb\xbc\xee\xdf\x36\x1c\x56\xd7\x6e\x9c\x7e\xa4\xdd\xf2"
               "\x2f\xf1\xe7\x61\x2d\xe5\xb5\x3f\xae\xc4\xeb\xde\xcd",
               28));
    NONFAILING(*(uint8_t*)0x20003882 = 0);
    NONFAILING(*(uint8_t*)0x20003883 = 0xd);
    NONFAILING(memcpy(
        (void*)0x20003884,
        "\x8d\x5c\xd0\x2a\xca\xfe\xf3\x95\x7f\xb1\x2d\x87\xf2\x99\x99\x03\x1c"
        "\x9e\xc9\x34\x04\xff\xa2\x0a\x1f\x81\xd7\xda\x7d\xcc\x51\x88\x94\x7f"
        "\x67\x61\xf7\xff\xb6\x1c\x40\x73\x4d\x9a\x23\x96\xa4\x88\x89\x7b\x4b"
        "\x57\xa0\x51\xfb\xfb\x21\x11\x23\x91\x9b\x71\xb1\x5c\x98\x65\x89\xa7"
        "\xa8\xe0\xff\xe5\xd9\x7a\xc1\x65\x39\x83\xc5\x81\x7b\xad\x32\x61\xa7"
        "\x5b\xe8\x24\xe6\xf7\x24\x38\xec\x64\x31\x27\x64\x59\xfd\x54\x03\x4b"
        "\x11\x51\xd7\xc1\x50\xc3\xc2\x15\x9f\x75\x20\xcf\x6f\x7a\x32\xe9\xc0"
        "\x0d\xf6\x36\x1b\x99\x94\x44\x48\xdb\x95\x53\x1d\x4d\x61\xd7\x8d\xb3"
        "\x5f\xd5\x59\x7d\x6f\xf4\x2e\x47\xd2\x7b\xc0\xec\x38\xa3\x0b\xc4\xf9"
        "\x36\x7a\x21\x8f\x44\x2f\x6d\xf4\xcd\x8f\x23\x85\xb7\x0c\xff\x4b\xb4"
        "\x6c\x41\xb1\x9e\xcb\x4c\x13\x96\x8e\x33\x80\x5b\x30\x65\xf2\xbe\xa2"
        "\xe4\x0e\xea\x3c\x75\x05\x34\x7e\xe6\x23\x84\xb2\xf3\xb0\xb3\xd2\xbe"
        "\xcf\xa2\xa6\x1c\x09\xc7\x44\x57\xff\x8d\xc5\x53\xc3\xde\x1f\x04\xd3"
        "\x83\x71\x46\x83\xf3\x8f\x39\x1c\x5e\xfe\x96\x34\x19\xc8\xf2\xc7\xea"
        "\xa1\x2d\xd0\x68\x1e\xd0\x86\x91\xd2\xe0\xd8\x1b\xef\xcb\x5f\x7b\x1d"
        "\x78\x34\x41\xe7\x7a\xbb\x5b\xec\x27\xba\xa3\xa4\x8b\x0d\x71\xa3\xa8"
        "\xf0\x10\xcc\x93\xc8\x93\x21\x8d\xca\xe7\x5f\x52\xa8\x9b\x16\x19\xec"
        "\x5b\xc2\x64\x6d\xaf\xfb\x43\xb2\x09\x93\xa6\xc4\x64\x3b\xa6\x35\x4d"
        "\xf4\x63\xf9\x23\xaa\x62\x4d\x77\x2d\xa0\x28\xec\x23\xd1\x02\x1c\xc5"
        "\x03\x83\x89\x03\x73\xa2\x79\xb3\x29\x05\x98\xf3\xc1\xf7\xa9\x2e\x4c"
        "\xe2\x39\x9f\x6e\x5b\x91\xe5\xe6\x80\x3d\x7b\x2e\x2a\x53\xe4\x40\x29"
        "\x3c\x4b\xc8\x54\xdc\xc1\xd3\xbc\xcc\x51\x19\xa4\x35\x69\xa4\xe1\x66"
        "\x5a\x94\xfe\x9a\xa1\x3b\x11\x50\x96\xd9\x25\x48\x04\x6e\xf1\x08\xa9"
        "\x69\xa3\x22\x43\x2e\xee\xc5\x7f\x35\x81\xf6\xd7\x0d\x83\xa9\x67\x31"
        "\x6f\x85\x39\x6c\x1e\xe9\xf6\x48\x02\x77\x3b\x31\x55\xeb\x34\x33\x28"
        "\x34\x15\xb2\x8a\xee\x79\x06\x63\xb9\x57\x82\x50\x23\x62\x97\xc8\x12"
        "\x00\x21\x6e\x31\xfc\x75\xb0\xb3\xc5\x70\x4f\x85\x04\xce\x31\xb6\x0c"
        "\xc9\x1f\x46\x7f\x72\x8f\xc4\x56\x25\x85\xef\x89\xc1\x05\x5b\x6b\x61"
        "\x59\xff\xd4\x6d\x2c\x3c\x4d\x6b\xb8\x42\xdf\x57\xae\xaf\x4f\xb4\x57"
        "\x77\xfc\x77\x24\x7f\x3f\x2f\x94\x6a\xed\x04\xe8\xa3\x3e\xd1\x83\x7f"
        "\x2b\x68\x99\xb3\x5a\x63\x89\xd4\x35\x94\x74\x35\x93\x6f\x01\x8e\xc8"
        "\xe1\x9f\x8e\x07\xb7\xd5\xf5\x96\xa1\x58\xbf\x3d\x8e\x41\x29\x4b\x1a"
        "\xa7\x6d\x4d\x24\x18\x80\xd5\xe7\x5f\xe0\x37\xd9\x44\x52\xfb\xb8\xac"
        "\x13\x41\x39\xc9\xec\x4d\x2a\xd7\xdb\xf7\x0e\xc2\xaf\x3f\xf8\x94\x15"
        "\x83\x11\xb9\xd0\x92\x47\xe1\xf1\x54\x20\xcf\x1a\xd3\x85\xff\xe7\xd2"
        "\x05\xb1\x48\x74\xe1\x41\xfd\xf4\x04\xb4\x22\x2a\x80\x1e\xc8\xd4\xf9"
        "\x4b\xd6\xcf\x1e\x1f\x88\x18\xd8\x7f\x19\x40\x98\xcc\xf3\x88\xe8\x3f"
        "\xcb\x47\x6b\x4a\x2b\xb6\x3e\xa0\x0e\x55\xe6\x99\x0b\x96\x60\xa4\x97"
        "\x82\x9b\x07\x4b\x34\xc4\xd2\xb5\xd9\x1f\x55\x71\x9f\xa5\xc0\xed\x03"
        "\xca\x7a\xc7\xb4\xde\x9f\xa0\x21\x17\x9a\x0b\x9d\x7f\xee\x82\x8e\x40"
        "\xac\x31\xeb\x72\xf0\xe3\x6a\x72\xf6\x34\xd9\xe2\x8d\x3e\x0f\x1a\x2b"
        "\x4c\x6d\x01\x17\xbc\x16\xdd\x60\x61\x0d\x5b\xce\x62\x74\x3a\x58\x18"
        "\xd5\xc3\x37\x0e\xa7\x1c\x44\x20\x2d\xf8\x5a\x0f\x92\xfa\x04\x4c\x50"
        "\xa1\x0e\x67\x21\x15\xc6\xac\x12\xb8\xfc\x13\xa2\xe9\x97\x5e\xd8\xda"
        "\x55\x88\x47\xa7\xe8\xed\x28\x86\x0e\xc3\x07\xd9\x8e\x28\xd0\xde\xf9"
        "\x86\xe4\xf1\x45\xb4\xa3\xc5\xe6\xa1\x6a\x38\xb9\x54\xe4\xef\x6f\x4f"
        "\xcc\x3f\xfe\x27\xe6\xda\xbe\xb9\x39\x28\x52\x17\x19\xa2\x5a\x3e\x03"
        "\xce\x15\x1d\x75\x2a\x3b\x87\xe9\x47\x54\x2b\x7e\x0d\x31\xe7\x45\x54"
        "\xe2\xec\xc4\x4d\xb2\xde\xd3\x99\xc5\x7f\xe5\x0b\x5c\xb5\x98\x7e\xac"
        "\x3c\x4c\x5d\x97\xc8\x82\x81\x44\xa0\xcd\xbf\xf8\x64\xdd\x0f\x61\xb2"
        "\xe5\x0a\xa2\x8c\xb1\x6a\x62\xd0\xbc\xb4\x9c\xed\x92\x07\xc6\xe6\x61"
        "\x8d\x60\x9e\x6f\x2f\x85\xe6\x88\x02\x76\x57\xcb\x1a\x90\xea\x5b\x9c"
        "\x8c\x6d\x63\x99\x06\x7f\xda\xc0\x73\x95\x33\x2d\xf3\x8f\x58\xf5\x98"
        "\x3a\x0f\xf9\x74\xdd\xd1\x7b\xa2\xdb\xb4\x8b\x33\x8e\x6e\x90\x84\x4f"
        "\xfa\xd0\x12\x35\xeb\x5d\xb0\xf5\x87\xdb\x3c\x1a\x74\x22\x2e\xc3\x60"
        "\xa5\x44\x2d\xf0\xba\x76\x93\x61\x19\xc1\xc9\x58\x80\xb9\x8d\xf1\xea"
        "\xd2\x92\x17\x6c\xaf\x6b\x11\x95\xc5\xdb\x74\x02\x1f\xd8\x06\x63\xf6"
        "\xec\x20\x2a\xce\x68\xd6\xba\x13\xc9\x05\xef\xc2\x29\xf6\x72\xd4\xfa"
        "\x54\xe6\x14\xcd\xe7\xcc\x65\x49\x8e\x1f\x00\x03\x78\x35\x1d\x47\x7b"
        "\x3e\x66\x8d\x9d\xa3\x0c\x9d\xba\x95\x62\x63\x45\x12\x6f\xd0\xcb\xf6"
        "\xc3\x4c\xd1\x4a\x1e\x23\x1f\x7e\x71\x43\xf7\x30\x0e\xa3\xdb\x5b\xcd"
        "\x72\x8d\x48\xaa\x9d\x37\xf4\xe8\x49\x38\x32\x4a\xb9\x76\x53\x21\x6b"
        "\xc4\x7d\xf2\xc3\x98\x35\x5f\xc3\x87\x6b\xde\x5f\xe1\x39\xe9\xd9\xb0"
        "\x93\x92\x6c\x43\xfb\x19\xc5\x49\xee\xa2\xc0\x8d\xd8\x0d\x05\x54\x71"
        "\x91\x2f\x57\x7d\x90\x92\x35\x81\x48\x15\x33\x3c\x82\x59\x2d\xbd\xfe"
        "\xeb\x6b\xe1\xc8\x84\xcc\x6a\x24\x82\x71\x51\x3e\x23\xcc\x76\xc2\xbb"
        "\x16\x6f\xde\xd8\x20\x26\xa0\xf6\x40\xbe\x42\x64\xce\x31\x96\xcd\x9e"
        "\x37\x83\xf7\x40\xc8\xef\xc3\x74\xca\x2b\xc1\x72\x73\x87\xde\x0f\x73"
        "\x1d\x61\x54\xc2\x7a\x3e\x59\x1f\x13\x6e\x4e\xdf\x41\x35\xc8\x22\xe1"
        "\xe5\x65\xe7\xd5\x6c\xeb\x94\x2a\xe2\xd3\x48\xa0\xb7\xa0\x28\x61\x16"
        "\x96\xdb\xc1\x67\x56\xbb\x78\x84\x7a\x86\xc3\x0e\x1f\x26\x6a\xa3\xa5"
        "\xa2\xa3\x38\x32\xa5\xdc\xa0\x13\x80\xe1\x95\xc2\xa3\x56\x88\xac\x11"
        "\x73\xeb\x6a\x97\x86\xf0\x03\xde\x89\x4e\xc3\xb3\xce\x66\x44\x50\x8e"
        "\xad\x2a\xc0\x38\x24\x4f\x6f\xc5\xaa\x2a\xaa\x86\x44\xc4\xfe\xbe\x09"
        "\xbf\x27\x9b\xed\xed\x3c\x3d\x04\xee\x4f\x0c\x03\xce\xf3\xfc\xd2\x26"
        "\x1a\xdf\x88\xa5\x38\xaf\xa9\x1d\xa8\x17\xf1\xa4\xf1\x44\x5a\x43\xbb"
        "\xd9\x2e\xbf\xc8\x7e\xf7\x06\xac\xbc\x80\x5e\x22\x7d\x7b\xa5\xf2\x18"
        "\xe4\x4f\xed\xa9\xb8\xf8\x05\x56\x5d\x83\x91\x4b\x20\x7d\xad\x61\xc8"
        "\x88\x09\x9d\x20\xbc\xf2\x45\xf2\xbd\x8c\xb8\x2f\x00\xef\xa0\x0b\xef"
        "\x77\x3f\xa5\x24\x3f\x0e\xbc\xaf\xe0\x4d\x7b\x9a\xe2\x61\x54\xad\x3d"
        "\x5f\xba\xb5\x66\x41\x97\x6c\xc3\xaa\x19\xf3\x2c\xc3\x67\x4a\x73\x71"
        "\xa2\xb1\x52\x82\x32\xbd\x85\xbf\x09\x72\xe1\xa1\x0b\x62\xca\x9e\xa8"
        "\x96\xd5\x28\x18\x01\x72\x3e\xba\x98\x9a\xfc\x46\x33\xe4\x4f\x0c\xf8"
        "\xda\xbf\x6c\x3e\x95\xf3\x6e\xd0\xa5\xb1\x71\x16\x54\x5f\x4c\x2b\xc2"
        "\x51\xf0\xfa\x19\x41\x5f\x49\xb6\xd4\xac\xed\xfa\x1c\x8e\x93\x5f\xea"
        "\x64\x66\xa9\x87\xa3\x2b\xe4\xf8\x07\xf1\x34\xfb\x86\xc1\x42\xb4\x13"
        "\x81\xf8\xac\x7e\x1c\xf2\xa8\x0a\x8c\x41\x6d\x25\x9b\x80\xc4\xda\xd3"
        "\x2a\x88\x2c\x3b\xa9\xfd\xa8\xbb\xa4\x6b\x3d\x32\x4e\x10\xb9\x22\xb2"
        "\x90\x4e\xac\xde\x2d\xb9\x1e\xf7\x6d\xe2\x43\x5c\xee\xde\x60\xb9\x2e"
        "\x60\x28\xcd\x9c\xec\xb0\x82\xfe\x33\x3a\xaf\xf9\x81\x14\xd7\x33\xa9"
        "\x66\x70\x1c\x23\xc9\x29\x57\xb1\x27\x1c\x13\x6d\xa9\x12\x21\xed\x8d"
        "\x9c\xad\x41\xa2\x67\x01\x07\x29\xd6\x36\x08\xdb\x76\x84\x5c\xc6\xf3"
        "\x27\xeb\xc4\x85\xa3\xf3\xfa\x26\x85\xc2\xe3\x54\x0e\x9e\xa5\x74\x5b"
        "\xee\x9e\x62\xb7\xaf\xa7\xba\x2e\x4d\xd0\x57\x8b\x9f\x07\x91\x7b\x49"
        "\x95\xed\x52\x2c\x3f\xbc\xf6\xbe\x27\xdb\xd3\x33\x6e\x67\x7d\x3d\xaf"
        "\xfb\x14\xf9\x3a\x87\xa3\x54\xce\x1e\xb1\x18\x71\x5e\x2f\x33\x9e\xcb"
        "\x61\x7e\x38\x26\xa9\x38\xc8\x7a\x67\x85\x75\xc1\x9e\x50\xb0\xf4\x10"
        "\xa9\x96\x9a\x9b\xbb\x64\x08\x3f\x36\x5c\x94\x4d\x66\x88\x55\x8e\x36"
        "\xde\xf5\x98\xb0\x83\xe0\xd2\x1f\xf3\x81\x74\xad\xd9\xc5\x50\x92\x07"
        "\x12\x9f\x08\x5b\xe1\x55\x80\x47\xdd\xab\x06\xe3\xa8\x83\xb7\xc9\xbb"
        "\x55\x87\x72\x43\x2e\x75\x9c\xcc\x0f\x02\x6a\xeb\xe6\x87\x6f\x5b\xe4"
        "\xb7\xcf\x8b\x2c\xf9\xf5\x6a\x07\xc5\x7e\xb4\xef\x11\xf5\x9f\x1b\xd4"
        "\x3a\x21\xee\xed\x3c\x5e\x57\x77\x3c\x22\x0f\x0c\x5c\x1f\x77\x04\xa2"
        "\xc2\xee\xfd\xf6\x67\x6b\x6f\x1b\x42\x82\x7a\xb0\x4f\xb0\x64\x7b\x9c"
        "\xf0\xe9\x6d\xbf\x4d\x7b\x99\x5f\x2d\x36\x04\x25\x41\x53\xc6\x36\x26"
        "\x1a\xf5\x53\xaf\x6f\x35\x51\x3a\x9e\x5c\x9c\xc5\x90\x5d\xd6\x3e\x89"
        "\x65\xde\xf4\x97\xa9\x8c\x38\x76\xd7\x92\xc0\xb8\x0f\x4d\x4b\x53\x92"
        "\x6a\x3d\xc1\xc1\x84\xfd\xc4\xab\x7f\x5e\xe2\x1a\x4f\x61\xef\xf3\x4c"
        "\xe3\x2b\xca\x4d\xd3\x67\xa6\xc9\x8c\xc9\x13\x72\x02\x39\x5e\xdd\x99"
        "\xaa\x5e\x63\x0c\xe2\x5a\x2e\xff\xf3\x4b\x8e\x60\x4b\xc6\xa2\x7f\x69"
        "\x86\xd2\xf2\x41\x7b\x4b\xc0\xc5\xb1\x24\xae\xf9\x4e\x4d\xf0\x23\x75"
        "\x5e\xa5\x31\xa2\x52\x78\x47\x46\x12\x78\xf4\xd4\x4b\x8c\xee\xfb\x1d"
        "\xc2\x67\x2a\xf4\xa6\x07\x5b\x45\xf5\x0d\x78\x8d\xa5\xee\x3e\x59\xac"
        "\x08\xae\xed\xf7\x1e\x4c\xaf\x29\xbd\xe4\xbe\x5c\xd5\x70\x25\x75\x4a"
        "\x29\x24\xe7\x56\x3c\x3c\x0f\xd2\x0e\x94\x8c\x64\x24\x19\x6b\x75\xd2"
        "\x16\xce\x4e\xe8\xa8\x5c\xef\x63\xa8\x32\x58\x44\x42\x62\x38\x1d\x0b"
        "\x53\xc1\x4b\x1d\x5d\x22\xa1\x5f\x33\x59\x75\xdb\x8d\x98\xd9\xf2\x8e"
        "\xa2\x3d\x8e\x94\x9e\xda\x96\x76\x6a\x90\x1c\x5c\x86\xe7\x1e\xb7\x1c"
        "\x47\x78\xdc\x87\x88\x38\xa5\x8a\x5b\x8c\x2e\x07\xe6\x1b\x8c\xb6\x99"
        "\x96\x31\xbe\xa3\xa8\xd8\x81\xc3\x7b\x8e\xae\x3d\x02\x40\xab\x7e\xbd"
        "\xfc\x3a\xa0\x42\x6c\x3a\x76\xb5\xed\xc1\x95\xef\x89\xa7\xfd\x4e\xd9"
        "\x51\xfe\xed\x5b\xa0\xa4\x30\xd7\xfb\xe1\x10\xaf\x47\x88\x0a\x54\x5a"
        "\x7c\x0d\xe9\x80\xd9\x17\xb1\xd4\xf6\x9c\x6c\x93\xe3\x98\x7a\x86\xfd"
        "\x8f\x12\xf8\x66\x2c\xc1\x2f\x13\xbc\x39\x80\x95\xaa\x9d\x0d\xcd\x20"
        "\x05\x01\x22\x37\x2f\x16\xc3\x95\xa7\xed\x82\x42\xd3\x2b\x06\xfb\xca"
        "\x49\x2d\x5c\x97\x47\x91\x54\xaf\x14\xca\x7e\x38\xc7\xbb\xe3\xc6\x48"
        "\x93\xdd\x84\x19\x5d\x8e\xb8\x6a\xd7\xd2\x12\x3b\x96\xfc\x8e\x92\x8a"
        "\x77\x66\xcf\x08\xd8\x5b\x54\xbd\xca\x6e\x3f\xe7\xfc\x36\x50\x74\x9e"
        "\x10\xbd\x8d\xb0\xb7\x8a\x5c\x69\xe3\x9b\x82\xd3\x7c\x44\x51\xf6\x09"
        "\x54\xc3\xdd\x3a\xc7\x76\xd8\x4f\x30\x4f\x5f\x07\xf1\xc3\xc2\x51\xb4"
        "\x07\x20\xe2\x0f\x32\x10\x6f\x7d\x3a\x8c\xd2\x3b\x5f\x38\x13\xa5\xfc"
        "\x75\x6a\x9d\x6d\x99\xc1\xce\x4e\x93\xdb\xd1\x24\xa5\xc0\x9b\x5f\xc7"
        "\x44\x1b\x3b\xb3\xa2\xd3\xe4\x40\xb0\xe3\x4e\x85\x84\x24\x32\x75\xad"
        "\xf3\xab\x7c\xc4\xf1\x32\x27\xfd\xfe\xbf\x1e\x53\x3b\x7b\x7f\xce\x3b"
        "\xfc\x1a\x97\xd0\x08\xfd\xe5\x7e\x50\xac\x1f\x36\x1a\x86\x24\xe7\x98"
        "\xee\x17\x78\x9b\x4e\xaf\xbb\x29\x47\x32\x58\x69\x92\x8a\xb3\xef\xac"
        "\x33\x99\x06\xaf\x45\xd6\x25\x5d\x3c\x5c\x1d\x7a\xa6\x58\x33\x29\x47"
        "\xcf\xbc\x05\xb3\xd9\x55\x94\x42\xcd\x9b\xfd\xe5\xea\x69\x77\xf7\x91"
        "\xb9\xd3\x84\x26\xa3\xe8\x23\x0e\xf3\x6e\xa1\x0e\x56\xd1\x96\x71\xee"
        "\x68\xff\x2e\x3b\xe9\xa7\x72\x7f\xc4\x21\xb4\x1d\x86\x94\x0b\xcd\x1a"
        "\x9c\x9e\x61\x50\x6e\x34\x3c\x04\xe9\x6d\x23\xa8\x5c\xc8\x7f\xb6\x6b"
        "\xff\x9a\x67\xfb\xf3\xe4\x57\xe4\x0d\xea\x08\x08\x9d\xa6\xaf\x7b\x6f"
        "\xd5\xcb\x54\x5c\xab\x1d\x47\xc8\xb7\x23\x26\xa5\xa5\xd4\xbe\x50\x16"
        "\x87\x3c\x11\x4f\x66\xbb\x75\xa3\x1f\xb9\x62\x8b\xcb\x27\x01\x9e\x47"
        "\x06\xb7\x86\x1a\x79\xcb\xfd\x5f\xa3\x42\x79\x1b\x7e\xda\xa8\x5d\xd8"
        "\x63\x82\xc3\xd0\x85\x56\xd6\x23\x16\xd3\xce\xc9\x8d\xc4\xb6\x03\xcd"
        "\x00\xc7\xe5\x94\x34\xe0\x0a\xbe\xcb\x2a\xaf\x48\x9a\x04\x6a\xb5\xf8"
        "\x75\xbc\xb0\xaf\xe5\x8e\x96\x1a\xda\x82\xd7\xee\xe7\x0d\xeb\x8f\x06"
        "\xcf\x9f\x61\x31\xc0\x1b\x61\x89\x2e\xef\x3d\xfb\x8e\x33\x11\x29\x94"
        "\xfa\xa2\xd4\x3a\xa8\xaf\x8f\xfd\x6d\x24\x35\x69\x7c\x5f\x63\xd6\x0b"
        "\x77\x0c\xed\xa6\x64\x95\x61\x0a\x98\xbb\x22\xf1\x4c\xe8\xd5\x0d\x8f"
        "\xf5\xde\x7b\x20\xcd\xa7\xf3\xfd\x8c\x80\x4f\x64\xbc\x54\xd5\xd0\x4d"
        "\xcf\xd4\xf8\x3a\x09\xbb\xb2\xb3\xf5\x16\x4e\xab\x1c\xe3\xe7\xc7\xc8"
        "\x22\x66\x32\x70\x43\xf6\xb2\x1a\x29\xeb\x53\x19\x2d\x62\x45\xfe\x80"
        "\xc9\x5e\x5e\xe0\xb3\xd2\xf0\x09\x29\x7f\x25\x3a\xa5\x87\x90\x39\x19"
        "\xc6\xea\xc2\xa9\xc9\x97\xe4\x75\xbf\x6f\x9f\x72\x1a\xc1\x34\x4d\x39"
        "\x54\x12\x54\x4e\x11\x03\x23\xc6\xac\xe6\xbc\xfd\xfa\x5a\xb6\xda\x57"
        "\x0f\x30\x72\x62\xdc\x04\x94\x9e\x6d\x17\x3e\x63\x84\xaa\x8f\x30\x54"
        "\x87\x86\x9f\x4a\xf9\x18\xb1\x2b\x61\x32\xaa\x24\x35\xb7\xcc\x24\x7d"
        "\xd7\xb7\x50\xcd\x88\xe7\x51\x20\x41\x2d\x86\x82\x91\xcd\x4a\x39\xce"
        "\x5e\xc9\x4c\x2d\x07\xfc\x0d\xd1\x8a\xaa\x3e\x43\x65\xab\x36\x3f\xa5"
        "\x6a\xb7\x32\xd7\x9a\x04\x8e\x9e\xdf\xf9\x99\x17\x5c\x6b\x49\xcf\x61"
        "\x5c\xb9\x31\xbd\x67\x47\x1b\xa1\xba\x5a\xbc\x3a\xbf\x00\xd4\x72\x8d"
        "\x53\xc9\x7a\x7a\x1e\x25\x75\x92\x51\x2b\xf6\x76\xff\xa4\x9a\x9b\x47"
        "\x90\x2c\x09\x45\xcd\x43\xee\xdd\xce\x7f\xe5\x47\x4f\x52\x11\x4c\xf1"
        "\x0a\xd2\xf2\x04\x89\x08\xb6\x81\xc1\x30\x76\xe9\x70\x9d\x42\x73\x08"
        "\x1b\xe7\x89\x27\x32\x36\xd1\xc0\x42\xab\x61\x1e\x66\xb6\x85\x42\xa6"
        "\x51\xc3\x2d\x0e\xfc\x9e\xcb\x98\xbe\x27\xdf\x17\xa8\xd8\x8f\x89\x73"
        "\x21\xb3\x15\xa9\x1d\x57\x41\x37\xd7\x27\x8b\xfc\x9e\xc7\x60\xac\xb8"
        "\xfb\x4a\x63\x31\x2f\x62\x49\xed\x96\xa9\xb9\x8e\x16\x47\xf9\x15\x07"
        "\x7d\xaf\xdd\xae\x8c\xd2\x08\x0a\x90\x4e\x67\xbd\x29\xbc\xff\x2b\x88"
        "\xc9\x82\x14\x0a\xdb\x22\x00\x77\xff\x73\x5f\x4c\xa5\xb3\xc7\xe4\x93"
        "\x10\x7a\x70\x90\xab\x2e\x7d\xc9\x1f\xdf\x10\x03\xcc\xb7\x60\x69\xb4"
        "\xac\xa3\x72\x3f\xfe\xd9\xe9\x7e\x07\xe4\x0f\xcf\x1c\x57\x2f\xb6\xd3"
        "\x3c\xab\x94\x93\xb9\x9a\x26\x07\xfd\xf7\xa3\x98\x8c\x34\xe5\x07\x0d"
        "\x24\x4a\x36\x14\xee\x3d\x05\xd7\xb4\x4d\xfa\xa1\x1f\x30\x2e\x9a\xa7"
        "\x02\x9a\xce\x35\x9b\x2b\xa5\x6a\x99\x09\x60\xa9\x42\x00\x12\x31\x33"
        "\x89\xc2\x9c\x3f\xc1\xa3\x0d\x2b\x44\x8e\x74\x09\xec\x28\xbf\xa6\x7b"
        "\x7f\xa4\x82\xe9\xe0\x8e\xec\xc0\x75\x79\xaa\xd3\xc2\xfc\x12\x23\xd9"
        "\x49\xc9\x6d\x99\x33\x80\xb0\x41\xba\x52\xc9\x3d\x7c\xb7\x2a\xb5\x15"
        "\x13\x8e\x8b\xad\x87\x46\x5e\x6d\xb7\x76\xdd\xbe\xaa\xd1\x15\xe1\xd2"
        "\x47\xe1\xf6\x08\xd7\x58\xd2\x44\x46\x77\x34\x43\xea\x38\x82\xd6\xa8"
        "\xe8\x26\xa6\x55\x51\xe2\x7f\x6c\xc5\xad\x60\x59\x94\x23\x66\x35\x28"
        "\x35\xe7\xde\x07\x90\xd3\x8d\xb3\xa5\xaa\xb7\xe5\xe6\x48\x39\xc1\x4a"
        "\x8e\x82\x3d\x44\x98\x5b\x53\xcf\x6a\xe9\x51\x1f\xf6\x41\x9c\x9a\x55"
        "\x68\x8b\x48\xd0\x55\x64\xcc\xc6\x4c\xfa\x7f\xc5\x06\x22\x34\x9f\x7a"
        "\x9d\xde\xb9\x75\x6a\xae\xc3\x55\xf3\x65\x5b\xf6\xb2\x08\x37\x20\xf9"
        "\x2f\xbc\x80\xa1\x8a\x2b\x87\xbc\xcb\xd5\x43\xac\x1b\x7a\xac\x01\xed"
        "\x4e\xc2\x2d\x65\xa7\xfa\xd9\x9a\xad\x06\xa7\xd9\x25\x32\xea\xd0\xad"
        "\xab\x5e\xbe\x9c\x2a\x51\xf3\x16\xe0\x4d\xe3\x90\x99\x7b\xb6\x0f\x69"
        "\xa6\x2c\xb5\xbe\x13\xde\xd5\xcc\x8e\x8d\x30\xbd\x5f\x77\xf7\x8f\xd1"
        "\xa4\x09\xbf\xf6\x84\x8e\xb0\x1f\x98\xe9\x9a\x34\xf6\x32\x84\x7c\xac"
        "\xaa\x26\x61\x7a\x1c\x58\x28\xa0\xc4\x50\xe4\xb7\xb8\x72\x72\x75\x0e"
        "\x37\x1d\x61\x09\x57\x00\x06\x91\xd6\xd4\xbf\xc8\x90\x72\xc8\x0a\x9f"
        "\x93\x30\xcf\xe3\x1b\x8a\xb2\x21\x78\x42\x9d\x27\xaa\x79\x4c\xdf\xab"
        "\xc1\x9a\xe9\xaf\xc6\xba\x03\x42\x0e\x04\x8b\x98\x9b\x45\x03\x58\xbd"
        "\x12\x20\x5f\x15\x57\xc5\x89\xc4\x18\xee\xb6\x82\x29\x62\x03\xec\x7c"
        "\xd6\xd5\x7f\xd5\x02\x71\x6f\x2f\xaf\x90\x47\x95\x9f\xa3\x69\x40\x3d"
        "\xef\x03\xc7\x61\xaf\x0e\x1c\x3e\x6c\x99\x1f\xee\xad\x5e\x9e\xe1\x54"
        "\x4d\xab\x79\x2f\x33\x87\x49\x8c\x57\x40\x45\xff\x76\x12\x52\x7e\x8e"
        "\x8d\x7d\x60\x0b\xc3\x7e\xa2\xa2\x22\x7b\x35\x42\x2a\xc9\x33\xa0\x24"
        "\x5d\x1f\x0c\x09\x00\xcb\x4e\x3c\x63\x8e\x6d\x87\xe1\xee\xac\x5c\xd1"
        "\xb1\x6f\x9f\xfc\x21\xcb\xcd\x2a\x0b\x79\xa7\x02\x48\x76\x35\x46\x1d"
        "\x98\xfb\x54\x3e\xc8\x6a\x43\x30\x94\x5b\x5e\xb6\xcd\xce\x90\x55\x1f"
        "\x45\x8f\xf9\x05\x8c\x32\xf6\x78\x62\x0d\xb3\x60\xd4\x70\x96\x1b\x00"
        "\x0f\xf4\x4b\x54\x45\xe4\xe0\x0a\x5e\xd9\x63\xeb\x0d\x49\x59\x64\x9c"
        "\x3b\xaf\x37\x45\x0d\x7a\x9c\xff\x88\x8e\xb9\xb8\x86\xe1\x8b\x01\x6b"
        "\xf4\xa5\x81\xbe\x69\xe4\xda\x55\xd2\x60\xcd\x2d\x44\x70\xa2\x15\x27"
        "\xda\x28\xf0\x80\x5a\x2c\x5b\xf5\x57\x24\xb9\x99\x63\x5c\xe5\xb2\x73"
        "\xe8\x21\x9b\x68\xee\x67\xd0\x23\xe9\x05\x8a\x93\x05\x3c\x07\x5c\xc3"
        "\x3a\xba\x38\xcd\xda\xbe\x22\x3e\x56\x5e\x49\xab\x4c\xf4\xb0\x61\xce"
        "\xe8\xc6\x71\x9d\xfc\xc1\x5b\x23\x73\x3c\x9f\x32\x9b\x36\x13\x39\xf4"
        "\xe8\xb7\x8a\xf9\x1f\xb7\x6e\xcc\xc4\x2b\x20\xe9\x0c\xeb\xfe\x43\xae"
        "\x1f\xe4\x01\xc3\x64\x76\x7a\x5b\x57\x6e\x36\xc2\x15\x44\x25\x53\x20"
        "\xcb\xdc\xc4\x3c\xda\x5a\xe1\xdf\x3b\x7e\xbd\xf9\x37\x76\xcb\x38\x15"
        "\xd5\xfe\xec\x33\x81\xfd\xc4\xc5\x43\x82\xf5\x5b\x12\x04\x9e\x00\x06"
        "\xd5\xec\xea\x18\x81\xa1\x3d\x4d\x74\x37\x5d\x07\x8a\x0b\xc0\x3c\x78"
        "\x7c\x2f\x64\x52\x81\x34\x0f\x38\x74\xe6\x65\x16\x70\x07\x94\x01\xad"
        "\xb3\x30\xdb\x64\xa9\x82\x25\x61\x4e\x72\xae\xcf\x37\x2f\x54\x3d\xd6"
        "\xf1\x25\xae\xfa\xe8\x80\x4f\x29\x78\xce\x1d\xa8\x45\x50\x0b\xd4\xee"
        "\x7a\x98\x5f\x64\xee\xde\x52\xed\xb9\xfe\xa7\x08\xc8\x5f\xb8\x67\x70"
        "\x65\xdb\xbb\x98\x4e\xc4\xaa\xe6\x2d\x92\x78\xdd\x88\xec\x03\xcf\xcf"
        "\x4a\xff\x04\x2a\xaa\x68\x71\x4f\x07\xc0\xae\xb2\xe8\x42\x62\x2c\x8c"
        "\x96\x7b\x61\x4c\x93\xad\x90\xf5\xd0\x7e\x61\xbb\x7c\x06\x9e\x07\xbc"
        "\x21\xb4\xc3\x9d\x87\x01\x06\x81\x28\x41\xf5\x66\x44\xc1\x1a\x81\xdd"
        "\xc5\xdc\x38\x7b\xb6\xd2\xf7\x6a\x9f\x9f\x15\xf3\x39\x32\xf1\xc6\x6f"
        "\xa2\x0f\x86\xc6\x5b\x0b\x7b\x82\xb6\x4d\xed\x1b\x4f\x56\xb4\xa6\xe5"
        "\x5c\x98\xe6\x0a\x86\x96\xf5\x51\x55\xf7\xb8\x4b\xdd\xc1\x98\x8e\x56"
        "\x4c\x10\x57\x4f\x49\x03\x6e\x27\x3f\x37\xa1\x2e\x21\x29\x4c\x08\x9a"
        "\xae\x26\x75\xd7\x97\x23\x3f\x0b\xce\x20\x78\xd6\x56\x46\x14\x08\x6e"
        "\xab\x7d\xfd\x3c\x7e\x77\x82\x8c\x58\x88\x5e\x68\xba\xd2\x5f\x7a\xff"
        "\xcf\xd9\x40\xfa\x38\x0c\x95\x60\x0b\x47\xda\xb2\x6d\x33\x64\xb3\x57"
        "\xcb\x5e\xb0\x03\x06\x37\x24\x66\xaf\x78\x24\xda\xde\x60\x8a\x96\x3e"
        "\xe9\xeb\x5e\x13\xe3\xc8\xca\xaf\xdb\xde\x26\xa3\x05\x73\xce\xf5\xb1"
        "\xbc\xd0\x6f\x48\xfe\xc9\x71\xd2\xbf\xec\x54\x03\x1c\xe2\xa9\x84\x71"
        "\x5d\x3a\xb2\x06\x3a\x2e\x7f\xc6\x3c\xcb\x4c\xab\x36\xc3\xb0\x16\x98"
        "\x6d\x1d\x3b\x81\xe0\x23\x21\x7c\xb6\xed\x9f\xcc\x65\xe7\x6c\xc1\x67"
        "\x3c\xb3\x18\x1e\x27\xbc\x4c\x8b\xd4\xda\xee\x4a\x8f\xf7\x8b\x00\xf0"
        "\x9b\x17\x2a\x0f\xa3\x52\x6a\xb9\xc6\x3d\x06\xcc\x4b\xe3\x97\xa0\xf5"
        "\xf6\xd9\xab\xf6\xa8\xf2\x64\x5e\xc3\x60\xd4\x81\x00\x0b\x00\xa4\x94"
        "\xef\x18\x2c\x25\xaa\x3a\x61\xdb\xf1\xbe\x5d\xf5\x76\x39\x0d\x6f",
        4096));
    NONFAILING(*(uint8_t*)0x20004884 = 9);
    NONFAILING(*(uint8_t*)0x20004885 = 5);
    NONFAILING(*(uint8_t*)0x20004886 = 0xb);
    NONFAILING(*(uint8_t*)0x20004887 = 4);
    NONFAILING(*(uint16_t*)0x20004888 = 0x3e5);
    NONFAILING(*(uint8_t*)0x2000488a = 0);
    NONFAILING(*(uint8_t*)0x2000488b = 8);
    NONFAILING(*(uint8_t*)0x2000488c = 0x65);
    NONFAILING(*(uint8_t*)0x2000488d = 9);
    NONFAILING(*(uint8_t*)0x2000488e = 5);
    NONFAILING(*(uint8_t*)0x2000488f = 5);
    NONFAILING(*(uint8_t*)0x20004890 = 0);
    NONFAILING(*(uint16_t*)0x20004891 = 6);
    NONFAILING(*(uint8_t*)0x20004893 = 1);
    NONFAILING(*(uint8_t*)0x20004894 = 0x97);
    NONFAILING(*(uint8_t*)0x20004895 = 3);
    NONFAILING(*(uint8_t*)0x20004896 = 0);
    NONFAILING(*(uint8_t*)0x20004897 = 0xf);
    NONFAILING(memcpy(
        (void*)0x20004898,
        "\x4a\x5f\xdd\x22\xb6\x45\x47\xd6\x7c\x3c\x10\x11\x7e\xe1\xe3\x2d\xce"
        "\xbc\x54\x9b\xc8\x22\xce\x81\x09\xe9\x2d\x51\x80\x44\xfc\x76\xc0\x2a"
        "\xfc\xb4\x36\xd8\x3f\x30\x97\x1f\x81\xcf\x9a\x24\xbe\x5d\xd3\x0e\x3a"
        "\x2b\x75\x2f\x27\x21\x30\x52\xae\xbb\xd3\xfa\xc2\x61\x4e\xfb\xb5\x64"
        "\x47\xb6\x82\x19\x8b\xe0\xf3\x01\x31\x47\x6e\xe2\x38\x0a\xcf\x0b\x9e"
        "\xaf\xaa\xc7\xbb\xc2\xa8\x48\x8b\x24\x69\xd8\x1b\xce\xdc\x05\x6e\x22"
        "\x00\xf6\x88\x30\x8a\x92\xcb\xda\xcb\x52\x81\x22\xae\xc9\x97\x39\xaa"
        "\x6a\xaf\xb9\x3e\x2b\xab\x87\x77",
        127));
    NONFAILING(*(uint8_t*)0x20004917 = 9);
    NONFAILING(*(uint8_t*)0x20004918 = 5);
    NONFAILING(*(uint8_t*)0x20004919 = 0);
    NONFAILING(*(uint8_t*)0x2000491a = 0xd);
    NONFAILING(*(uint16_t*)0x2000491b = 0x297);
    NONFAILING(*(uint8_t*)0x2000491d = 2);
    NONFAILING(*(uint8_t*)0x2000491e = 4);
    NONFAILING(*(uint8_t*)0x2000491f = 0xfb);
    NONFAILING(*(uint8_t*)0x20004920 = 9);
    NONFAILING(*(uint8_t*)0x20004921 = 5);
    NONFAILING(*(uint8_t*)0x20004922 = 8);
    NONFAILING(*(uint8_t*)0x20004923 = 8);
    NONFAILING(*(uint16_t*)0x20004924 = 0x219);
    NONFAILING(*(uint8_t*)0x20004926 = 1);
    NONFAILING(*(uint8_t*)0x20004927 = 7);
    NONFAILING(*(uint8_t*)0x20004928 = -1);
    NONFAILING(*(uint8_t*)0x20004929 = 0x5c);
    NONFAILING(*(uint8_t*)0x2000492a = 0x22);
    NONFAILING(memcpy(
        (void*)0x2000492b,
        "\x2a\x3b\xaa\x25\xce\x5a\x51\xf4\xa6\xbd\x8b\x6c\x8c\x14\x29\xcd\xf7"
        "\x45\xf1\xb7\xc7\xd4\xfc\x2f\xec\x94\xe1\x3c\x5a\x8e\x16\xcf\x03\xc7"
        "\xac\x44\xc6\x6e\xdb\xef\x8c\x56\x24\x06\xbd\x5a\x2c\xbf\x37\xcc\x0f"
        "\x41\x40\x60\xff\xc9\x02\xdb\xc9\x4f\xa0\xe9\x89\x2a\x2d\xf1\x69",
        67));
    NONFAILING(*(uint8_t*)0x2000496e = 0);
    NONFAILING(*(uint8_t*)0x2000496f = 0x10);
    NONFAILING(memcpy(
        (void*)0x20004970,
        "\xda\xf3\x7a\x40\x6b\xc8\xf9\xe9\xe9\xff\xf3\x16\xf0\x77\x38\x9c\xeb"
        "\xde\x20\x97\x45\x3d\xee\xa9\x50\x72\xa1\x88\xe4\x72\x25\x35\xaf\xcf"
        "\x8a\xea\x67\x4e\x83\x0d\xb5\x7c\x52\xab\xef\x24\x1c\xf2\x2f\xad\xd8"
        "\x1c\xab\x7c\x0d\xa7\xd7\x7d\x62\x6a\xac\xd1\x55\x42\x59\x9f\xb6\x56"
        "\x82\x20\x38\x39\xe6\x1f\xf5\x6f\x15\xd6\xfb\xef\xe2\x26\x07\x09\xa0"
        "\xf3\xec\xe0\x74\x89\x46\x8d\x2a\x08\x32\x25\x24\x7c\x7b\xa7\x05\x23"
        "\x38\xb2\x5b\xc9\x15\x12\x04\x83\x0c\x3d\x63\xe3\xf7\xc5\x2f\x8e\x23"
        "\x1e\xdf\xd3\xb1\xd0\xcf\x5e\x11\x1a\x27\xde\x18\x09\x0c\x12\x0d\x68"
        "\x01\x34\xf4\x5f\xa2\x0c\x67\xfa\xc8\x6b\x2c\x30\xd8\x30\x61\x5d\x8d"
        "\x59\xce\x2f\x1a\xee\x72\xe3\x93\x39\x65\xd6\x56\x3e\x84\x91\x9f\xec"
        "\x3b\xf8\x23\x99\xcc\xb8\xf6\x0c\x40\xf0\x11\x71\xd1\x6c\x5f\xe5\xcc"
        "\x30\x19\xd4\xec\x45\xb6\x93\xbe\xbb\xd4\xc3",
        198));
    res = syz_usb_connect(1, 0x15, 0x20003480, 0);
    if (res != -1)
      r[0] = res;
    break;
  case 1:
    NONFAILING(*(uint8_t*)0x20000000 = 0x12);
    NONFAILING(*(uint8_t*)0x20000001 = 1);
    NONFAILING(*(uint16_t*)0x20000002 = 0x2b27);
    NONFAILING(*(uint8_t*)0x20000004 = 0xe6);
    NONFAILING(*(uint8_t*)0x20000005 = 0xef);
    NONFAILING(*(uint8_t*)0x20000006 = 0x51);
    NONFAILING(*(uint8_t*)0x20000007 = 0x10);
    NONFAILING(*(uint16_t*)0x20000008 = 0x2001);
    NONFAILING(*(uint16_t*)0x2000000a = 0x3c1f);
    NONFAILING(*(uint16_t*)0x2000000c = 0x8f6d);
    NONFAILING(*(uint8_t*)0x2000000e = 4);
    NONFAILING(*(uint8_t*)0x2000000f = 0x58);
    NONFAILING(*(uint8_t*)0x20000010 = 0);
    NONFAILING(*(uint8_t*)0x20000011 = 1);
    NONFAILING(*(uint8_t*)0x20000012 = 9);
    NONFAILING(*(uint8_t*)0x20000013 = 2);
    NONFAILING(*(uint16_t*)0x20000014 = 0x1f);
    NONFAILING(*(uint8_t*)0x20000016 = 1);
    NONFAILING(*(uint8_t*)0x20000017 = 0);
    NONFAILING(*(uint8_t*)0x20000018 = 7);
    NONFAILING(*(uint8_t*)0x20000019 = 0x10);
    NONFAILING(*(uint8_t*)0x2000001a = 2);
    NONFAILING(*(uint8_t*)0x2000001b = 9);
    NONFAILING(*(uint8_t*)0x2000001c = 4);
    NONFAILING(*(uint8_t*)0x2000001d = 0xbf);
    NONFAILING(*(uint8_t*)0x2000001e = -1);
    NONFAILING(*(uint8_t*)0x2000001f = 1);
    NONFAILING(*(uint8_t*)0x20000020 = 0x53);
    NONFAILING(*(uint8_t*)0x20000021 = 0x74);
    NONFAILING(*(uint8_t*)0x20000022 = 0xe0);
    NONFAILING(*(uint8_t*)0x20000023 = 0x80);
    NONFAILING(*(uint8_t*)0x20000024 = 9);
    NONFAILING(*(uint8_t*)0x20000025 = 5);
    NONFAILING(*(uint8_t*)0x20000026 = 0xc);
    NONFAILING(*(uint8_t*)0x20000027 = 0x10);
    NONFAILING(*(uint16_t*)0x20000028 = 0x19f);
    NONFAILING(*(uint8_t*)0x2000002a = 3);
    NONFAILING(*(uint8_t*)0x2000002b = 9);
    NONFAILING(*(uint8_t*)0x2000002c = 1);
    NONFAILING(*(uint8_t*)0x2000002d = 2);
    NONFAILING(*(uint8_t*)0x2000002e = 0x10);
    NONFAILING(*(uint8_t*)0x2000002f = 2);
    NONFAILING(*(uint8_t*)0x20000030 = 0x21);
    NONFAILING(*(uint32_t*)0x20000780 = 0);
    NONFAILING(*(uint64_t*)0x20000784 = 0);
    NONFAILING(*(uint32_t*)0x2000078c = 0xa8);
    NONFAILING(*(uint64_t*)0x20000790 = 0x200001c0);
    NONFAILING(*(uint8_t*)0x200001c0 = 5);
    NONFAILING(*(uint8_t*)0x200001c1 = 0xf);
    NONFAILING(*(uint16_t*)0x200001c2 = 0xa8);
    NONFAILING(*(uint8_t*)0x200001c4 = 2);
    NONFAILING(*(uint8_t*)0x200001c5 = 0x10);
    NONFAILING(*(uint8_t*)0x200001c6 = 0x10);
    NONFAILING(*(uint8_t*)0x200001c7 = 0xa);
    NONFAILING(*(uint8_t*)0x200001c8 = 7);
    NONFAILING(STORE_BY_BITMASK(uint32_t, , 0x200001c9, 1, 0, 5));
    NONFAILING(STORE_BY_BITMASK(uint32_t, , 0x200001c9, 4, 5, 27));
    NONFAILING(*(uint16_t*)0x200001cd = 0xf00);
    NONFAILING(*(uint16_t*)0x200001cf = 0x8000);
    NONFAILING(*(uint32_t*)0x200001d1 = 0x3f00);
    NONFAILING(*(uint8_t*)0x200001d5 = 0x93);
    NONFAILING(*(uint8_t*)0x200001d6 = 0x10);
    NONFAILING(*(uint8_t*)0x200001d7 = 0xb);
    NONFAILING(memcpy(
        (void*)0x200001d8,
        "\x49\xd0\xc0\x43\x10\x7f\x03\xf2\xef\x4b\xc1\x6f\x43\xac\x50\x84\x14"
        "\x34\xd1\x33\x5f\xa7\x49\x09\x36\x08\x44\x8c\x56\x37\x73\xd0\x99\xfe"
        "\xe0\xab\xf1\xe8\x58\x46\xb7\xbc\x9a\x57\x1e\xcc\xbc\x85\x1e\x9b\xb2"
        "\x34\x5b\xe0\x6e\xce\x9c\xd2\x87\x6d\x6a\xab\xc3\x69\xf7\x7e\x4d\x89"
        "\x30\x83\x9f\x78\x65\x57\x22\x4c\x4b\xcf\x27\xbd\x3e\x67\x27\x78\xe7"
        "\x51\xa3\x7e\x27\xf2\x94\x6c\xba\x6e\xbf\x40\x3d\x61\xa8\x2d\x5f\x43"
        "\x9b\xfd\x96\x53\x33\x18\xd0\x7a\x69\xf4\x57\x3c\x69\x09\x82\xa2\x48"
        "\xff\xe5\xc7\x11\x87\xa2\xbd\xee\x9e\x48\x23\x0e\x40\xe3\x38\x95\xbf"
        "\x3c\x13\xd4\xce\x82\x32\x59\xbf",
        144));
    NONFAILING(*(uint32_t*)0x20000798 = 9);
    NONFAILING(*(uint32_t*)0x2000079c = 2);
    NONFAILING(*(uint64_t*)0x200007a0 = 0x20000280);
    NONFAILING(*(uint8_t*)0x20000280 = 2);
    NONFAILING(*(uint8_t*)0x20000281 = 3);
    NONFAILING(*(uint32_t*)0x200007a8 = 0);
    NONFAILING(*(uint64_t*)0x200007ac = 0);
    NONFAILING(*(uint32_t*)0x200007b4 = 0);
    NONFAILING(*(uint64_t*)0x200007b8 = 0);
    NONFAILING(*(uint32_t*)0x200007c0 = 0);
    NONFAILING(*(uint64_t*)0x200007c4 = 0);
    NONFAILING(*(uint32_t*)0x200007cc = 4);
    NONFAILING(*(uint64_t*)0x200007d0 = 0x20000580);
    NONFAILING(*(uint8_t*)0x20000580 = 4);
    NONFAILING(*(uint8_t*)0x20000581 = 3);
    NONFAILING(*(uint16_t*)0x20000582 = 0x427);
    NONFAILING(*(uint32_t*)0x200007d8 = 0);
    NONFAILING(*(uint64_t*)0x200007dc = 0);
    NONFAILING(*(uint32_t*)0x200007e4 = 0);
    NONFAILING(*(uint64_t*)0x200007e8 = 0);
    NONFAILING(*(uint32_t*)0x200007f0 = 0);
    NONFAILING(*(uint64_t*)0x200007f4 = 0);
    NONFAILING(*(uint32_t*)0x200007fc = 0);
    NONFAILING(*(uint64_t*)0x20000800 = 0);
    syz_usb_connect(6, 0x31, 0x20000000, 0x20000780);
    break;
  case 2:
    syz_usb_disconnect(r[0]);
    break;
  case 3:
    NONFAILING(*(uint32_t*)0x200012c0 = 0x14);
    NONFAILING(*(uint64_t*)0x200012c4 = 0x20001140);
    NONFAILING(*(uint8_t*)0x20001140 = 0);
    NONFAILING(*(uint8_t*)0x20001141 = 0x33);
    NONFAILING(*(uint32_t*)0x20001142 = 2);
    NONFAILING(*(uint8_t*)0x20001146 = 2);
    NONFAILING(*(uint8_t*)0x20001147 = 0x11);
    NONFAILING(*(uint64_t*)0x200012cc = 0);
    NONFAILING(*(uint32_t*)0x20001500 = 0x34);
    NONFAILING(*(uint64_t*)0x20001504 = 0);
    NONFAILING(*(uint64_t*)0x2000150c = 0);
    NONFAILING(*(uint64_t*)0x20001514 = 0);
    NONFAILING(*(uint64_t*)0x2000151c = 0);
    NONFAILING(*(uint64_t*)0x20001524 = 0);
    NONFAILING(*(uint64_t*)0x2000152c = 0);
    syz_usb_control_io(r[0], 0x200012c0, 0x20001500);
    break;
  case 4:
    NONFAILING(*(uint32_t*)0x20000b00 = 0x2c);
    NONFAILING(*(uint64_t*)0x20000b04 = 0x20000840);
    NONFAILING(*(uint8_t*)0x20000840 = 0);
    NONFAILING(*(uint8_t*)0x20000841 = 0x30);
    NONFAILING(*(uint32_t*)0x20000842 = 2);
    NONFAILING(*(uint8_t*)0x20000846 = 2);
    NONFAILING(*(uint8_t*)0x20000847 = 2);
    NONFAILING(*(uint64_t*)0x20000b0c = 0);
    NONFAILING(*(uint64_t*)0x20000b14 = 0);
    NONFAILING(*(uint64_t*)0x20000b1c = 0);
    NONFAILING(*(uint64_t*)0x20000b24 = 0);
    NONFAILING(*(uint32_t*)0x20001080 = 0xac);
    NONFAILING(*(uint64_t*)0x20001084 = 0);
    NONFAILING(*(uint64_t*)0x2000108c = 0);
    NONFAILING(*(uint64_t*)0x20001094 = 0);
    NONFAILING(*(uint64_t*)0x2000109c = 0);
    NONFAILING(*(uint64_t*)0x200010a4 = 0);
    NONFAILING(*(uint64_t*)0x200010ac = 0);
    NONFAILING(*(uint64_t*)0x200010b4 = 0);
    NONFAILING(*(uint64_t*)0x200010bc = 0);
    NONFAILING(*(uint64_t*)0x200010c4 = 0);
    NONFAILING(*(uint64_t*)0x200010cc = 0);
    NONFAILING(*(uint64_t*)0x200010d4 = 0);
    NONFAILING(*(uint64_t*)0x200010dc = 0);
    NONFAILING(*(uint64_t*)0x200010e4 = 0);
    NONFAILING(*(uint64_t*)0x200010ec = 0);
    NONFAILING(*(uint64_t*)0x200010f4 = 0);
    NONFAILING(*(uint64_t*)0x200010fc = 0);
    NONFAILING(*(uint64_t*)0x20001104 = 0);
    NONFAILING(*(uint64_t*)0x2000110c = 0);
    NONFAILING(*(uint64_t*)0x20001114 = 0);
    NONFAILING(*(uint64_t*)0x2000111c = 0);
    NONFAILING(*(uint64_t*)0x20001124 = 0);
    syz_usb_control_io(r[0], 0x20000b00, 0x20001080);
    break;
  case 5:
    NONFAILING(*(uint32_t*)0x20001740 = 0x2c);
    NONFAILING(*(uint64_t*)0x20001744 = 0);
    NONFAILING(*(uint64_t*)0x2000174c = 0);
    NONFAILING(*(uint64_t*)0x20001754 = 0x20001640);
    NONFAILING(*(uint8_t*)0x20001640 = 0);
    NONFAILING(*(uint8_t*)0x20001641 = 0xf);
    NONFAILING(*(uint32_t*)0x20001642 = 0x36);
    NONFAILING(*(uint8_t*)0x20001646 = 5);
    NONFAILING(*(uint8_t*)0x20001647 = 0xf);
    NONFAILING(*(uint16_t*)0x20001648 = 0x36);
    NONFAILING(*(uint8_t*)0x2000164a = 5);
    NONFAILING(*(uint8_t*)0x2000164b = 0xb);
    NONFAILING(*(uint8_t*)0x2000164c = 0x10);
    NONFAILING(*(uint8_t*)0x2000164d = 1);
    NONFAILING(*(uint8_t*)0x2000164e = 0xe);
    NONFAILING(*(uint16_t*)0x2000164f = 0x20);
    NONFAILING(*(uint8_t*)0x20001651 = 4);
    NONFAILING(*(uint8_t*)0x20001652 = 1);
    NONFAILING(*(uint16_t*)0x20001653 = 0xf1df);
    NONFAILING(*(uint8_t*)0x20001655 = 3);
    NONFAILING(*(uint8_t*)0x20001656 = 7);
    NONFAILING(*(uint8_t*)0x20001657 = 0x10);
    NONFAILING(*(uint8_t*)0x20001658 = 2);
    NONFAILING(STORE_BY_BITMASK(uint32_t, , 0x20001659, 8, 0, 8));
    NONFAILING(STORE_BY_BITMASK(uint32_t, , 0x20001659, 5, 8, 4));
    NONFAILING(STORE_BY_BITMASK(uint32_t, , 0x20001659, 1, 12, 4));
    NONFAILING(STORE_BY_BITMASK(uint32_t, , 0x20001659, 0x7f, 16, 16));
    NONFAILING(*(uint8_t*)0x2000165d = 0xc);
    NONFAILING(*(uint8_t*)0x2000165e = 0x10);
    NONFAILING(*(uint8_t*)0x2000165f = 0xa);
    NONFAILING(*(uint8_t*)0x20001660 = 2);
    NONFAILING(STORE_BY_BITMASK(uint32_t, , 0x20001661, 0, 0, 5));
    NONFAILING(STORE_BY_BITMASK(uint32_t, , 0x20001661, 5, 5, 27));
    NONFAILING(*(uint16_t*)0x20001665 = 0xf00);
    NONFAILING(*(uint16_t*)0x20001667 = 0x1ac0);
    NONFAILING(*(uint8_t*)0x20001669 = 3);
    NONFAILING(*(uint8_t*)0x2000166a = 0x10);
    NONFAILING(*(uint8_t*)0x2000166b = 0xb);
    NONFAILING(*(uint8_t*)0x2000166c = 0x10);
    NONFAILING(*(uint8_t*)0x2000166d = 0x10);
    NONFAILING(*(uint8_t*)0x2000166e = 0xa);
    NONFAILING(*(uint8_t*)0x2000166f = 0);
    NONFAILING(STORE_BY_BITMASK(uint32_t, , 0x20001670, 1, 0, 5));
    NONFAILING(STORE_BY_BITMASK(uint32_t, , 0x20001670, 1, 5, 27));
    NONFAILING(*(uint16_t*)0x20001674 = 0xf000);
    NONFAILING(*(uint16_t*)0x20001676 = 0x5b);
    NONFAILING(*(uint32_t*)0x20001678 = 0xff3fff);
    NONFAILING(*(uint64_t*)0x2000175c = 0);
    NONFAILING(*(uint64_t*)0x20001764 = 0);
    NONFAILING(*(uint32_t*)0x20001dc0 = 0xac);
    NONFAILING(*(uint64_t*)0x20001dc4 = 0);
    NONFAILING(*(uint64_t*)0x20001dcc = 0);
    NONFAILING(*(uint64_t*)0x20001dd4 = 0);
    NONFAILING(*(uint64_t*)0x20001ddc = 0);
    NONFAILING(*(uint64_t*)0x20001de4 = 0);
    NONFAILING(*(uint64_t*)0x20001dec = 0);
    NONFAILING(*(uint64_t*)0x20001df4 = 0);
    NONFAILING(*(uint64_t*)0x20001dfc = 0);
    NONFAILING(*(uint64_t*)0x20001e04 = 0);
    NONFAILING(*(uint64_t*)0x20001e0c = 0);
    NONFAILING(*(uint64_t*)0x20001e14 = 0);
    NONFAILING(*(uint64_t*)0x20001e1c = 0);
    NONFAILING(*(uint64_t*)0x20001e24 = 0);
    NONFAILING(*(uint64_t*)0x20001e2c = 0);
    NONFAILING(*(uint64_t*)0x20001e34 = 0);
    NONFAILING(*(uint64_t*)0x20001e3c = 0);
    NONFAILING(*(uint64_t*)0x20001e44 = 0);
    NONFAILING(*(uint64_t*)0x20001e4c = 0);
    NONFAILING(*(uint64_t*)0x20001e54 = 0);
    NONFAILING(*(uint64_t*)0x20001e5c = 0);
    NONFAILING(*(uint64_t*)0x20001e64 = 0);
    syz_usb_control_io(r[0], 0x20001740, 0x20001dc0);
    break;
  }
}
int main(void)
{
  syscall(__NR_mmap, 0x20000000, 0x1000000, 3, 0x32, -1, 0);
  setup_binfmt_misc();
  install_segv_handler();
  for (procid = 0; procid < 6; procid++) {
    if (fork() == 0) {
      use_temporary_dir();
      do_sandbox_none();
    }
  }
  sleep(1000000);
  return 0;
}
