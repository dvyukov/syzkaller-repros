// INFO: task hung in blkdev_reread_part
// https://syzkaller.appspot.com/bug?id=0544206f228050a56f4a6e32a71ead77c89137a6
// status:open
// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#include <linux/loop.h>

unsigned long long procid;

static void sleep_ms(uint64_t ms)
{
  usleep(ms * 1000);
}

static uint64_t current_time_ms(void)
{
  struct timespec ts;
  if (clock_gettime(CLOCK_MONOTONIC, &ts))
    exit(1);
  return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}

struct fs_image_segment {
  void* data;
  uintptr_t size;
  uintptr_t offset;
};

#define IMAGE_MAX_SEGMENTS 4096
#define IMAGE_MAX_SIZE (129 << 20)

#define SYZ_memfd_create 319

static long syz_read_part_table(unsigned long size, unsigned long nsegs,
                                long segments)
{
  char loopname[64], linkname[64];
  int loopfd, err = 0, res = -1;
  unsigned long i, j;
  struct fs_image_segment* segs = (struct fs_image_segment*)segments;
  if (nsegs > IMAGE_MAX_SEGMENTS)
    nsegs = IMAGE_MAX_SEGMENTS;
  for (i = 0; i < nsegs; i++) {
    if (segs[i].size > IMAGE_MAX_SIZE)
      segs[i].size = IMAGE_MAX_SIZE;
    segs[i].offset %= IMAGE_MAX_SIZE;
    if (segs[i].offset > IMAGE_MAX_SIZE - segs[i].size)
      segs[i].offset = IMAGE_MAX_SIZE - segs[i].size;
    if (size < segs[i].offset + segs[i].offset)
      size = segs[i].offset + segs[i].offset;
  }
  if (size > IMAGE_MAX_SIZE)
    size = IMAGE_MAX_SIZE;
  int memfd = syscall(SYZ_memfd_create, "syz_read_part_table", 0);
  if (memfd == -1) {
    err = errno;
    goto error;
  }
  if (ftruncate(memfd, size)) {
    err = errno;
    goto error_close_memfd;
  }
  for (i = 0; i < nsegs; i++) {
    if (pwrite(memfd, segs[i].data, segs[i].size, segs[i].offset) < 0) {
    }
  }
  snprintf(loopname, sizeof(loopname), "/dev/loop%llu", procid);
  loopfd = open(loopname, O_RDWR);
  if (loopfd == -1) {
    err = errno;
    goto error_close_memfd;
  }
  if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
    if (errno != EBUSY) {
      err = errno;
      goto error_close_loop;
    }
    ioctl(loopfd, LOOP_CLR_FD, 0);
    usleep(1000);
    if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
      err = errno;
      goto error_close_loop;
    }
  }
  struct loop_info64 info;
  if (ioctl(loopfd, LOOP_GET_STATUS64, &info)) {
    err = errno;
    goto error_clear_loop;
  }
  info.lo_flags |= LO_FLAGS_PARTSCAN;
  if (ioctl(loopfd, LOOP_SET_STATUS64, &info)) {
    err = errno;
    goto error_clear_loop;
  }
  res = 0;
  for (i = 1, j = 0; i < 8; i++) {
    snprintf(loopname, sizeof(loopname), "/dev/loop%llup%d", procid, (int)i);
    struct stat statbuf;
    if (stat(loopname, &statbuf) == 0) {
      snprintf(linkname, sizeof(linkname), "./file%d", (int)j++);
      if (symlink(loopname, linkname)) {
      }
    }
  }
error_clear_loop:
  ioctl(loopfd, LOOP_CLR_FD, 0);
error_close_loop:
  close(loopfd);
error_close_memfd:
  close(memfd);
error:
  errno = err;
  return res;
}

static void kill_and_wait(int pid, int* status)
{
  kill(-pid, SIGKILL);
  kill(pid, SIGKILL);
  int i;
  for (i = 0; i < 100; i++) {
    if (waitpid(-1, status, WNOHANG | __WALL) == pid)
      return;
    usleep(1000);
  }
  DIR* dir = opendir("/sys/fs/fuse/connections");
  if (dir) {
    for (;;) {
      struct dirent* ent = readdir(dir);
      if (!ent)
        break;
      if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
        continue;
      char abort[300];
      snprintf(abort, sizeof(abort), "/sys/fs/fuse/connections/%s/abort",
               ent->d_name);
      int fd = open(abort, O_WRONLY);
      if (fd == -1) {
        continue;
      }
      if (write(fd, abort, 1) < 0) {
      }
      close(fd);
    }
    closedir(dir);
  } else {
  }
  while (waitpid(-1, status, __WALL) != pid) {
  }
}

#define SYZ_HAVE_RESET_LOOP 1
static void reset_loop()
{
  char buf[64];
  snprintf(buf, sizeof(buf), "/dev/loop%llu", procid);
  int loopfd = open(buf, O_RDWR);
  if (loopfd != -1) {
    ioctl(loopfd, LOOP_CLR_FD, 0);
    close(loopfd);
  }
}

#define SYZ_HAVE_SETUP_TEST 1
static void setup_test()
{
  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
  setpgrp();
}

#define SYZ_HAVE_RESET_TEST 1
static void reset_test()
{
  int fd;
  for (fd = 3; fd < 30; fd++)
    close(fd);
}

static void execute_one(void);

#define WAIT_FLAGS __WALL

static void loop(void)
{
  int iter;
  for (iter = 0;; iter++) {
    reset_loop();
    int pid = fork();
    if (pid < 0)
      exit(1);
    if (pid == 0) {
      setup_test();
      execute_one();
      reset_test();
      exit(0);
    }
    int status = 0;
    uint64_t start = current_time_ms();
    for (;;) {
      if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
        break;
      sleep_ms(1);
      if (current_time_ms() - start < 5 * 1000)
        continue;
      kill_and_wait(pid, &status);
      break;
    }
  }
}

uint64_t r[1] = {0xffffffffffffffff};

void execute_one(void)
{
  long res = 0;
  memcpy((void*)0x20000040, "/dev/loop-control", 18);
  res = syscall(__NR_openat, 0xffffffffffffff9c, 0x20000040, 0, 0);
  if (res != -1)
    r[0] = res;
  syscall(__NR_ioctl, r[0], 0x4c80, 0);
  *(uint64_t*)0x20001340 = 0x20000080;
  *(uint64_t*)0x20001348 = 0;
  *(uint64_t*)0x20001350 = 0xe72;
  *(uint64_t*)0x20001358 = 0x20000180;
  *(uint64_t*)0x20001360 = 0;
  *(uint64_t*)0x20001368 = 2;
  *(uint64_t*)0x20001370 = 0x20000280;
  memcpy((void*)0x20000280,
         "\x83\xf4\x8a\x54\x14\xe4\xfc\x10\x22\xed\x67\x61\xb0\xc0\x1f\xde\xff"
         "\xc5\xdf\x76\x3f\x28\x5b\xae\xbc\x2c\xe1\x77\x4a\xe2\x18\xd6\xc9\x7a"
         "\xb6\x49\xaf\xbe\xb2\x46\x7c\x67\xd1\x03\x88\xa8\xc1\xd4\x60\x70\x78"
         "\x88\x77\x76\x81\x2c\xe6\x4b\x0c\x3f\x53\xdc\x0b\xc7\x38\xf6\xfb\xfe"
         "\x18\xc3\x92\xe9\xff\xe1\x0a\x2e\x30\x08\x02\x70\x01\x88\x7c\x86\xe9"
         "\x2c\xb5\x0a\x7c\xe0\x51\x7a\xdd\x0d\x12\x46\xee\x3a\x3c\x76\x5c\x31"
         "\xeb\x63\xbf\x14\xca\x86\x4c\x4e\xaa\x97\xba\x23\x8f\x67\xcd\xb6\x08"
         "\x07\xb2\x7c\xfa\x07\x86\xa5\x1b\x0f\x3f\x52\x17\x3b\x76\x6a\x08\x77"
         "\x6a\x95\xca\xce\x62\x97\x90",
         143);
  *(uint64_t*)0x20001378 = 0x8f;
  *(uint64_t*)0x20001380 = 0x80000000;
  *(uint64_t*)0x20001388 = 0x20000340;
  *(uint64_t*)0x20001390 = 0;
  *(uint64_t*)0x20001398 = 0xffff;
  *(uint64_t*)0x200013a0 = 0x20000000;
  *(uint64_t*)0x200013a8 = 0;
  *(uint64_t*)0x200013b0 = 3;
  syz_read_part_table(6, 5, 0x20001340);
  syscall(__NR_ioctl, r[0], 0x4c81, 0);
  syscall(__NR_ioctl, -1, 0x540e, 3);
  syscall(__NR_lseek, r[0], 0, 3);
}
int main(void)
{
  syscall(__NR_mmap, 0x20000000, 0x1000000, 3, 0x32, -1, 0);
  for (procid = 0; procid < 6; procid++) {
    if (fork() == 0) {
      loop();
    }
  }
  sleep(1000000);
  return 0;
}
