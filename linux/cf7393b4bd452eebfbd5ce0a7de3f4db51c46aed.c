// KASAN: use-after-free Write in prb_fill_curr_block
// https://syzkaller.appspot.com/bug?id=cf7393b4bd452eebfbd5ce0a7de3f4db51c46aed
// status:fixed
// autogenerated by syzkaller (http://github.com/google/syzkaller)

#define _GNU_SOURCE
#include <arpa/inet.h>
#include <endian.h>
#include <errno.h>
#include <errno.h>
#include <fcntl.h>
#include <linux/if.h>
#include <linux/if_ether.h>
#include <linux/if_tun.h>
#include <linux/ip.h>
#include <linux/tcp.h>
#include <net/if_arp.h>
#include <sched.h>
#include <signal.h>
#include <stdarg.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <unistd.h>

__attribute__((noreturn)) static void doexit(int status)
{
  volatile unsigned i;
  syscall(__NR_exit_group, status);
  for (i = 0;; i++) {
  }
}
#include <errno.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <string.h>

const int kFailStatus = 67;
const int kRetryStatus = 69;

static void fail(const char* msg, ...)
{
  int e = errno;
  va_list args;
  va_start(args, msg);
  vfprintf(stderr, msg, args);
  va_end(args);
  fprintf(stderr, " (errno %d)\n", e);
  doexit((e == ENOMEM || e == EAGAIN) ? kRetryStatus : kFailStatus);
}

static __thread int skip_segv;
static __thread jmp_buf segv_env;

static void segv_handler(int sig, siginfo_t* info, void* uctx)
{
  uintptr_t addr = (uintptr_t)info->si_addr;
  const uintptr_t prog_start = 1 << 20;
  const uintptr_t prog_end = 100 << 20;
  if (__atomic_load_n(&skip_segv, __ATOMIC_RELAXED) &&
      (addr < prog_start || addr > prog_end)) {
    _longjmp(segv_env, 1);
  }
  doexit(sig);
}

static void install_segv_handler()
{
  struct sigaction sa;

  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  syscall(SYS_rt_sigaction, 0x20, &sa, NULL, 8);
  syscall(SYS_rt_sigaction, 0x21, &sa, NULL, 8);

  memset(&sa, 0, sizeof(sa));
  sa.sa_sigaction = segv_handler;
  sa.sa_flags = SA_NODEFER | SA_SIGINFO;
  sigaction(SIGSEGV, &sa, NULL);
  sigaction(SIGBUS, &sa, NULL);
}

#define NONFAILING(...)                                                        \
  {                                                                            \
    __atomic_fetch_add(&skip_segv, 1, __ATOMIC_SEQ_CST);                       \
    if (_setjmp(segv_env) == 0) {                                              \
      __VA_ARGS__;                                                             \
    }                                                                          \
    __atomic_fetch_sub(&skip_segv, 1, __ATOMIC_SEQ_CST);                       \
  }

static void vsnprintf_check(char* str, size_t size, const char* format,
                            va_list args)
{
  int rv;

  rv = vsnprintf(str, size, format, args);
  if (rv < 0)
    fail("tun: snprintf failed");
  if ((size_t)rv >= size)
    fail("tun: string '%s...' doesn't fit into buffer", str);
}

#define COMMAND_MAX_LEN 128
#define PATH_PREFIX                                                            \
  "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin "
#define PATH_PREFIX_LEN (sizeof(PATH_PREFIX) - 1)

static void execute_command(bool panic, const char* format, ...)
{
  va_list args;
  char command[PATH_PREFIX_LEN + COMMAND_MAX_LEN];
  int rv;

  va_start(args, format);
  memcpy(command, PATH_PREFIX, PATH_PREFIX_LEN);
  vsnprintf_check(command + PATH_PREFIX_LEN, COMMAND_MAX_LEN, format, args);
  va_end(args);
  rv = system(command);
  if (rv) {
    if (panic)
      fail("command '%s' failed: %d", &command[0], rv);
  }
}

#define DEV_IPV4 "172.20.20.%d"
#define DEV_IPV6 "fe80::%02hx"
#define DEV_MAC "aa:aa:aa:aa:aa:%02hx"

static void snprintf_check(char* str, size_t size, const char* format, ...)
{
  va_list args;

  va_start(args, format);
  vsnprintf_check(str, size, format, args);
  va_end(args);
}

static void initialize_netdevices(void)
{
  unsigned i;
  const char* devtypes[] = {"ip6gretap", "bridge", "vcan", "bond", "team"};
  const char* devnames[] = {"lo",
                            "sit0",
                            "bridge0",
                            "vcan0",
                            "tunl0",
                            "gre0",
                            "gretap0",
                            "ip_vti0",
                            "ip6_vti0",
                            "ip6tnl0",
                            "ip6gre0",
                            "ip6gretap0",
                            "erspan0",
                            "bond0",
                            "veth0",
                            "veth1",
                            "team0",
                            "veth0_to_bridge",
                            "veth1_to_bridge",
                            "veth0_to_bond",
                            "veth1_to_bond",
                            "veth0_to_team",
                            "veth1_to_team"};
  const char* devmasters[] = {"bridge", "bond", "team"};

  for (i = 0; i < sizeof(devtypes) / (sizeof(devtypes[0])); i++)
    execute_command(0, "ip link add dev %s0 type %s", devtypes[i], devtypes[i]);
  execute_command(0, "ip link add type veth");

  for (i = 0; i < sizeof(devmasters) / (sizeof(devmasters[0])); i++) {
    execute_command(
        0, "ip link add name %s_slave_0 type veth peer name veth0_to_%s",
        devmasters[i], devmasters[i]);
    execute_command(
        0, "ip link add name %s_slave_1 type veth peer name veth1_to_%s",
        devmasters[i], devmasters[i]);
    execute_command(0, "ip link set %s_slave_0 master %s0", devmasters[i],
                    devmasters[i]);
    execute_command(0, "ip link set %s_slave_1 master %s0", devmasters[i],
                    devmasters[i]);
    execute_command(0, "ip link set veth0_to_%s up", devmasters[i]);
    execute_command(0, "ip link set veth1_to_%s up", devmasters[i]);
  }
  execute_command(0, "ip link set bridge_slave_0 up");
  execute_command(0, "ip link set bridge_slave_1 up");

  for (i = 0; i < sizeof(devnames) / (sizeof(devnames[0])); i++) {
    char addr[32];
    snprintf_check(addr, sizeof(addr), DEV_IPV4, i + 10);
    execute_command(0, "ip -4 addr add %s/24 dev %s", addr, devnames[i]);
    snprintf_check(addr, sizeof(addr), DEV_IPV6, i + 10);
    execute_command(0, "ip -6 addr add %s/120 dev %s", addr, devnames[i]);
    snprintf_check(addr, sizeof(addr), DEV_MAC, i + 10);
    execute_command(0, "ip link set dev %s address %s", devnames[i], addr);
    execute_command(0, "ip link set dev %s up", devnames[i]);
  }
}

static void loop();

static void sandbox_common()
{
  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
  setpgrp();
  setsid();

  struct rlimit rlim;
  rlim.rlim_cur = rlim.rlim_max = 160 << 20;
  setrlimit(RLIMIT_AS, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 8 << 20;
  setrlimit(RLIMIT_MEMLOCK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 136 << 20;
  setrlimit(RLIMIT_FSIZE, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 1 << 20;
  setrlimit(RLIMIT_STACK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 0;
  setrlimit(RLIMIT_CORE, &rlim);

  if (unshare(CLONE_NEWNS)) {
  }
  if (unshare(CLONE_NEWIPC)) {
  }
  if (unshare(0x02000000)) {
  }
  if (unshare(CLONE_NEWUTS)) {
  }
  if (unshare(CLONE_SYSVSEM)) {
  }
}

static int do_sandbox_none(void)
{
  if (unshare(CLONE_NEWPID)) {
  }
  int pid = fork();
  if (pid < 0)
    fail("sandbox fork failed");
  if (pid)
    return pid;

  sandbox_common();
  if (unshare(CLONE_NEWNET)) {
  }
  initialize_netdevices();
  loop();
  doexit(1);
}

#ifndef __NR_bpf
#define __NR_bpf 321
#endif

uint64_t r[1] = {0xffffffffffffffff};
void loop()
{
  long res = 0;
  NONFAILING(*(uint32_t*)0x20000000 = 0);
  NONFAILING(*(uint32_t*)0x20000004 = 3);
  NONFAILING(*(uint64_t*)0x20000008 = 0x20001000);
  NONFAILING(memcpy((void*)0x20001000, "\x7b\x1a\xf8\xff\x00\x00\x00\x00\x69"
                                       "\xa2\xf8\xce\xdd\x2e\x00\x0d\x5c\xc4"
                                       "\xb3\xaa\xb4\xff\x00\x00\x00",
                    25));
  NONFAILING(*(uint64_t*)0x20000010 = 0x20000100);
  NONFAILING(memcpy((void*)0x20000100, "GPL", 4));
  NONFAILING(*(uint32_t*)0x20000018 = 0);
  NONFAILING(*(uint32_t*)0x2000001c = 0);
  NONFAILING(*(uint64_t*)0x20000020 = 0);
  NONFAILING(*(uint32_t*)0x20000028 = 0);
  NONFAILING(*(uint32_t*)0x2000002c = 0);
  NONFAILING(*(uint8_t*)0x20000030 = 0);
  NONFAILING(*(uint8_t*)0x20000031 = 0);
  NONFAILING(*(uint8_t*)0x20000032 = 0);
  NONFAILING(*(uint8_t*)0x20000033 = 0);
  NONFAILING(*(uint8_t*)0x20000034 = 0);
  NONFAILING(*(uint8_t*)0x20000035 = 0);
  NONFAILING(*(uint8_t*)0x20000036 = 0);
  NONFAILING(*(uint8_t*)0x20000037 = 0);
  NONFAILING(*(uint8_t*)0x20000038 = 0);
  NONFAILING(*(uint8_t*)0x20000039 = 0);
  NONFAILING(*(uint8_t*)0x2000003a = 0);
  NONFAILING(*(uint8_t*)0x2000003b = 0);
  NONFAILING(*(uint8_t*)0x2000003c = 0);
  NONFAILING(*(uint8_t*)0x2000003d = 0);
  NONFAILING(*(uint8_t*)0x2000003e = 0);
  NONFAILING(*(uint8_t*)0x2000003f = 0);
  NONFAILING(*(uint32_t*)0x20000040 = 0);
  NONFAILING(*(uint32_t*)0x20000044 = 0);
  syscall(__NR_bpf, 5, 0x20000000, 0x48);
  NONFAILING(*(uint32_t*)0x20001000 = 0x10000);
  NONFAILING(*(uint32_t*)0x20001004 = 4);
  NONFAILING(*(uint32_t*)0x20001008 = 0x100);
  NONFAILING(*(uint32_t*)0x2000100c = 0x400);
  syscall(__NR_setsockopt, -1, 0x84, 0, 0x20001000, 6);
  res = syscall(__NR_socket, 0x11, 0x80002, 0);
  if (res != -1)
    r[0] = res;
  NONFAILING(*(uint32_t*)0x20788000 = 2);
  syscall(__NR_setsockopt, r[0], 0x107, 0xa, 0x20788000, 4);
  NONFAILING(*(uint16_t*)0x20000480 = 0x11);
  NONFAILING(*(uint16_t*)0x20000482 = htobe16(3));
  NONFAILING(*(uint32_t*)0x20000484 = 0);
  NONFAILING(*(uint16_t*)0x20000488 = 1);
  NONFAILING(*(uint8_t*)0x2000048a = 0);
  NONFAILING(*(uint8_t*)0x2000048b = 6);
  NONFAILING(*(uint8_t*)0x2000048c = 0xaa);
  NONFAILING(*(uint8_t*)0x2000048d = 0xaa);
  NONFAILING(*(uint8_t*)0x2000048e = 0xaa);
  NONFAILING(*(uint8_t*)0x2000048f = 0xaa);
  NONFAILING(*(uint8_t*)0x20000490 = 0xaa);
  NONFAILING(*(uint8_t*)0x20000491 = 0xaa);
  NONFAILING(*(uint8_t*)0x20000492 = 0);
  NONFAILING(*(uint8_t*)0x20000493 = 0);
  syscall(__NR_bind, r[0], 0x20000480, 0x14);
  syscall(__NR_setsockopt, r[0], 0x107, 5, 0x20001000, 0xc5);
}

int main()
{
  syscall(__NR_mmap, 0x20000000, 0x1000000, 3, 0x32, -1, 0);
  install_segv_handler();
  int pid = do_sandbox_none();
  int status = 0;
  while (waitpid(pid, &status, __WALL) != pid) {
  }
  return 0;
}
