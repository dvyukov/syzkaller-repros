// BUG: unable to handle kernel paging request in free_block (5)
// https://syzkaller.appspot.com/bug?id=df52ab115e885a8e9b7b6a1359133890cd206e8b
// status:open
// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <arpa/inet.h>
#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <net/if.h>
#include <net/if_arp.h>
#include <netinet/in.h>
#include <pthread.h>
#include <sched.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#include <linux/futex.h>
#include <linux/genetlink.h>
#include <linux/if_addr.h>
#include <linux/if_ether.h>
#include <linux/if_link.h>
#include <linux/if_tun.h>
#include <linux/in6.h>
#include <linux/ip.h>
#include <linux/neighbour.h>
#include <linux/net.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/tcp.h>
#include <linux/veth.h>

unsigned long long procid;

static __thread int skip_segv;
static __thread jmp_buf segv_env;

static void segv_handler(int sig, siginfo_t* info, void* ctx)
{
  uintptr_t addr = (uintptr_t)info->si_addr;
  const uintptr_t prog_start = 1 << 20;
  const uintptr_t prog_end = 100 << 20;
  if (__atomic_load_n(&skip_segv, __ATOMIC_RELAXED) &&
      (addr < prog_start || addr > prog_end)) {
    _longjmp(segv_env, 1);
  }
  exit(sig);
}

static void install_segv_handler(void)
{
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  syscall(SYS_rt_sigaction, 0x20, &sa, NULL, 8);
  syscall(SYS_rt_sigaction, 0x21, &sa, NULL, 8);
  memset(&sa, 0, sizeof(sa));
  sa.sa_sigaction = segv_handler;
  sa.sa_flags = SA_NODEFER | SA_SIGINFO;
  sigaction(SIGSEGV, &sa, NULL);
  sigaction(SIGBUS, &sa, NULL);
}

#define NONFAILING(...)                                                        \
  {                                                                            \
    __atomic_fetch_add(&skip_segv, 1, __ATOMIC_SEQ_CST);                       \
    if (_setjmp(segv_env) == 0) {                                              \
      __VA_ARGS__;                                                             \
    }                                                                          \
    __atomic_fetch_sub(&skip_segv, 1, __ATOMIC_SEQ_CST);                       \
  }

static void sleep_ms(uint64_t ms)
{
  usleep(ms * 1000);
}

static uint64_t current_time_ms(void)
{
  struct timespec ts;
  if (clock_gettime(CLOCK_MONOTONIC, &ts))
    exit(1);
  return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}

static void use_temporary_dir(void)
{
  char tmpdir_template[] = "./syzkaller.XXXXXX";
  char* tmpdir = mkdtemp(tmpdir_template);
  if (!tmpdir)
    exit(1);
  if (chmod(tmpdir, 0777))
    exit(1);
  if (chdir(tmpdir))
    exit(1);
}

static void thread_start(void* (*fn)(void*), void* arg)
{
  pthread_t th;
  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 128 << 10);
  int i;
  for (i = 0; i < 100; i++) {
    if (pthread_create(&th, &attr, fn, arg) == 0) {
      pthread_attr_destroy(&attr);
      return;
    }
    if (errno == EAGAIN) {
      usleep(50);
      continue;
    }
    break;
  }
  exit(1);
}

#define BITMASK(bf_off, bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
#define STORE_BY_BITMASK(type, htobe, addr, val, bf_off, bf_len)               \
  *(type*)(addr) =                                                             \
      htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) |           \
            (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))

struct csum_inet {
  uint32_t acc;
};

static void csum_inet_init(struct csum_inet* csum)
{
  csum->acc = 0;
}

static void csum_inet_update(struct csum_inet* csum, const uint8_t* data,
                             size_t length)
{
  if (length == 0)
    return;
  size_t i;
  for (i = 0; i < length - 1; i += 2)
    csum->acc += *(uint16_t*)&data[i];
  if (length & 1)
    csum->acc += (uint16_t)data[length - 1];
  while (csum->acc > 0xffff)
    csum->acc = (csum->acc & 0xffff) + (csum->acc >> 16);
}

static uint16_t csum_inet_digest(struct csum_inet* csum)
{
  return ~csum->acc;
}

typedef struct {
  int state;
} event_t;

static void event_init(event_t* ev)
{
  ev->state = 0;
}

static void event_reset(event_t* ev)
{
  ev->state = 0;
}

static void event_set(event_t* ev)
{
  if (ev->state)
    exit(1);
  __atomic_store_n(&ev->state, 1, __ATOMIC_RELEASE);
  syscall(SYS_futex, &ev->state, FUTEX_WAKE | FUTEX_PRIVATE_FLAG);
}

static void event_wait(event_t* ev)
{
  while (!__atomic_load_n(&ev->state, __ATOMIC_ACQUIRE))
    syscall(SYS_futex, &ev->state, FUTEX_WAIT | FUTEX_PRIVATE_FLAG, 0, 0);
}

static int event_isset(event_t* ev)
{
  return __atomic_load_n(&ev->state, __ATOMIC_ACQUIRE);
}

static int event_timedwait(event_t* ev, uint64_t timeout)
{
  uint64_t start = current_time_ms();
  uint64_t now = start;
  for (;;) {
    uint64_t remain = timeout - (now - start);
    struct timespec ts;
    ts.tv_sec = remain / 1000;
    ts.tv_nsec = (remain % 1000) * 1000 * 1000;
    syscall(SYS_futex, &ev->state, FUTEX_WAIT | FUTEX_PRIVATE_FLAG, 0, &ts);
    if (__atomic_load_n(&ev->state, __ATOMIC_RELAXED))
      return 1;
    now = current_time_ms();
    if (now - start > timeout)
      return 0;
  }
}

static bool write_file(const char* file, const char* what, ...)
{
  char buf[1024];
  va_list args;
  va_start(args, what);
  vsnprintf(buf, sizeof(buf), what, args);
  va_end(args);
  buf[sizeof(buf) - 1] = 0;
  int len = strlen(buf);
  int fd = open(file, O_WRONLY | O_CLOEXEC);
  if (fd == -1)
    return false;
  if (write(fd, buf, len) != len) {
    int err = errno;
    close(fd);
    errno = err;
    return false;
  }
  close(fd);
  return true;
}

static struct {
  char* pos;
  int nesting;
  struct nlattr* nested[8];
  char buf[1024];
} nlmsg;

static void netlink_init(int typ, int flags, const void* data, int size)
{
  memset(&nlmsg, 0, sizeof(nlmsg));
  struct nlmsghdr* hdr = (struct nlmsghdr*)nlmsg.buf;
  hdr->nlmsg_type = typ;
  hdr->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | flags;
  memcpy(hdr + 1, data, size);
  nlmsg.pos = (char*)(hdr + 1) + NLMSG_ALIGN(size);
}

static void netlink_attr(int typ, const void* data, int size)
{
  struct nlattr* attr = (struct nlattr*)nlmsg.pos;
  attr->nla_len = sizeof(*attr) + size;
  attr->nla_type = typ;
  memcpy(attr + 1, data, size);
  nlmsg.pos += NLMSG_ALIGN(attr->nla_len);
}

static void netlink_nest(int typ)
{
  struct nlattr* attr = (struct nlattr*)nlmsg.pos;
  attr->nla_type = typ;
  nlmsg.pos += sizeof(*attr);
  nlmsg.nested[nlmsg.nesting++] = attr;
}

static void netlink_done(void)
{
  struct nlattr* attr = nlmsg.nested[--nlmsg.nesting];
  attr->nla_len = nlmsg.pos - (char*)attr;
}

static int netlink_send(int sock)
{
  if (nlmsg.pos > nlmsg.buf + sizeof(nlmsg.buf) || nlmsg.nesting)
    exit(1);
  struct nlmsghdr* hdr = (struct nlmsghdr*)nlmsg.buf;
  hdr->nlmsg_len = nlmsg.pos - nlmsg.buf;
  struct sockaddr_nl addr;
  memset(&addr, 0, sizeof(addr));
  addr.nl_family = AF_NETLINK;
  unsigned n = sendto(sock, nlmsg.buf, hdr->nlmsg_len, 0,
                      (struct sockaddr*)&addr, sizeof(addr));
  if (n != hdr->nlmsg_len)
    exit(1);
  n = recv(sock, nlmsg.buf, sizeof(nlmsg.buf), 0);
  if (n < sizeof(struct nlmsghdr) + sizeof(struct nlmsgerr))
    exit(1);
  if (hdr->nlmsg_type != NLMSG_ERROR)
    exit(1);
  return -((struct nlmsgerr*)(hdr + 1))->error;
}

static void netlink_add_device_impl(const char* type, const char* name)
{
  struct ifinfomsg hdr;
  memset(&hdr, 0, sizeof(hdr));
  netlink_init(RTM_NEWLINK, NLM_F_EXCL | NLM_F_CREATE, &hdr, sizeof(hdr));
  if (name)
    netlink_attr(IFLA_IFNAME, name, strlen(name));
  netlink_nest(IFLA_LINKINFO);
  netlink_attr(IFLA_INFO_KIND, type, strlen(type));
}

static void netlink_add_device(int sock, const char* type, const char* name)
{
  netlink_add_device_impl(type, name);
  netlink_done();
  int err = netlink_send(sock);
  (void)err;
}

static void netlink_add_veth(int sock, const char* name, const char* peer)
{
  netlink_add_device_impl("veth", name);
  netlink_nest(IFLA_INFO_DATA);
  netlink_nest(VETH_INFO_PEER);
  nlmsg.pos += sizeof(struct ifinfomsg);
  netlink_attr(IFLA_IFNAME, peer, strlen(peer));
  netlink_done();
  netlink_done();
  netlink_done();
  int err = netlink_send(sock);
  (void)err;
}

static void netlink_add_hsr(int sock, const char* name, const char* slave1,
                            const char* slave2)
{
  netlink_add_device_impl("hsr", name);
  netlink_nest(IFLA_INFO_DATA);
  int ifindex1 = if_nametoindex(slave1);
  netlink_attr(IFLA_HSR_SLAVE1, &ifindex1, sizeof(ifindex1));
  int ifindex2 = if_nametoindex(slave2);
  netlink_attr(IFLA_HSR_SLAVE2, &ifindex2, sizeof(ifindex2));
  netlink_done();
  netlink_done();
  int err = netlink_send(sock);
  (void)err;
}

static void netlink_device_change(int sock, const char* name, bool up,
                                  const char* master, const void* mac,
                                  int macsize)
{
  struct ifinfomsg hdr;
  memset(&hdr, 0, sizeof(hdr));
  if (up)
    hdr.ifi_flags = hdr.ifi_change = IFF_UP;
  netlink_init(RTM_NEWLINK, 0, &hdr, sizeof(hdr));
  netlink_attr(IFLA_IFNAME, name, strlen(name));
  if (master) {
    int ifindex = if_nametoindex(master);
    netlink_attr(IFLA_MASTER, &ifindex, sizeof(ifindex));
  }
  if (macsize)
    netlink_attr(IFLA_ADDRESS, mac, macsize);
  int err = netlink_send(sock);
  (void)err;
}

static int netlink_add_addr(int sock, const char* dev, const void* addr,
                            int addrsize)
{
  struct ifaddrmsg hdr;
  memset(&hdr, 0, sizeof(hdr));
  hdr.ifa_family = addrsize == 4 ? AF_INET : AF_INET6;
  hdr.ifa_prefixlen = addrsize == 4 ? 24 : 120;
  hdr.ifa_scope = RT_SCOPE_UNIVERSE;
  hdr.ifa_index = if_nametoindex(dev);
  netlink_init(RTM_NEWADDR, NLM_F_CREATE | NLM_F_REPLACE, &hdr, sizeof(hdr));
  netlink_attr(IFA_LOCAL, addr, addrsize);
  netlink_attr(IFA_ADDRESS, addr, addrsize);
  return netlink_send(sock);
}

static void netlink_add_addr4(int sock, const char* dev, const char* addr)
{
  struct in_addr in_addr;
  inet_pton(AF_INET, addr, &in_addr);
  int err = netlink_add_addr(sock, dev, &in_addr, sizeof(in_addr));
  (void)err;
}

static void netlink_add_addr6(int sock, const char* dev, const char* addr)
{
  struct in6_addr in6_addr;
  inet_pton(AF_INET6, addr, &in6_addr);
  int err = netlink_add_addr(sock, dev, &in6_addr, sizeof(in6_addr));
  (void)err;
}

static void netlink_add_neigh(int sock, const char* name, const void* addr,
                              int addrsize, const void* mac, int macsize)
{
  struct ndmsg hdr;
  memset(&hdr, 0, sizeof(hdr));
  hdr.ndm_family = addrsize == 4 ? AF_INET : AF_INET6;
  hdr.ndm_ifindex = if_nametoindex(name);
  hdr.ndm_state = NUD_PERMANENT;
  netlink_init(RTM_NEWNEIGH, NLM_F_EXCL | NLM_F_CREATE, &hdr, sizeof(hdr));
  netlink_attr(NDA_DST, addr, addrsize);
  netlink_attr(NDA_LLADDR, mac, macsize);
  int err = netlink_send(sock);
  (void)err;
}

static int tunfd = -1;
static int tun_frags_enabled;
#define SYZ_TUN_MAX_PACKET_SIZE 1000

#define TUN_IFACE "syz_tun"

#define LOCAL_MAC 0xaaaaaaaaaaaa
#define REMOTE_MAC 0xaaaaaaaaaabb

#define LOCAL_IPV4 "172.20.20.170"
#define REMOTE_IPV4 "172.20.20.187"

#define LOCAL_IPV6 "fe80::aa"
#define REMOTE_IPV6 "fe80::bb"

#define IFF_NAPI 0x0010
#define IFF_NAPI_FRAGS 0x0020

static void initialize_tun(void)
{
  tunfd = open("/dev/net/tun", O_RDWR | O_NONBLOCK);
  if (tunfd == -1) {
    printf("tun: can't open /dev/net/tun: please enable CONFIG_TUN=y\n");
    printf("otherwise fuzzing or reproducing might not work as intended\n");
    return;
  }
  const int kTunFd = 240;
  if (dup2(tunfd, kTunFd) < 0)
    exit(1);
  close(tunfd);
  tunfd = kTunFd;
  struct ifreq ifr;
  memset(&ifr, 0, sizeof(ifr));
  strncpy(ifr.ifr_name, TUN_IFACE, IFNAMSIZ);
  ifr.ifr_flags = IFF_TAP | IFF_NO_PI | IFF_NAPI | IFF_NAPI_FRAGS;
  if (ioctl(tunfd, TUNSETIFF, (void*)&ifr) < 0) {
    ifr.ifr_flags = IFF_TAP | IFF_NO_PI;
    if (ioctl(tunfd, TUNSETIFF, (void*)&ifr) < 0)
      exit(1);
  }
  if (ioctl(tunfd, TUNGETIFF, (void*)&ifr) < 0)
    exit(1);
  tun_frags_enabled = (ifr.ifr_flags & IFF_NAPI_FRAGS) != 0;
  char sysctl[64];
  sprintf(sysctl, "/proc/sys/net/ipv6/conf/%s/accept_dad", TUN_IFACE);
  write_file(sysctl, "0");
  sprintf(sysctl, "/proc/sys/net/ipv6/conf/%s/router_solicitations", TUN_IFACE);
  write_file(sysctl, "0");
  int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
  if (sock == -1)
    exit(1);
  netlink_add_addr4(sock, TUN_IFACE, LOCAL_IPV4);
  netlink_add_addr6(sock, TUN_IFACE, LOCAL_IPV6);
  uint64_t macaddr = REMOTE_MAC;
  struct in_addr in_addr;
  inet_pton(AF_INET, REMOTE_IPV4, &in_addr);
  netlink_add_neigh(sock, TUN_IFACE, &in_addr, sizeof(in_addr), &macaddr,
                    ETH_ALEN);
  struct in6_addr in6_addr;
  inet_pton(AF_INET6, REMOTE_IPV6, &in6_addr);
  netlink_add_neigh(sock, TUN_IFACE, &in6_addr, sizeof(in6_addr), &macaddr,
                    ETH_ALEN);
  macaddr = LOCAL_MAC;
  netlink_device_change(sock, TUN_IFACE, true, 0, &macaddr, ETH_ALEN);
  close(sock);
}

#define DEV_IPV4 "172.20.20.%d"
#define DEV_IPV6 "fe80::%02x"
#define DEV_MAC 0x00aaaaaaaaaa
static void initialize_netdevices(void)
{
  char netdevsim[16];
  sprintf(netdevsim, "netdevsim%d", (int)procid);
  struct {
    const char* type;
    const char* dev;
  } devtypes[] = {
      {"ip6gretap", "ip6gretap0"}, {"bridge", "bridge0"},
      {"vcan", "vcan0"},           {"bond", "bond0"},
      {"team", "team0"},           {"dummy", "dummy0"},
      {"nlmon", "nlmon0"},         {"caif", "caif0"},
      {"batadv", "batadv0"},       {"vxcan", "vxcan1"},
      {"netdevsim", netdevsim},    {"veth", 0},
  };
  const char* devmasters[] = {"bridge", "bond", "team"};
  struct {
    const char* name;
    int macsize;
    bool noipv6;
  } devices[] = {
      {"lo", ETH_ALEN},
      {"sit0", 0},
      {"bridge0", ETH_ALEN},
      {"vcan0", 0, true},
      {"tunl0", 0},
      {"gre0", 0},
      {"gretap0", ETH_ALEN},
      {"ip_vti0", 0},
      {"ip6_vti0", 0},
      {"ip6tnl0", 0},
      {"ip6gre0", 0},
      {"ip6gretap0", ETH_ALEN},
      {"erspan0", ETH_ALEN},
      {"bond0", ETH_ALEN},
      {"veth0", ETH_ALEN},
      {"veth1", ETH_ALEN},
      {"team0", ETH_ALEN},
      {"veth0_to_bridge", ETH_ALEN},
      {"veth1_to_bridge", ETH_ALEN},
      {"veth0_to_bond", ETH_ALEN},
      {"veth1_to_bond", ETH_ALEN},
      {"veth0_to_team", ETH_ALEN},
      {"veth1_to_team", ETH_ALEN},
      {"veth0_to_hsr", ETH_ALEN},
      {"veth1_to_hsr", ETH_ALEN},
      {"hsr0", 0},
      {"dummy0", ETH_ALEN},
      {"nlmon0", 0},
      {"vxcan1", 0, true},
      {"caif0", ETH_ALEN},
      {"batadv0", ETH_ALEN},
      {netdevsim, ETH_ALEN},
  };
  int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
  if (sock == -1)
    exit(1);
  unsigned i;
  for (i = 0; i < sizeof(devtypes) / sizeof(devtypes[0]); i++)
    netlink_add_device(sock, devtypes[i].type, devtypes[i].dev);
  for (i = 0; i < sizeof(devmasters) / (sizeof(devmasters[0])); i++) {
    char master[32], slave0[32], veth0[32], slave1[32], veth1[32];
    sprintf(slave0, "%s_slave_0", devmasters[i]);
    sprintf(veth0, "veth0_to_%s", devmasters[i]);
    netlink_add_veth(sock, slave0, veth0);
    sprintf(slave1, "%s_slave_1", devmasters[i]);
    sprintf(veth1, "veth1_to_%s", devmasters[i]);
    netlink_add_veth(sock, slave1, veth1);
    sprintf(master, "%s0", devmasters[i]);
    netlink_device_change(sock, slave0, false, master, 0, 0);
    netlink_device_change(sock, slave1, false, master, 0, 0);
  }
  netlink_device_change(sock, "bridge_slave_0", true, 0, 0, 0);
  netlink_device_change(sock, "bridge_slave_1", true, 0, 0, 0);
  netlink_add_veth(sock, "hsr_slave_0", "veth0_to_hsr");
  netlink_add_veth(sock, "hsr_slave_1", "veth1_to_hsr");
  netlink_add_hsr(sock, "hsr0", "hsr_slave_0", "hsr_slave_1");
  netlink_device_change(sock, "hsr_slave_0", true, 0, 0, 0);
  netlink_device_change(sock, "hsr_slave_1", true, 0, 0, 0);
  for (i = 0; i < sizeof(devices) / (sizeof(devices[0])); i++) {
    char addr[32];
    sprintf(addr, DEV_IPV4, i + 10);
    netlink_add_addr4(sock, devices[i].name, addr);
    if (!devices[i].noipv6) {
      sprintf(addr, DEV_IPV6, i + 10);
      netlink_add_addr6(sock, devices[i].name, addr);
    }
    uint64_t macaddr = DEV_MAC + ((i + 10ull) << 40);
    netlink_device_change(sock, devices[i].name, true, 0, &macaddr,
                          devices[i].macsize);
  }
  close(sock);
}
static void initialize_netdevices_init(void)
{
  int sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
  if (sock == -1)
    exit(1);
  struct {
    const char* type;
    int macsize;
    bool noipv6;
    bool noup;
  } devtypes[] = {
      {"nr", 7, true},
      {"rose", 5, true, true},
  };
  unsigned i;
  for (i = 0; i < sizeof(devtypes) / sizeof(devtypes[0]); i++) {
    char dev[32], addr[32];
    sprintf(dev, "%s%d", devtypes[i].type, (int)procid);
    sprintf(addr, "172.30.%d.%d", i, (int)procid + 1);
    netlink_add_addr4(sock, dev, addr);
    if (!devtypes[i].noipv6) {
      sprintf(addr, "fe88::%02x:%02x", i, (int)procid + 1);
      netlink_add_addr6(sock, dev, addr);
    }
    int macsize = devtypes[i].macsize;
    uint64_t macaddr = 0xbbbbbb +
                       ((unsigned long long)i << (8 * (macsize - 2))) +
                       (procid << (8 * (macsize - 1)));
    netlink_device_change(sock, dev, !devtypes[i].noup, 0, &macaddr, macsize);
  }
  close(sock);
}

static int read_tun(char* data, int size)
{
  if (tunfd < 0)
    return -1;
  int rv = read(tunfd, data, size);
  if (rv < 0) {
    if (errno == EAGAIN)
      return -1;
    if (errno == EBADFD)
      return -1;
    exit(1);
  }
  return rv;
}

#define MAX_FRAGS 4
struct vnet_fragmentation {
  uint32_t full;
  uint32_t count;
  uint32_t frags[MAX_FRAGS];
};

static long syz_emit_ethernet(volatile long a0, volatile long a1,
                              volatile long a2)
{
  if (tunfd < 0)
    return (uintptr_t)-1;
  uint32_t length = a0;
  char* data = (char*)a1;
  struct vnet_fragmentation* frags = (struct vnet_fragmentation*)a2;
  struct iovec vecs[MAX_FRAGS + 1];
  uint32_t nfrags = 0;
  if (!tun_frags_enabled || frags == NULL) {
    vecs[nfrags].iov_base = data;
    vecs[nfrags].iov_len = length;
    nfrags++;
  } else {
    bool full = true;
    uint32_t i, count = 0;
    NONFAILING(full = frags->full);
    NONFAILING(count = frags->count);
    if (count > MAX_FRAGS)
      count = MAX_FRAGS;
    for (i = 0; i < count && length != 0; i++) {
      uint32_t size = 0;
      NONFAILING(size = frags->frags[i]);
      if (size > length)
        size = length;
      vecs[nfrags].iov_base = data;
      vecs[nfrags].iov_len = size;
      nfrags++;
      data += size;
      length -= size;
    }
    if (length != 0 && (full || nfrags == 0)) {
      vecs[nfrags].iov_base = data;
      vecs[nfrags].iov_len = length;
      nfrags++;
    }
  }
  return writev(tunfd, vecs, nfrags);
}

static void flush_tun()
{
  char data[SYZ_TUN_MAX_PACKET_SIZE];
  while (read_tun(&data[0], sizeof(data)) != -1) {
  }
}

const int kInitNetNsFd = 239;
static long syz_init_net_socket(volatile long domain, volatile long type,
                                volatile long proto)
{
  int netns = open("/proc/self/ns/net", O_RDONLY);
  if (netns == -1)
    return netns;
  if (setns(kInitNetNsFd, 0))
    return -1;
  int sock = syscall(__NR_socket, domain, type, proto);
  int err = errno;
  if (setns(netns, 0))
    exit(1);
  close(netns);
  errno = err;
  return sock;
}

static long syz_genetlink_get_family_id(volatile long name)
{
  char buf[512] = {0};
  struct nlmsghdr* hdr = (struct nlmsghdr*)buf;
  struct genlmsghdr* genlhdr = (struct genlmsghdr*)NLMSG_DATA(hdr);
  struct nlattr* attr = (struct nlattr*)(genlhdr + 1);
  hdr->nlmsg_len =
      sizeof(*hdr) + sizeof(*genlhdr) + sizeof(*attr) + GENL_NAMSIZ;
  hdr->nlmsg_type = GENL_ID_CTRL;
  hdr->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
  genlhdr->cmd = CTRL_CMD_GETFAMILY;
  attr->nla_type = CTRL_ATTR_FAMILY_NAME;
  attr->nla_len = sizeof(*attr) + GENL_NAMSIZ;
  NONFAILING(strncpy((char*)(attr + 1), (char*)name, GENL_NAMSIZ));
  struct iovec iov = {hdr, hdr->nlmsg_len};
  struct sockaddr_nl addr = {0};
  addr.nl_family = AF_NETLINK;
  int fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_GENERIC);
  if (fd == -1) {
    return -1;
  }
  struct msghdr msg = {&addr, sizeof(addr), &iov, 1, NULL, 0, 0};
  if (sendmsg(fd, &msg, 0) == -1) {
    close(fd);
    return -1;
  }
  ssize_t n = recv(fd, buf, sizeof(buf), 0);
  close(fd);
  if (n <= 0) {
    return -1;
  }
  if (hdr->nlmsg_type != GENL_ID_CTRL) {
    return -1;
  }
  for (; (char*)attr < buf + n;
       attr = (struct nlattr*)((char*)attr + NLMSG_ALIGN(attr->nla_len))) {
    if (attr->nla_type == CTRL_ATTR_FAMILY_ID)
      return *(uint16_t*)(attr + 1);
  }
  return -1;
}

#define XT_TABLE_SIZE 1536
#define XT_MAX_ENTRIES 10

struct xt_counters {
  uint64_t pcnt, bcnt;
};

struct ipt_getinfo {
  char name[32];
  unsigned int valid_hooks;
  unsigned int hook_entry[5];
  unsigned int underflow[5];
  unsigned int num_entries;
  unsigned int size;
};

struct ipt_get_entries {
  char name[32];
  unsigned int size;
  void* entrytable[XT_TABLE_SIZE / sizeof(void*)];
};

struct ipt_replace {
  char name[32];
  unsigned int valid_hooks;
  unsigned int num_entries;
  unsigned int size;
  unsigned int hook_entry[5];
  unsigned int underflow[5];
  unsigned int num_counters;
  struct xt_counters* counters;
  char entrytable[XT_TABLE_SIZE];
};

struct ipt_table_desc {
  const char* name;
  struct ipt_getinfo info;
  struct ipt_replace replace;
};

static struct ipt_table_desc ipv4_tables[] = {
    {.name = "filter"}, {.name = "nat"},      {.name = "mangle"},
    {.name = "raw"},    {.name = "security"},
};

static struct ipt_table_desc ipv6_tables[] = {
    {.name = "filter"}, {.name = "nat"},      {.name = "mangle"},
    {.name = "raw"},    {.name = "security"},
};

#define IPT_BASE_CTL 64
#define IPT_SO_SET_REPLACE (IPT_BASE_CTL)
#define IPT_SO_GET_INFO (IPT_BASE_CTL)
#define IPT_SO_GET_ENTRIES (IPT_BASE_CTL + 1)

struct arpt_getinfo {
  char name[32];
  unsigned int valid_hooks;
  unsigned int hook_entry[3];
  unsigned int underflow[3];
  unsigned int num_entries;
  unsigned int size;
};

struct arpt_get_entries {
  char name[32];
  unsigned int size;
  void* entrytable[XT_TABLE_SIZE / sizeof(void*)];
};

struct arpt_replace {
  char name[32];
  unsigned int valid_hooks;
  unsigned int num_entries;
  unsigned int size;
  unsigned int hook_entry[3];
  unsigned int underflow[3];
  unsigned int num_counters;
  struct xt_counters* counters;
  char entrytable[XT_TABLE_SIZE];
};

struct arpt_table_desc {
  const char* name;
  struct arpt_getinfo info;
  struct arpt_replace replace;
};

static struct arpt_table_desc arpt_tables[] = {
    {.name = "filter"},
};

#define ARPT_BASE_CTL 96
#define ARPT_SO_SET_REPLACE (ARPT_BASE_CTL)
#define ARPT_SO_GET_INFO (ARPT_BASE_CTL)
#define ARPT_SO_GET_ENTRIES (ARPT_BASE_CTL + 1)

static void checkpoint_iptables(struct ipt_table_desc* tables, int num_tables,
                                int family, int level)
{
  struct ipt_get_entries entries;
  socklen_t optlen;
  int fd, i;
  fd = socket(family, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < num_tables; i++) {
    struct ipt_table_desc* table = &tables[i];
    strcpy(table->info.name, table->name);
    strcpy(table->replace.name, table->name);
    optlen = sizeof(table->info);
    if (getsockopt(fd, level, IPT_SO_GET_INFO, &table->info, &optlen)) {
      switch (errno) {
      case EPERM:
      case ENOENT:
      case ENOPROTOOPT:
        continue;
      }
      exit(1);
    }
    if (table->info.size > sizeof(table->replace.entrytable))
      exit(1);
    if (table->info.num_entries > XT_MAX_ENTRIES)
      exit(1);
    memset(&entries, 0, sizeof(entries));
    strcpy(entries.name, table->name);
    entries.size = table->info.size;
    optlen = sizeof(entries) - sizeof(entries.entrytable) + table->info.size;
    if (getsockopt(fd, level, IPT_SO_GET_ENTRIES, &entries, &optlen))
      exit(1);
    table->replace.valid_hooks = table->info.valid_hooks;
    table->replace.num_entries = table->info.num_entries;
    table->replace.size = table->info.size;
    memcpy(table->replace.hook_entry, table->info.hook_entry,
           sizeof(table->replace.hook_entry));
    memcpy(table->replace.underflow, table->info.underflow,
           sizeof(table->replace.underflow));
    memcpy(table->replace.entrytable, entries.entrytable, table->info.size);
  }
  close(fd);
}

static void reset_iptables(struct ipt_table_desc* tables, int num_tables,
                           int family, int level)
{
  struct xt_counters counters[XT_MAX_ENTRIES];
  struct ipt_get_entries entries;
  struct ipt_getinfo info;
  socklen_t optlen;
  int fd, i;
  fd = socket(family, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < num_tables; i++) {
    struct ipt_table_desc* table = &tables[i];
    if (table->info.valid_hooks == 0)
      continue;
    memset(&info, 0, sizeof(info));
    strcpy(info.name, table->name);
    optlen = sizeof(info);
    if (getsockopt(fd, level, IPT_SO_GET_INFO, &info, &optlen))
      exit(1);
    if (memcmp(&table->info, &info, sizeof(table->info)) == 0) {
      memset(&entries, 0, sizeof(entries));
      strcpy(entries.name, table->name);
      entries.size = table->info.size;
      optlen = sizeof(entries) - sizeof(entries.entrytable) + entries.size;
      if (getsockopt(fd, level, IPT_SO_GET_ENTRIES, &entries, &optlen))
        exit(1);
      if (memcmp(table->replace.entrytable, entries.entrytable,
                 table->info.size) == 0)
        continue;
    }
    table->replace.num_counters = info.num_entries;
    table->replace.counters = counters;
    optlen = sizeof(table->replace) - sizeof(table->replace.entrytable) +
             table->replace.size;
    if (setsockopt(fd, level, IPT_SO_SET_REPLACE, &table->replace, optlen))
      exit(1);
  }
  close(fd);
}

static void checkpoint_arptables(void)
{
  struct arpt_get_entries entries;
  socklen_t optlen;
  unsigned i;
  int fd;
  fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < sizeof(arpt_tables) / sizeof(arpt_tables[0]); i++) {
    struct arpt_table_desc* table = &arpt_tables[i];
    strcpy(table->info.name, table->name);
    strcpy(table->replace.name, table->name);
    optlen = sizeof(table->info);
    if (getsockopt(fd, SOL_IP, ARPT_SO_GET_INFO, &table->info, &optlen)) {
      switch (errno) {
      case EPERM:
      case ENOENT:
      case ENOPROTOOPT:
        continue;
      }
      exit(1);
    }
    if (table->info.size > sizeof(table->replace.entrytable))
      exit(1);
    if (table->info.num_entries > XT_MAX_ENTRIES)
      exit(1);
    memset(&entries, 0, sizeof(entries));
    strcpy(entries.name, table->name);
    entries.size = table->info.size;
    optlen = sizeof(entries) - sizeof(entries.entrytable) + table->info.size;
    if (getsockopt(fd, SOL_IP, ARPT_SO_GET_ENTRIES, &entries, &optlen))
      exit(1);
    table->replace.valid_hooks = table->info.valid_hooks;
    table->replace.num_entries = table->info.num_entries;
    table->replace.size = table->info.size;
    memcpy(table->replace.hook_entry, table->info.hook_entry,
           sizeof(table->replace.hook_entry));
    memcpy(table->replace.underflow, table->info.underflow,
           sizeof(table->replace.underflow));
    memcpy(table->replace.entrytable, entries.entrytable, table->info.size);
  }
  close(fd);
}

static void reset_arptables()
{
  struct xt_counters counters[XT_MAX_ENTRIES];
  struct arpt_get_entries entries;
  struct arpt_getinfo info;
  socklen_t optlen;
  unsigned i;
  int fd;
  fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < sizeof(arpt_tables) / sizeof(arpt_tables[0]); i++) {
    struct arpt_table_desc* table = &arpt_tables[i];
    if (table->info.valid_hooks == 0)
      continue;
    memset(&info, 0, sizeof(info));
    strcpy(info.name, table->name);
    optlen = sizeof(info);
    if (getsockopt(fd, SOL_IP, ARPT_SO_GET_INFO, &info, &optlen))
      exit(1);
    if (memcmp(&table->info, &info, sizeof(table->info)) == 0) {
      memset(&entries, 0, sizeof(entries));
      strcpy(entries.name, table->name);
      entries.size = table->info.size;
      optlen = sizeof(entries) - sizeof(entries.entrytable) + entries.size;
      if (getsockopt(fd, SOL_IP, ARPT_SO_GET_ENTRIES, &entries, &optlen))
        exit(1);
      if (memcmp(table->replace.entrytable, entries.entrytable,
                 table->info.size) == 0)
        continue;
    } else {
    }
    table->replace.num_counters = info.num_entries;
    table->replace.counters = counters;
    optlen = sizeof(table->replace) - sizeof(table->replace.entrytable) +
             table->replace.size;
    if (setsockopt(fd, SOL_IP, ARPT_SO_SET_REPLACE, &table->replace, optlen))
      exit(1);
  }
  close(fd);
}

#define NF_BR_NUMHOOKS 6
#define EBT_TABLE_MAXNAMELEN 32
#define EBT_CHAIN_MAXNAMELEN 32
#define EBT_BASE_CTL 128
#define EBT_SO_SET_ENTRIES (EBT_BASE_CTL)
#define EBT_SO_GET_INFO (EBT_BASE_CTL)
#define EBT_SO_GET_ENTRIES (EBT_SO_GET_INFO + 1)
#define EBT_SO_GET_INIT_INFO (EBT_SO_GET_ENTRIES + 1)
#define EBT_SO_GET_INIT_ENTRIES (EBT_SO_GET_INIT_INFO + 1)

struct ebt_replace {
  char name[EBT_TABLE_MAXNAMELEN];
  unsigned int valid_hooks;
  unsigned int nentries;
  unsigned int entries_size;
  struct ebt_entries* hook_entry[NF_BR_NUMHOOKS];
  unsigned int num_counters;
  struct ebt_counter* counters;
  char* entries;
};

struct ebt_entries {
  unsigned int distinguisher;
  char name[EBT_CHAIN_MAXNAMELEN];
  unsigned int counter_offset;
  int policy;
  unsigned int nentries;
  char data[0] __attribute__((aligned(__alignof__(struct ebt_replace))));
};

struct ebt_table_desc {
  const char* name;
  struct ebt_replace replace;
  char entrytable[XT_TABLE_SIZE];
};

static struct ebt_table_desc ebt_tables[] = {
    {.name = "filter"},
    {.name = "nat"},
    {.name = "broute"},
};

static void checkpoint_ebtables(void)
{
  socklen_t optlen;
  unsigned i;
  int fd;
  fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < sizeof(ebt_tables) / sizeof(ebt_tables[0]); i++) {
    struct ebt_table_desc* table = &ebt_tables[i];
    strcpy(table->replace.name, table->name);
    optlen = sizeof(table->replace);
    if (getsockopt(fd, SOL_IP, EBT_SO_GET_INIT_INFO, &table->replace,
                   &optlen)) {
      switch (errno) {
      case EPERM:
      case ENOENT:
      case ENOPROTOOPT:
        continue;
      }
      exit(1);
    }
    if (table->replace.entries_size > sizeof(table->entrytable))
      exit(1);
    table->replace.num_counters = 0;
    table->replace.entries = table->entrytable;
    optlen = sizeof(table->replace) + table->replace.entries_size;
    if (getsockopt(fd, SOL_IP, EBT_SO_GET_INIT_ENTRIES, &table->replace,
                   &optlen))
      exit(1);
  }
  close(fd);
}

static void reset_ebtables()
{
  struct ebt_replace replace;
  char entrytable[XT_TABLE_SIZE];
  socklen_t optlen;
  unsigned i, j, h;
  int fd;
  fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < sizeof(ebt_tables) / sizeof(ebt_tables[0]); i++) {
    struct ebt_table_desc* table = &ebt_tables[i];
    if (table->replace.valid_hooks == 0)
      continue;
    memset(&replace, 0, sizeof(replace));
    strcpy(replace.name, table->name);
    optlen = sizeof(replace);
    if (getsockopt(fd, SOL_IP, EBT_SO_GET_INFO, &replace, &optlen))
      exit(1);
    replace.num_counters = 0;
    table->replace.entries = 0;
    for (h = 0; h < NF_BR_NUMHOOKS; h++)
      table->replace.hook_entry[h] = 0;
    if (memcmp(&table->replace, &replace, sizeof(table->replace)) == 0) {
      memset(&entrytable, 0, sizeof(entrytable));
      replace.entries = entrytable;
      optlen = sizeof(replace) + replace.entries_size;
      if (getsockopt(fd, SOL_IP, EBT_SO_GET_ENTRIES, &replace, &optlen))
        exit(1);
      if (memcmp(table->entrytable, entrytable, replace.entries_size) == 0)
        continue;
    }
    for (j = 0, h = 0; h < NF_BR_NUMHOOKS; h++) {
      if (table->replace.valid_hooks & (1 << h)) {
        table->replace.hook_entry[h] =
            (struct ebt_entries*)table->entrytable + j;
        j++;
      }
    }
    table->replace.entries = table->entrytable;
    optlen = sizeof(table->replace) + table->replace.entries_size;
    if (setsockopt(fd, SOL_IP, EBT_SO_SET_ENTRIES, &table->replace, optlen))
      exit(1);
  }
  close(fd);
}

static void checkpoint_net_namespace(void)
{
  checkpoint_ebtables();
  checkpoint_arptables();
  checkpoint_iptables(ipv4_tables, sizeof(ipv4_tables) / sizeof(ipv4_tables[0]),
                      AF_INET, SOL_IP);
  checkpoint_iptables(ipv6_tables, sizeof(ipv6_tables) / sizeof(ipv6_tables[0]),
                      AF_INET6, SOL_IPV6);
}

static void reset_net_namespace(void)
{
  reset_ebtables();
  reset_arptables();
  reset_iptables(ipv4_tables, sizeof(ipv4_tables) / sizeof(ipv4_tables[0]),
                 AF_INET, SOL_IP);
  reset_iptables(ipv6_tables, sizeof(ipv6_tables) / sizeof(ipv6_tables[0]),
                 AF_INET6, SOL_IPV6);
}

static void setup_cgroups()
{
  if (mkdir("/syzcgroup", 0777)) {
  }
  if (mkdir("/syzcgroup/unified", 0777)) {
  }
  if (mount("none", "/syzcgroup/unified", "cgroup2", 0, NULL)) {
  }
  if (chmod("/syzcgroup/unified", 0777)) {
  }
  write_file("/syzcgroup/unified/cgroup.subtree_control",
             "+cpu +memory +io +pids +rdma");
  if (mkdir("/syzcgroup/cpu", 0777)) {
  }
  if (mount("none", "/syzcgroup/cpu", "cgroup", 0,
            "cpuset,cpuacct,perf_event,hugetlb")) {
  }
  write_file("/syzcgroup/cpu/cgroup.clone_children", "1");
  if (chmod("/syzcgroup/cpu", 0777)) {
  }
  if (mkdir("/syzcgroup/net", 0777)) {
  }
  if (mount("none", "/syzcgroup/net", "cgroup", 0,
            "net_cls,net_prio,devices,freezer")) {
  }
  if (chmod("/syzcgroup/net", 0777)) {
  }
}

static void setup_cgroups_loop()
{
  int pid = getpid();
  char file[128];
  char cgroupdir[64];
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/unified/syz%llu", procid);
  if (mkdir(cgroupdir, 0777)) {
  }
  snprintf(file, sizeof(file), "%s/pids.max", cgroupdir);
  write_file(file, "32");
  snprintf(file, sizeof(file), "%s/memory.low", cgroupdir);
  write_file(file, "%d", 298 << 20);
  snprintf(file, sizeof(file), "%s/memory.high", cgroupdir);
  write_file(file, "%d", 299 << 20);
  snprintf(file, sizeof(file), "%s/memory.max", cgroupdir);
  write_file(file, "%d", 300 << 20);
  snprintf(file, sizeof(file), "%s/cgroup.procs", cgroupdir);
  write_file(file, "%d", pid);
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/cpu/syz%llu", procid);
  if (mkdir(cgroupdir, 0777)) {
  }
  snprintf(file, sizeof(file), "%s/cgroup.procs", cgroupdir);
  write_file(file, "%d", pid);
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/net/syz%llu", procid);
  if (mkdir(cgroupdir, 0777)) {
  }
  snprintf(file, sizeof(file), "%s/cgroup.procs", cgroupdir);
  write_file(file, "%d", pid);
}

static void setup_cgroups_test()
{
  char cgroupdir[64];
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/unified/syz%llu", procid);
  if (symlink(cgroupdir, "./cgroup")) {
  }
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/cpu/syz%llu", procid);
  if (symlink(cgroupdir, "./cgroup.cpu")) {
  }
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/net/syz%llu", procid);
  if (symlink(cgroupdir, "./cgroup.net")) {
  }
}

static void setup_binfmt_misc()
{
  if (mount(0, "/proc/sys/fs/binfmt_misc", "binfmt_misc", 0, 0)) {
  }
  write_file("/proc/sys/fs/binfmt_misc/register", ":syz0:M:0:\x01::./file0:");
  write_file("/proc/sys/fs/binfmt_misc/register",
             ":syz1:M:1:\x02::./file0:POC");
}

static void setup_common()
{
  if (mount(0, "/sys/fs/fuse/connections", "fusectl", 0, 0)) {
  }
  setup_cgroups();
  setup_binfmt_misc();
}

static void loop();

static void sandbox_common()
{
  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
  setpgrp();
  setsid();
  int netns = open("/proc/self/ns/net", O_RDONLY);
  if (netns == -1)
    exit(1);
  if (dup2(netns, kInitNetNsFd) < 0)
    exit(1);
  close(netns);
  struct rlimit rlim;
  rlim.rlim_cur = rlim.rlim_max = (200 << 20);
  setrlimit(RLIMIT_AS, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 32 << 20;
  setrlimit(RLIMIT_MEMLOCK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 136 << 20;
  setrlimit(RLIMIT_FSIZE, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 1 << 20;
  setrlimit(RLIMIT_STACK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 0;
  setrlimit(RLIMIT_CORE, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 256;
  setrlimit(RLIMIT_NOFILE, &rlim);
  if (unshare(CLONE_NEWNS)) {
  }
  if (unshare(CLONE_NEWIPC)) {
  }
  if (unshare(0x02000000)) {
  }
  if (unshare(CLONE_NEWUTS)) {
  }
  if (unshare(CLONE_SYSVSEM)) {
  }
  typedef struct {
    const char* name;
    const char* value;
  } sysctl_t;
  static const sysctl_t sysctls[] = {
      {"/proc/sys/kernel/shmmax", "16777216"},
      {"/proc/sys/kernel/shmall", "536870912"},
      {"/proc/sys/kernel/shmmni", "1024"},
      {"/proc/sys/kernel/msgmax", "8192"},
      {"/proc/sys/kernel/msgmni", "1024"},
      {"/proc/sys/kernel/msgmnb", "1024"},
      {"/proc/sys/kernel/sem", "1024 1048576 500 1024"},
  };
  unsigned i;
  for (i = 0; i < sizeof(sysctls) / sizeof(sysctls[0]); i++)
    write_file(sysctls[i].name, sysctls[i].value);
}

int wait_for_loop(int pid)
{
  if (pid < 0)
    exit(1);
  int status = 0;
  while (waitpid(-1, &status, __WALL) != pid) {
  }
  return WEXITSTATUS(status);
}

static int do_sandbox_none(void)
{
  if (unshare(CLONE_NEWPID)) {
  }
  int pid = fork();
  if (pid != 0)
    return wait_for_loop(pid);
  setup_common();
  sandbox_common();
  initialize_netdevices_init();
  if (unshare(CLONE_NEWNET)) {
  }
  initialize_tun();
  initialize_netdevices();
  loop();
  exit(1);
}

#define FS_IOC_SETFLAGS _IOW('f', 2, long)
static void remove_dir(const char* dir)
{
  DIR* dp;
  struct dirent* ep;
  int iter = 0;
retry:
  while (umount2(dir, MNT_DETACH) == 0) {
  }
  dp = opendir(dir);
  if (dp == NULL) {
    if (errno == EMFILE) {
      exit(1);
    }
    exit(1);
  }
  while ((ep = readdir(dp))) {
    if (strcmp(ep->d_name, ".") == 0 || strcmp(ep->d_name, "..") == 0)
      continue;
    char filename[FILENAME_MAX];
    snprintf(filename, sizeof(filename), "%s/%s", dir, ep->d_name);
    while (umount2(filename, MNT_DETACH) == 0) {
    }
    struct stat st;
    if (lstat(filename, &st))
      exit(1);
    if (S_ISDIR(st.st_mode)) {
      remove_dir(filename);
      continue;
    }
    int i;
    for (i = 0;; i++) {
      if (unlink(filename) == 0)
        break;
      if (errno == EPERM) {
        int fd = open(filename, O_RDONLY);
        if (fd != -1) {
          long flags = 0;
          if (ioctl(fd, FS_IOC_SETFLAGS, &flags) == 0)
            close(fd);
          continue;
        }
      }
      if (errno == EROFS) {
        break;
      }
      if (errno != EBUSY || i > 100)
        exit(1);
      if (umount2(filename, MNT_DETACH))
        exit(1);
    }
  }
  closedir(dp);
  int i;
  for (i = 0;; i++) {
    if (rmdir(dir) == 0)
      break;
    if (i < 100) {
      if (errno == EPERM) {
        int fd = open(dir, O_RDONLY);
        if (fd != -1) {
          long flags = 0;
          if (ioctl(fd, FS_IOC_SETFLAGS, &flags) == 0)
            close(fd);
          continue;
        }
      }
      if (errno == EROFS) {
        break;
      }
      if (errno == EBUSY) {
        if (umount2(dir, MNT_DETACH))
          exit(1);
        continue;
      }
      if (errno == ENOTEMPTY) {
        if (iter < 100) {
          iter++;
          goto retry;
        }
      }
    }
    exit(1);
  }
}

static void kill_and_wait(int pid, int* status)
{
  kill(-pid, SIGKILL);
  kill(pid, SIGKILL);
  int i;
  for (i = 0; i < 100; i++) {
    if (waitpid(-1, status, WNOHANG | __WALL) == pid)
      return;
    usleep(1000);
  }
  DIR* dir = opendir("/sys/fs/fuse/connections");
  if (dir) {
    for (;;) {
      struct dirent* ent = readdir(dir);
      if (!ent)
        break;
      if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
        continue;
      char abort[300];
      snprintf(abort, sizeof(abort), "/sys/fs/fuse/connections/%s/abort",
               ent->d_name);
      int fd = open(abort, O_WRONLY);
      if (fd == -1) {
        continue;
      }
      if (write(fd, abort, 1) < 0) {
      }
      close(fd);
    }
    closedir(dir);
  } else {
  }
  while (waitpid(-1, status, __WALL) != pid) {
  }
}

#define SYZ_HAVE_SETUP_LOOP 1
static void setup_loop()
{
  setup_cgroups_loop();
  checkpoint_net_namespace();
}

#define SYZ_HAVE_RESET_LOOP 1
static void reset_loop()
{
  reset_net_namespace();
}

#define SYZ_HAVE_SETUP_TEST 1
static void setup_test()
{
  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
  setpgrp();
  setup_cgroups_test();
  write_file("/proc/self/oom_score_adj", "1000");
  flush_tun();
}

#define SYZ_HAVE_CLOSE_FDS 1
static void close_fds()
{
  int fd;
  for (fd = 3; fd < 30; fd++)
    close(fd);
}

struct thread_t {
  int created, call;
  event_t ready, done;
};

static struct thread_t threads[16];
static void execute_call(int call);
static int running;

static void* thr(void* arg)
{
  struct thread_t* th = (struct thread_t*)arg;
  for (;;) {
    event_wait(&th->ready);
    event_reset(&th->ready);
    execute_call(th->call);
    __atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
    event_set(&th->done);
  }
  return 0;
}

static void execute_one(void)
{
  int i, call, thread;
  int collide = 0;
again:
  for (call = 0; call < 163; call++) {
    for (thread = 0; thread < (int)(sizeof(threads) / sizeof(threads[0]));
         thread++) {
      struct thread_t* th = &threads[thread];
      if (!th->created) {
        th->created = 1;
        event_init(&th->ready);
        event_init(&th->done);
        event_set(&th->done);
        thread_start(thr, th);
      }
      if (!event_isset(&th->done))
        continue;
      event_reset(&th->done);
      th->call = call;
      __atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
      event_set(&th->ready);
      if (collide && (call % 2) == 0)
        break;
      event_timedwait(&th->done, 45);
      break;
    }
  }
  for (i = 0; i < 100 && __atomic_load_n(&running, __ATOMIC_RELAXED); i++)
    sleep_ms(1);
  close_fds();
  if (!collide) {
    collide = 1;
    goto again;
  }
}

static void execute_one(void);

#define WAIT_FLAGS __WALL

static void loop(void)
{
  setup_loop();
  int iter;
  for (iter = 0;; iter++) {
    char cwdbuf[32];
    sprintf(cwdbuf, "./%d", iter);
    if (mkdir(cwdbuf, 0777))
      exit(1);
    reset_loop();
    int pid = fork();
    if (pid < 0)
      exit(1);
    if (pid == 0) {
      if (chdir(cwdbuf))
        exit(1);
      setup_test();
      execute_one();
      exit(0);
    }
    int status = 0;
    uint64_t start = current_time_ms();
    for (;;) {
      if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
        break;
      sleep_ms(1);
      if (current_time_ms() - start < 5 * 1000)
        continue;
      kill_and_wait(pid, &status);
      break;
    }
    remove_dir(cwdbuf);
  }
}

#ifndef __NR_bpf
#define __NR_bpf 321
#endif

uint64_t r[44] = {0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0x0,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff};

void execute_call(int call)
{
  long res;
  switch (call) {
  case 0:
    res = syscall(__NR_socket, 2, 0x80001, 0x84);
    if (res != -1)
      r[0] = res;
    break;
  case 1:
    NONFAILING(*(uint64_t*)0x20000000 = 0x20006000);
    NONFAILING(*(uint16_t*)0x20006000 = 2);
    NONFAILING(*(uint16_t*)0x20006002 = htobe16(0x4e20));
    NONFAILING(*(uint32_t*)0x20006004 = htobe32(0x7f000001));
    NONFAILING(*(uint32_t*)0x20000008 = 0x57);
    NONFAILING(*(uint64_t*)0x20000010 = 0x200002c0);
    NONFAILING(*(uint64_t*)0x200002c0 = 0x20001840);
    NONFAILING(*(uint64_t*)0x200002c8 = 0x1fff8);
    NONFAILING(*(uint64_t*)0x20000018 = 1);
    NONFAILING(*(uint64_t*)0x20000020 = 0);
    NONFAILING(*(uint64_t*)0x20000028 = 0);
    NONFAILING(*(uint32_t*)0x20000030 = 0);
    syscall(__NR_sendmsg, r[0], 0x20000000, 0);
    break;
  case 2:
    res = syscall(__NR_socket, 2, 2, 0x88);
    if (res != -1)
      r[1] = res;
    break;
  case 3:
    syscall(__NR_ioctl, r[1], 0x1000008912, 0);
    break;
  case 4:
    syscall(__NR_close, r[0]);
    break;
  case 5:
    syscall(__NR_connect, -1, 0, 0);
    break;
  case 6:
    res = syscall(__NR_socket, 0x11, 0x8000000003, 0x300);
    if (res != -1)
      r[2] = res;
    break;
  case 7:
    NONFAILING(*(uint16_t*)0x20000000 = 0xa);
    NONFAILING(*(uint16_t*)0x20000002 = htobe16(0));
    NONFAILING(*(uint32_t*)0x20000004 = htobe32(0));
    NONFAILING(*(uint8_t*)0x20000008 = -1);
    NONFAILING(*(uint8_t*)0x20000009 = 2);
    NONFAILING(*(uint8_t*)0x2000000a = 0);
    NONFAILING(*(uint8_t*)0x2000000b = 0);
    NONFAILING(*(uint8_t*)0x2000000c = 0);
    NONFAILING(*(uint8_t*)0x2000000d = 0);
    NONFAILING(*(uint8_t*)0x2000000e = 0);
    NONFAILING(*(uint8_t*)0x2000000f = 0);
    NONFAILING(*(uint8_t*)0x20000010 = 0);
    NONFAILING(*(uint8_t*)0x20000011 = 0);
    NONFAILING(*(uint8_t*)0x20000012 = 0);
    NONFAILING(*(uint8_t*)0x20000013 = 0);
    NONFAILING(*(uint8_t*)0x20000014 = 0);
    NONFAILING(*(uint8_t*)0x20000015 = 0);
    NONFAILING(*(uint8_t*)0x20000016 = 0);
    NONFAILING(*(uint8_t*)0x20000017 = 1);
    NONFAILING(*(uint32_t*)0x20000018 = 4);
    syscall(__NR_connect, -1, 0x20000000, 0x1c);
    break;
  case 8:
    NONFAILING(*(uint16_t*)0x20000140 = 0);
    NONFAILING(*(uint8_t*)0x20000142 = 0);
    NONFAILING(*(uint8_t*)0x20000143 = 0xd7);
    syscall(__NR_setsockopt, r[2], 0x107, 0x12, 0x20000140, 4);
    break;
  case 9:
    syscall(__NR_sendmmsg, -1, 0x200092c0, 0x4f, 0);
    break;
  case 10:
    syscall(__NR_sendmmsg, -1, 0, 0, 0);
    break;
  case 11:
    syscall(__NR_sendmsg, -1, 0, 0);
    break;
  case 12:
    res = syscall(__NR_socket, 2, 2, 0x88);
    if (res != -1)
      r[3] = res;
    break;
  case 13:
    syscall(__NR_ioctl, r[3], 0x1000008912, 0);
    break;
  case 14:
    syscall(__NR_close, -1);
    break;
  case 15:
    res = syscall(__NR_socket, 2, 0x80001, 0x84);
    if (res != -1)
      r[4] = res;
    break;
  case 16:
    NONFAILING(*(uint16_t*)0x20000040 = 2);
    NONFAILING(*(uint16_t*)0x20000042 = htobe16(0x4e20));
    NONFAILING(*(uint32_t*)0x20000044 = htobe32(0x7f000001));
    syscall(__NR_bind, r[4], 0x20000040, 0x10);
    break;
  case 17:
    syscall(__NR_sendmsg, r[4], 0, 0);
    break;
  case 18:
    NONFAILING(*(uint16_t*)0x20000100 = 0xa);
    NONFAILING(*(uint16_t*)0x20000102 = htobe16(0x4e21));
    NONFAILING(*(uint32_t*)0x20000104 = htobe32(0));
    NONFAILING(*(uint8_t*)0x20000108 = 0);
    NONFAILING(*(uint8_t*)0x20000109 = 0);
    NONFAILING(*(uint8_t*)0x2000010a = 0);
    NONFAILING(*(uint8_t*)0x2000010b = 0);
    NONFAILING(*(uint8_t*)0x2000010c = 0);
    NONFAILING(*(uint8_t*)0x2000010d = 0);
    NONFAILING(*(uint8_t*)0x2000010e = 0);
    NONFAILING(*(uint8_t*)0x2000010f = 0);
    NONFAILING(*(uint8_t*)0x20000110 = 0);
    NONFAILING(*(uint8_t*)0x20000111 = 0);
    NONFAILING(*(uint8_t*)0x20000112 = 0);
    NONFAILING(*(uint8_t*)0x20000113 = 0);
    NONFAILING(*(uint8_t*)0x20000114 = 0);
    NONFAILING(*(uint8_t*)0x20000115 = 0);
    NONFAILING(*(uint8_t*)0x20000116 = 0);
    NONFAILING(*(uint8_t*)0x20000117 = 0);
    NONFAILING(*(uint32_t*)0x20000118 = 0);
    syscall(__NR_bind, -1, 0x20000100, 0x1c);
    break;
  case 19:
    syscall(__NR_setsockopt, -1, 0x84, 0x72, 0, 0);
    break;
  case 20:
    NONFAILING(*(uint16_t*)0x20000200 = 0xa);
    NONFAILING(*(uint16_t*)0x20000202 = htobe16(0x4e21));
    NONFAILING(*(uint32_t*)0x20000204 = htobe32(0));
    NONFAILING(*(uint64_t*)0x20000208 = htobe64(0));
    NONFAILING(*(uint64_t*)0x20000210 = htobe64(1));
    NONFAILING(*(uint32_t*)0x20000218 = 0);
    syscall(__NR_connect, -1, 0x20000200, 0x1c);
    break;
  case 21:
    syscall(__NR_write, -1, 0, 0);
    break;
  case 22:
    syscall(__NR_socket, 2, 2, 0x88);
    break;
  case 23:
    syscall(__NR_socket, 2, 2, 0x88);
    break;
  case 24:
    syscall(__NR_socket, 0x15, 5, 0);
    break;
  case 25:
    res = syscall(__NR_socket, 0x10, 3, 0x10);
    if (res != -1)
      r[5] = res;
    break;
  case 26:
    NONFAILING(memcpy((void*)0x20000040, "TIPCv2\000", 7));
    res = syz_genetlink_get_family_id(0x20000040);
    if (res != -1)
      r[6] = res;
    break;
  case 27:
    NONFAILING(*(uint64_t*)0x200000c0 = 0);
    NONFAILING(*(uint32_t*)0x200000c8 = 0);
    NONFAILING(*(uint64_t*)0x200000d0 = 0x20000080);
    NONFAILING(*(uint64_t*)0x20000080 = 0x20000340);
    NONFAILING(*(uint32_t*)0x20000340 = 0x54);
    NONFAILING(*(uint16_t*)0x20000344 = r[6]);
    NONFAILING(*(uint16_t*)0x20000346 = 1);
    NONFAILING(*(uint32_t*)0x20000348 = 0);
    NONFAILING(*(uint32_t*)0x2000034c = 0);
    NONFAILING(*(uint8_t*)0x20000350 = 3);
    NONFAILING(*(uint8_t*)0x20000351 = 0);
    NONFAILING(*(uint16_t*)0x20000352 = 0);
    NONFAILING(*(uint16_t*)0x20000354 = 0x40);
    NONFAILING(*(uint16_t*)0x20000356 = 1);
    NONFAILING(*(uint16_t*)0x20000358 = 0x10);
    NONFAILING(*(uint16_t*)0x2000035a = 1);
    NONFAILING(memcpy((void*)0x2000035c, "udp:\nyz1\000", 9));
    NONFAILING(*(uint16_t*)0x20000368 = 0x2c);
    NONFAILING(*(uint16_t*)0x2000036a = 4);
    NONFAILING(*(uint16_t*)0x2000036c = 0x14);
    NONFAILING(*(uint16_t*)0x2000036e = 1);
    NONFAILING(*(uint16_t*)0x20000370 = 2);
    NONFAILING(*(uint16_t*)0x20000372 = htobe16(0));
    NONFAILING(*(uint8_t*)0x20000374 = 0xac);
    NONFAILING(*(uint8_t*)0x20000375 = 0x14);
    NONFAILING(*(uint8_t*)0x20000376 = 0x14);
    NONFAILING(*(uint8_t*)0x20000377 = 0xaa);
    NONFAILING(*(uint16_t*)0x20000380 = 0x14);
    NONFAILING(*(uint16_t*)0x20000382 = 2);
    NONFAILING(*(uint16_t*)0x20000384 = 2);
    NONFAILING(*(uint16_t*)0x20000386 = htobe16(0));
    NONFAILING(*(uint8_t*)0x20000388 = 0xac);
    NONFAILING(*(uint8_t*)0x20000389 = 0x14);
    NONFAILING(*(uint8_t*)0x2000038a = 0x14);
    NONFAILING(*(uint8_t*)0x2000038b = 0xbb);
    NONFAILING(*(uint64_t*)0x20000088 = 0x54);
    NONFAILING(*(uint64_t*)0x200000d8 = 1);
    NONFAILING(*(uint64_t*)0x200000e0 = 0);
    NONFAILING(*(uint64_t*)0x200000e8 = 0);
    NONFAILING(*(uint32_t*)0x200000f0 = 0);
    syscall(__NR_sendmsg, r[5], 0x200000c0, 0);
    break;
  case 28:
    res = syscall(__NR_socket, 2, 0x80001, 0x84);
    if (res != -1)
      r[7] = res;
    break;
  case 29:
    NONFAILING(*(uint16_t*)0x20000040 = 2);
    NONFAILING(*(uint16_t*)0x20000042 = htobe16(0x4e20));
    NONFAILING(*(uint32_t*)0x20000044 = htobe32(0x7f000001));
    syscall(__NR_bind, r[7], 0x20000040, 0x10);
    break;
  case 30:
    res = syscall(__NR_socket, 2, 2, 0x88);
    if (res != -1)
      r[8] = res;
    break;
  case 31:
    NONFAILING(memcpy((void*)0x20000000,
                      "\x0a\xdc\x1f\x12\x3c\x12\x3f\x31\x9b\xd0\x70", 11));
    syscall(__NR_ioctl, r[8], 0x1000008912, 0x20000000);
    break;
  case 32:
    syscall(__NR_close, r[7]);
    break;
  case 33:
    res = syscall(__NR_socket, 0xa, 1, 0x84);
    if (res != -1)
      r[9] = res;
    break;
  case 34:
    NONFAILING(*(uint32_t*)0x200001c0 = 0);
    NONFAILING(*(uint32_t*)0x200001c4 = 0);
    NONFAILING(*(uint16_t*)0x200001c8 = 0x20);
    syscall(__NR_setsockopt, r[9], 0x84, 0x72, 0x200001c0, 0xc);
    break;
  case 35:
    NONFAILING(*(uint16_t*)0x20000200 = 0xa);
    NONFAILING(*(uint16_t*)0x20000202 = htobe16(0x4e21));
    NONFAILING(*(uint32_t*)0x20000204 = htobe32(0));
    NONFAILING(*(uint64_t*)0x20000208 = htobe64(0));
    NONFAILING(*(uint64_t*)0x20000210 = htobe64(1));
    NONFAILING(*(uint32_t*)0x20000218 = 0);
    syscall(__NR_connect, r[9], 0x20000200, 0x1c);
    break;
  case 36:
    NONFAILING(*(uint8_t*)0x20000480 = 0x7f);
    NONFAILING(*(uint8_t*)0x20000481 = 0x45);
    NONFAILING(*(uint8_t*)0x20000482 = 0x4c);
    NONFAILING(*(uint8_t*)0x20000483 = 0x46);
    NONFAILING(*(uint8_t*)0x20000484 = 0);
    NONFAILING(*(uint8_t*)0x20000485 = 0);
    NONFAILING(*(uint8_t*)0x20000486 = 0);
    NONFAILING(*(uint8_t*)0x20000487 = 0);
    NONFAILING(*(uint64_t*)0x20000488 = 0);
    NONFAILING(*(uint16_t*)0x20000490 = 0);
    NONFAILING(*(uint16_t*)0x20000492 = 0);
    NONFAILING(*(uint32_t*)0x20000494 = 0);
    NONFAILING(*(uint64_t*)0x20000498 = 0);
    NONFAILING(*(uint64_t*)0x200004a0 = 0x40);
    NONFAILING(*(uint64_t*)0x200004a8 = 0);
    NONFAILING(*(uint32_t*)0x200004b0 = 0);
    NONFAILING(*(uint16_t*)0x200004b4 = 0);
    NONFAILING(*(uint16_t*)0x200004b6 = 0x38);
    NONFAILING(*(uint16_t*)0x200004b8 = 0);
    NONFAILING(*(uint16_t*)0x200004ba = 0);
    NONFAILING(*(uint16_t*)0x200004bc = 0);
    NONFAILING(*(uint16_t*)0x200004be = 0);
    NONFAILING(*(uint32_t*)0x200004c0 = 0);
    NONFAILING(*(uint32_t*)0x200004c4 = 0);
    NONFAILING(*(uint64_t*)0x200004c8 = 0);
    NONFAILING(*(uint64_t*)0x200004d0 = 0);
    NONFAILING(*(uint64_t*)0x200004d8 = 0);
    NONFAILING(*(uint64_t*)0x200004e0 = 0);
    NONFAILING(*(uint64_t*)0x200004e8 = 0);
    NONFAILING(*(uint64_t*)0x200004f0 = 0);
    syscall(__NR_write, r[9], 0x20000480, 0x34000);
    break;
  case 37:
    res = syscall(__NR_socket, 2, 2, 0x88);
    if (res != -1)
      r[10] = res;
    break;
  case 38:
    NONFAILING(memcpy((void*)0x200000c0,
                      "\x0a\xdc\x1f\x12\x3c\x12\x3f\x31\x9b\xd0\x70", 11));
    syscall(__NR_ioctl, -1, 0x1000008912, 0x200000c0);
    break;
  case 39:
    syscall(__NR_setsockopt, r[10], 0, 0x80, 0, 0x498);
    break;
  case 40:
    NONFAILING(
        memcpy((void*)0x20000040,
               "nat\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
               "\000\000\000\000\000\000\000\000\000\000\000\000\000\000",
               32));
    NONFAILING(*(uint32_t*)0x20000060 = 0x19);
    NONFAILING(*(uint32_t*)0x20000064 = 1);
    NONFAILING(*(uint32_t*)0x20000068 = 0);
    NONFAILING(*(uint64_t*)0x20000070 = 0x20000380);
    NONFAILING(*(uint64_t*)0x20000078 = 0);
    NONFAILING(*(uint64_t*)0x20000080 = 0);
    NONFAILING(*(uint64_t*)0x20000088 = 0x200003b0);
    NONFAILING(*(uint64_t*)0x20000090 = 0x200003e0);
    NONFAILING(*(uint64_t*)0x20000098 = 0);
    NONFAILING(*(uint32_t*)0x200000a0 = 0);
    NONFAILING(*(uint64_t*)0x200000a8 = 0);
    NONFAILING(*(uint64_t*)0x200000b0 = 0x20000000);
    syscall(__NR_setsockopt, -1, 0, 0x80, 0x20000040, 0x78);
    break;
  case 41:
    res = syscall(__NR_socket, 2, 1, 0);
    if (res != -1)
      r[11] = res;
    break;
  case 42:
    NONFAILING(
        memcpy((void*)0x200000c0,
               "nat\000\000\000\000\000\000\000\003\000\000\000\000\000\000\000"
               "\000\000\000\000\000\000\000\000\000\000\000\000\000\000",
               32));
    NONFAILING(*(uint32_t*)0x200000e0 = 0x19);
    NONFAILING(*(uint32_t*)0x200000e4 = 1);
    NONFAILING(*(uint32_t*)0x200000e8 = 0x178);
    NONFAILING(*(uint64_t*)0x200000f0 = 0x200003c0);
    NONFAILING(*(uint64_t*)0x200000f8 = 0);
    NONFAILING(*(uint64_t*)0x20000100 = 0);
    NONFAILING(*(uint64_t*)0x20000108 = 0x200003f0);
    NONFAILING(*(uint64_t*)0x20000110 = 0x20000420);
    NONFAILING(*(uint64_t*)0x20000118 = 0);
    NONFAILING(*(uint32_t*)0x20000120 = 0);
    NONFAILING(*(uint64_t*)0x20000128 = 0);
    NONFAILING(*(uint64_t*)0x20000130 = 0x200003c0);
    NONFAILING(*(uint32_t*)0x200003c0 = 0);
    NONFAILING(memcpy(
        (void*)0x200003c4,
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000",
        32));
    NONFAILING(*(uint32_t*)0x200003e4 = 0);
    NONFAILING(*(uint32_t*)0x200003e8 = 0xfffffffe);
    NONFAILING(*(uint32_t*)0x200003ec = 0);
    NONFAILING(*(uint32_t*)0x200003f0 = 0);
    NONFAILING(memcpy(
        (void*)0x200003f4,
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000",
        32));
    NONFAILING(*(uint32_t*)0x20000414 = 0);
    NONFAILING(*(uint32_t*)0x20000418 = -1);
    NONFAILING(*(uint32_t*)0x2000041c = 0);
    NONFAILING(*(uint32_t*)0x20000420 = 0);
    NONFAILING(memcpy(
        (void*)0x20000424,
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000",
        32));
    NONFAILING(*(uint32_t*)0x20000444 = 0);
    NONFAILING(*(uint32_t*)0x20000448 = 0xfffffffe);
    NONFAILING(*(uint32_t*)0x2000044c = 1);
    NONFAILING(*(uint32_t*)0x20000450 = 3);
    NONFAILING(*(uint32_t*)0x20000454 = 0);
    NONFAILING(*(uint16_t*)0x20000458 = htobe16(0x800));
    NONFAILING(memcpy((void*)0x2000045a,
                      "ifb0\000\000\000\000\000\000\000\000\000\000\000\000",
                      16));
    NONFAILING(memcpy((void*)0x2000046a,
                      "dummy0\000\000\000\000\000\000\000\000\000\000", 16));
    NONFAILING(memcpy((void*)0x2000047a,
                      "ip_vti0\000\000\000\000\000\000\000\000\000", 16));
    NONFAILING(memcpy((void*)0x2000048a,
                      "ip6tnl0\000\000\000\000\000\000\000\000\000", 16));
    NONFAILING(*(uint8_t*)0x2000049a = 0xaa);
    NONFAILING(*(uint8_t*)0x2000049b = 0xaa);
    NONFAILING(*(uint8_t*)0x2000049c = 0xaa);
    NONFAILING(*(uint8_t*)0x2000049d = 0xaa);
    NONFAILING(*(uint8_t*)0x2000049e = 0xaa);
    NONFAILING(*(uint8_t*)0x2000049f = 0xbb);
    NONFAILING(*(uint8_t*)0x200004a0 = 0);
    NONFAILING(*(uint8_t*)0x200004a1 = 0);
    NONFAILING(*(uint8_t*)0x200004a2 = 0);
    NONFAILING(*(uint8_t*)0x200004a3 = 0);
    NONFAILING(*(uint8_t*)0x200004a4 = 0);
    NONFAILING(*(uint8_t*)0x200004a5 = 0);
    NONFAILING(*(uint8_t*)0x200004a6 = 1);
    NONFAILING(*(uint8_t*)0x200004a7 = 0x80);
    NONFAILING(*(uint8_t*)0x200004a8 = 0xc2);
    NONFAILING(*(uint8_t*)0x200004a9 = 0);
    NONFAILING(*(uint8_t*)0x200004aa = 0);
    NONFAILING(*(uint8_t*)0x200004ab = 0);
    NONFAILING(*(uint8_t*)0x200004ac = 0);
    NONFAILING(*(uint8_t*)0x200004ad = 0);
    NONFAILING(*(uint8_t*)0x200004ae = 0);
    NONFAILING(*(uint8_t*)0x200004af = 0);
    NONFAILING(*(uint8_t*)0x200004b0 = 0);
    NONFAILING(*(uint8_t*)0x200004b1 = 0);
    NONFAILING(*(uint32_t*)0x200004b4 = 0xb8);
    NONFAILING(*(uint32_t*)0x200004b8 = 0xb8);
    NONFAILING(*(uint32_t*)0x200004bc = 0xe8);
    NONFAILING(
        memcpy((void*)0x200004c0,
               "ip\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
               "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000",
               32));
    NONFAILING(*(uint32_t*)0x200004e0 = 0x20);
    NONFAILING(*(uint32_t*)0x200004e8 = htobe32(0x7f000001));
    NONFAILING(*(uint8_t*)0x200004ec = 0xac);
    NONFAILING(*(uint8_t*)0x200004ed = 0x14);
    NONFAILING(*(uint8_t*)0x200004ee = 0x14);
    NONFAILING(*(uint8_t*)0x200004ef = 0);
    NONFAILING(*(uint32_t*)0x200004f0 = htobe32(0));
    NONFAILING(*(uint32_t*)0x200004f4 = htobe32(0));
    NONFAILING(*(uint8_t*)0x200004f8 = 0);
    NONFAILING(*(uint8_t*)0x200004f9 = 0x84);
    NONFAILING(*(uint8_t*)0x200004fa = 0x10);
    NONFAILING(*(uint8_t*)0x200004fb = 0);
    NONFAILING(*(uint16_t*)0x200004fc = htobe16(0));
    NONFAILING(*(uint16_t*)0x200004fe = htobe16(0));
    NONFAILING(*(uint16_t*)0x20000500 = htobe16(0));
    NONFAILING(*(uint16_t*)0x20000502 = htobe16(0));
    NONFAILING(
        memcpy((void*)0x20000508,
               "AUDIT\000\000\000\000\000\000\000\000\000\000\000\000\000\000"
               "\000\000\000\000\000\000\000\000\000\000\000\000\000",
               32));
    NONFAILING(*(uint32_t*)0x20000528 = 8);
    NONFAILING(*(uint8_t*)0x20000530 = 0);
    syscall(__NR_setsockopt, r[11], 0, 0x80, 0x200000c0, 0x1f0);
    break;
  case 43:
    syscall(__NR_ioctl, -1, 0x894a, 0);
    break;
  case 44:
    res = syscall(__NR_socket, 0x10, 3, 0);
    if (res != -1)
      r[12] = res;
    break;
  case 45:
    NONFAILING(memcpy((void*)0x20000080,
                      "ip_vti0:\237\002\000\000\000\000\000\000", 16));
    NONFAILING(*(uint16_t*)0x20000090 = 0);
    syscall(__NR_ioctl, r[12], 0x894a, 0x20000080);
    break;
  case 46:
    NONFAILING(memcpy((void*)0x20000100,
                      "\x0a\xdc\x1f\x12\x3c\x12\x3f\x31\x88\xb0\x70", 11));
    syscall(__NR_ioctl, -1, 0x2000001000008912, 0x20000100);
    break;
  case 47:
    res = syscall(__NR_socket, 0xa, 1, 0);
    if (res != -1)
      r[13] = res;
    break;
  case 48:
    syscall(__NR_bind, r[13], 0, 0);
    break;
  case 49:
    syz_emit_ethernet(0, 0, 0);
    break;
  case 50:
    NONFAILING(*(uint8_t*)0x20000100 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000101 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000102 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000103 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000104 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000105 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000106 = 1);
    NONFAILING(*(uint8_t*)0x20000107 = 0x80);
    NONFAILING(*(uint8_t*)0x20000108 = 0xc2);
    NONFAILING(*(uint8_t*)0x20000109 = 0);
    NONFAILING(*(uint8_t*)0x2000010a = 0);
    NONFAILING(*(uint8_t*)0x2000010b = 0);
    NONFAILING(*(uint16_t*)0x2000010c = htobe16(0x86dd));
    NONFAILING(STORE_BY_BITMASK(uint8_t, , 0x2000010e, 0, 0, 4));
    NONFAILING(STORE_BY_BITMASK(uint8_t, , 0x2000010e, 6, 4, 4));
    NONFAILING(memcpy((void*)0x2000010f, "\xd8\x65\x2b", 3));
    NONFAILING(*(uint16_t*)0x20000112 = htobe16(0x14));
    NONFAILING(*(uint8_t*)0x20000114 = 6);
    NONFAILING(*(uint8_t*)0x20000115 = 0);
    NONFAILING(*(uint8_t*)0x20000116 = 0xfe);
    NONFAILING(*(uint8_t*)0x20000117 = 0x80);
    NONFAILING(*(uint8_t*)0x20000118 = 0);
    NONFAILING(*(uint8_t*)0x20000119 = 0);
    NONFAILING(*(uint8_t*)0x2000011a = 0);
    NONFAILING(*(uint8_t*)0x2000011b = 0);
    NONFAILING(*(uint8_t*)0x2000011c = 0);
    NONFAILING(*(uint8_t*)0x2000011d = 0);
    NONFAILING(*(uint8_t*)0x2000011e = 0);
    NONFAILING(*(uint8_t*)0x2000011f = 0);
    NONFAILING(*(uint8_t*)0x20000120 = 0xd);
    NONFAILING(*(uint8_t*)0x20000121 = 0);
    NONFAILING(*(uint8_t*)0x20000122 = 0);
    NONFAILING(*(uint8_t*)0x20000123 = 0);
    NONFAILING(*(uint8_t*)0x20000124 = 0);
    NONFAILING(*(uint8_t*)0x20000125 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000126 = 0xfe);
    NONFAILING(*(uint8_t*)0x20000127 = 0x80);
    NONFAILING(*(uint8_t*)0x20000128 = 0);
    NONFAILING(*(uint8_t*)0x20000129 = 0);
    NONFAILING(*(uint8_t*)0x2000012a = 0);
    NONFAILING(*(uint8_t*)0x2000012b = 0);
    NONFAILING(*(uint8_t*)0x2000012c = 0);
    NONFAILING(*(uint8_t*)0x2000012d = 0);
    NONFAILING(*(uint8_t*)0x2000012e = 0);
    NONFAILING(*(uint8_t*)0x2000012f = 0);
    NONFAILING(*(uint8_t*)0x20000130 = 0);
    NONFAILING(*(uint8_t*)0x20000131 = 0);
    NONFAILING(*(uint8_t*)0x20000132 = 0);
    NONFAILING(*(uint8_t*)0x20000133 = 0);
    NONFAILING(*(uint8_t*)0x20000134 = 0);
    NONFAILING(*(uint8_t*)0x20000135 = 0xaa);
    NONFAILING(*(uint16_t*)0x20000136 = htobe16(0));
    NONFAILING(*(uint16_t*)0x20000138 = htobe16(0x4e20));
    NONFAILING(*(uint32_t*)0x2000013a = 0x41424344);
    NONFAILING(*(uint32_t*)0x2000013e = 0x41424344);
    NONFAILING(STORE_BY_BITMASK(uint8_t, , 0x20000142, 0, 0, 1));
    NONFAILING(STORE_BY_BITMASK(uint8_t, , 0x20000142, 0, 1, 3));
    NONFAILING(STORE_BY_BITMASK(uint8_t, , 0x20000142, 5, 4, 4));
    NONFAILING(*(uint8_t*)0x20000143 = 2);
    NONFAILING(*(uint16_t*)0x20000144 = htobe16(0));
    NONFAILING(*(uint16_t*)0x20000146 = htobe16(0));
    NONFAILING(*(uint16_t*)0x20000148 = htobe16(0));
    struct csum_inet csum_1;
    csum_inet_init(&csum_1);
    NONFAILING(csum_inet_update(&csum_1, (const uint8_t*)0x20000116, 16));
    NONFAILING(csum_inet_update(&csum_1, (const uint8_t*)0x20000126, 16));
    uint32_t csum_1_chunk_2 = 0x14000000;
    csum_inet_update(&csum_1, (const uint8_t*)&csum_1_chunk_2, 4);
    uint32_t csum_1_chunk_3 = 0x6000000;
    csum_inet_update(&csum_1, (const uint8_t*)&csum_1_chunk_3, 4);
    NONFAILING(csum_inet_update(&csum_1, (const uint8_t*)0x20000136, 20));
    NONFAILING(*(uint16_t*)0x20000146 = csum_inet_digest(&csum_1));
    syz_emit_ethernet(0x4a, 0x20000100, 0);
    break;
  case 51:
    res = syscall(__NR_socket, 2, 2, 0x88);
    if (res != -1)
      r[14] = res;
    break;
  case 52:
    NONFAILING(memcpy((void*)0x20000100,
                      "\x0a\xdc\x1f\x12\x3c\x12\x3f\x31\x88\xb0\x70", 11));
    syscall(__NR_ioctl, r[14], 0x2000001000008912, 0x20000100);
    break;
  case 53:
    res = syscall(__NR_socket, 0xa, 1, 0);
    if (res != -1)
      r[15] = res;
    break;
  case 54:
    NONFAILING(*(uint16_t*)0x20000080 = 0xa);
    NONFAILING(*(uint16_t*)0x20000082 = htobe16(0x4e20));
    NONFAILING(*(uint32_t*)0x20000084 = htobe32(0));
    NONFAILING(memcpy(
        (void*)0x20000088,
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000",
        16));
    NONFAILING(*(uint32_t*)0x20000098 = 0);
    syscall(__NR_bind, r[15], 0x20000080, 0x1b);
    break;
  case 55:
    NONFAILING(*(uint8_t*)0x20000100 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000101 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000102 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000103 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000104 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000105 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000106 = 1);
    NONFAILING(*(uint8_t*)0x20000107 = 0x80);
    NONFAILING(*(uint8_t*)0x20000108 = 0xc2);
    NONFAILING(*(uint8_t*)0x20000109 = 0);
    NONFAILING(*(uint8_t*)0x2000010a = 0);
    NONFAILING(*(uint8_t*)0x2000010b = 0);
    NONFAILING(*(uint16_t*)0x2000010c = htobe16(0x86dd));
    NONFAILING(STORE_BY_BITMASK(uint8_t, , 0x2000010e, 0, 0, 4));
    NONFAILING(STORE_BY_BITMASK(uint8_t, , 0x2000010e, 6, 4, 4));
    NONFAILING(memcpy((void*)0x2000010f, "\xd8\x65\x2b", 3));
    NONFAILING(*(uint16_t*)0x20000112 = htobe16(0x14));
    NONFAILING(*(uint8_t*)0x20000114 = 6);
    NONFAILING(*(uint8_t*)0x20000115 = 0);
    NONFAILING(*(uint8_t*)0x20000116 = 0xfe);
    NONFAILING(*(uint8_t*)0x20000117 = 0x80);
    NONFAILING(*(uint8_t*)0x20000118 = 0);
    NONFAILING(*(uint8_t*)0x20000119 = 0);
    NONFAILING(*(uint8_t*)0x2000011a = 0);
    NONFAILING(*(uint8_t*)0x2000011b = 0);
    NONFAILING(*(uint8_t*)0x2000011c = 0);
    NONFAILING(*(uint8_t*)0x2000011d = 0);
    NONFAILING(*(uint8_t*)0x2000011e = 0);
    NONFAILING(*(uint8_t*)0x2000011f = 0);
    NONFAILING(*(uint8_t*)0x20000120 = 0xd);
    NONFAILING(*(uint8_t*)0x20000121 = 0);
    NONFAILING(*(uint8_t*)0x20000122 = 0);
    NONFAILING(*(uint8_t*)0x20000123 = 0);
    NONFAILING(*(uint8_t*)0x20000124 = 0);
    NONFAILING(*(uint8_t*)0x20000125 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000126 = 0xfe);
    NONFAILING(*(uint8_t*)0x20000127 = 0x80);
    NONFAILING(*(uint8_t*)0x20000128 = 0);
    NONFAILING(*(uint8_t*)0x20000129 = 0);
    NONFAILING(*(uint8_t*)0x2000012a = 0);
    NONFAILING(*(uint8_t*)0x2000012b = 0);
    NONFAILING(*(uint8_t*)0x2000012c = 0);
    NONFAILING(*(uint8_t*)0x2000012d = 0);
    NONFAILING(*(uint8_t*)0x2000012e = 0);
    NONFAILING(*(uint8_t*)0x2000012f = 0);
    NONFAILING(*(uint8_t*)0x20000130 = 0);
    NONFAILING(*(uint8_t*)0x20000131 = 0);
    NONFAILING(*(uint8_t*)0x20000132 = 0);
    NONFAILING(*(uint8_t*)0x20000133 = 0);
    NONFAILING(*(uint8_t*)0x20000134 = 0);
    NONFAILING(*(uint8_t*)0x20000135 = 0xaa);
    NONFAILING(*(uint16_t*)0x20000136 = htobe16(0));
    NONFAILING(*(uint16_t*)0x20000138 = htobe16(0x4e20));
    NONFAILING(*(uint32_t*)0x2000013a = 0x41424344);
    NONFAILING(*(uint32_t*)0x2000013e = 0x41424344);
    NONFAILING(STORE_BY_BITMASK(uint8_t, , 0x20000142, 0, 0, 1));
    NONFAILING(STORE_BY_BITMASK(uint8_t, , 0x20000142, 0, 1, 3));
    NONFAILING(STORE_BY_BITMASK(uint8_t, , 0x20000142, 5, 4, 4));
    NONFAILING(*(uint8_t*)0x20000143 = 2);
    NONFAILING(*(uint16_t*)0x20000144 = htobe16(0));
    NONFAILING(*(uint16_t*)0x20000146 = htobe16(0));
    NONFAILING(*(uint16_t*)0x20000148 = htobe16(0));
    struct csum_inet csum_2;
    csum_inet_init(&csum_2);
    NONFAILING(csum_inet_update(&csum_2, (const uint8_t*)0x20000116, 16));
    NONFAILING(csum_inet_update(&csum_2, (const uint8_t*)0x20000126, 16));
    uint32_t csum_2_chunk_2 = 0x14000000;
    csum_inet_update(&csum_2, (const uint8_t*)&csum_2_chunk_2, 4);
    uint32_t csum_2_chunk_3 = 0x6000000;
    csum_inet_update(&csum_2, (const uint8_t*)&csum_2_chunk_3, 4);
    NONFAILING(csum_inet_update(&csum_2, (const uint8_t*)0x20000136, 20));
    NONFAILING(*(uint16_t*)0x20000146 = csum_inet_digest(&csum_2));
    syz_emit_ethernet(0x4a, 0x20000100, 0);
    break;
  case 56:
    NONFAILING(memcpy((void*)0x20000100,
                      "\x0a\xdc\x1f\x12\x3c\x12\x3f\x31\x88\xb0\x70", 11));
    syscall(__NR_ioctl, -1, 0x2000001000008912, 0x20000100);
    break;
  case 57:
    res = syscall(__NR_socket, 0xa, 1, 0);
    if (res != -1)
      r[16] = res;
    break;
  case 58:
    syscall(__NR_listen, r[16], 6);
    break;
  case 59:
    NONFAILING(*(uint8_t*)0x20000100 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000101 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000102 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000103 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000104 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000105 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000106 = 1);
    NONFAILING(*(uint8_t*)0x20000107 = 0x80);
    NONFAILING(*(uint8_t*)0x20000108 = 0xc2);
    NONFAILING(*(uint8_t*)0x20000109 = 0);
    NONFAILING(*(uint8_t*)0x2000010a = 0);
    NONFAILING(*(uint8_t*)0x2000010b = 0);
    NONFAILING(*(uint16_t*)0x2000010c = htobe16(0x86dd));
    NONFAILING(STORE_BY_BITMASK(uint8_t, , 0x2000010e, 0, 0, 4));
    NONFAILING(STORE_BY_BITMASK(uint8_t, , 0x2000010e, 6, 4, 4));
    NONFAILING(memcpy((void*)0x2000010f, "\xd8\x65\x2b", 3));
    NONFAILING(*(uint16_t*)0x20000112 = htobe16(0x14));
    NONFAILING(*(uint8_t*)0x20000114 = 6);
    NONFAILING(*(uint8_t*)0x20000115 = 0);
    NONFAILING(*(uint8_t*)0x20000116 = 0xfe);
    NONFAILING(*(uint8_t*)0x20000117 = 0x80);
    NONFAILING(*(uint8_t*)0x20000118 = 0);
    NONFAILING(*(uint8_t*)0x20000119 = 0);
    NONFAILING(*(uint8_t*)0x2000011a = 0);
    NONFAILING(*(uint8_t*)0x2000011b = 0);
    NONFAILING(*(uint8_t*)0x2000011c = 0);
    NONFAILING(*(uint8_t*)0x2000011d = 0);
    NONFAILING(*(uint8_t*)0x2000011e = 0);
    NONFAILING(*(uint8_t*)0x2000011f = 0);
    NONFAILING(*(uint8_t*)0x20000120 = 0xd);
    NONFAILING(*(uint8_t*)0x20000121 = 0);
    NONFAILING(*(uint8_t*)0x20000122 = 0);
    NONFAILING(*(uint8_t*)0x20000123 = 0);
    NONFAILING(*(uint8_t*)0x20000124 = 0);
    NONFAILING(*(uint8_t*)0x20000125 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000126 = 0xfe);
    NONFAILING(*(uint8_t*)0x20000127 = 0x80);
    NONFAILING(*(uint8_t*)0x20000128 = 0);
    NONFAILING(*(uint8_t*)0x20000129 = 0);
    NONFAILING(*(uint8_t*)0x2000012a = 0);
    NONFAILING(*(uint8_t*)0x2000012b = 0);
    NONFAILING(*(uint8_t*)0x2000012c = 0);
    NONFAILING(*(uint8_t*)0x2000012d = 0);
    NONFAILING(*(uint8_t*)0x2000012e = 0);
    NONFAILING(*(uint8_t*)0x2000012f = 0);
    NONFAILING(*(uint8_t*)0x20000130 = 0);
    NONFAILING(*(uint8_t*)0x20000131 = 0);
    NONFAILING(*(uint8_t*)0x20000132 = 0);
    NONFAILING(*(uint8_t*)0x20000133 = 0);
    NONFAILING(*(uint8_t*)0x20000134 = 0);
    NONFAILING(*(uint8_t*)0x20000135 = 0xaa);
    NONFAILING(*(uint16_t*)0x20000136 = htobe16(0));
    NONFAILING(*(uint16_t*)0x20000138 = htobe16(0x4e20));
    NONFAILING(*(uint32_t*)0x2000013a = 0x41424344);
    NONFAILING(*(uint32_t*)0x2000013e = 0x41424344);
    NONFAILING(STORE_BY_BITMASK(uint8_t, , 0x20000142, 0, 0, 1));
    NONFAILING(STORE_BY_BITMASK(uint8_t, , 0x20000142, 0, 1, 3));
    NONFAILING(STORE_BY_BITMASK(uint8_t, , 0x20000142, 5, 4, 4));
    NONFAILING(*(uint8_t*)0x20000143 = 2);
    NONFAILING(*(uint16_t*)0x20000144 = htobe16(0));
    NONFAILING(*(uint16_t*)0x20000146 = htobe16(0));
    NONFAILING(*(uint16_t*)0x20000148 = htobe16(0));
    struct csum_inet csum_3;
    csum_inet_init(&csum_3);
    NONFAILING(csum_inet_update(&csum_3, (const uint8_t*)0x20000116, 16));
    NONFAILING(csum_inet_update(&csum_3, (const uint8_t*)0x20000126, 16));
    uint32_t csum_3_chunk_2 = 0x14000000;
    csum_inet_update(&csum_3, (const uint8_t*)&csum_3_chunk_2, 4);
    uint32_t csum_3_chunk_3 = 0x6000000;
    csum_inet_update(&csum_3, (const uint8_t*)&csum_3_chunk_3, 4);
    NONFAILING(csum_inet_update(&csum_3, (const uint8_t*)0x20000136, 20));
    NONFAILING(*(uint16_t*)0x20000146 = csum_inet_digest(&csum_3));
    syz_emit_ethernet(0x74, 0x20000100, 0);
    break;
  case 60:
    NONFAILING(*(uint8_t*)0x20000100 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000101 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000102 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000103 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000104 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000105 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000106 = 1);
    NONFAILING(*(uint8_t*)0x20000107 = 0x80);
    NONFAILING(*(uint8_t*)0x20000108 = 0xc2);
    NONFAILING(*(uint8_t*)0x20000109 = 0);
    NONFAILING(*(uint8_t*)0x2000010a = 0);
    NONFAILING(*(uint8_t*)0x2000010b = 0);
    NONFAILING(*(uint16_t*)0x2000010c = htobe16(0x86dd));
    NONFAILING(STORE_BY_BITMASK(uint8_t, , 0x2000010e, 0, 0, 4));
    NONFAILING(STORE_BY_BITMASK(uint8_t, , 0x2000010e, 6, 4, 4));
    NONFAILING(memcpy((void*)0x2000010f, "\xd8\x65\x2b", 3));
    NONFAILING(*(uint16_t*)0x20000112 = htobe16(0x14));
    NONFAILING(*(uint8_t*)0x20000114 = 6);
    NONFAILING(*(uint8_t*)0x20000115 = 0);
    NONFAILING(*(uint8_t*)0x20000116 = 0xfe);
    NONFAILING(*(uint8_t*)0x20000117 = 0x80);
    NONFAILING(*(uint8_t*)0x20000118 = 0);
    NONFAILING(*(uint8_t*)0x20000119 = 0);
    NONFAILING(*(uint8_t*)0x2000011a = 0);
    NONFAILING(*(uint8_t*)0x2000011b = 0);
    NONFAILING(*(uint8_t*)0x2000011c = 0);
    NONFAILING(*(uint8_t*)0x2000011d = 0);
    NONFAILING(*(uint8_t*)0x2000011e = 0);
    NONFAILING(*(uint8_t*)0x2000011f = 0);
    NONFAILING(*(uint8_t*)0x20000120 = 0xd);
    NONFAILING(*(uint8_t*)0x20000121 = 0);
    NONFAILING(*(uint8_t*)0x20000122 = 0);
    NONFAILING(*(uint8_t*)0x20000123 = 0);
    NONFAILING(*(uint8_t*)0x20000124 = 0);
    NONFAILING(*(uint8_t*)0x20000125 = 0xaa);
    NONFAILING(*(uint8_t*)0x20000126 = 0xfe);
    NONFAILING(*(uint8_t*)0x20000127 = 0x80);
    NONFAILING(*(uint8_t*)0x20000128 = 0);
    NONFAILING(*(uint8_t*)0x20000129 = 0);
    NONFAILING(*(uint8_t*)0x2000012a = 0);
    NONFAILING(*(uint8_t*)0x2000012b = 0);
    NONFAILING(*(uint8_t*)0x2000012c = 0);
    NONFAILING(*(uint8_t*)0x2000012d = 0);
    NONFAILING(*(uint8_t*)0x2000012e = 0);
    NONFAILING(*(uint8_t*)0x2000012f = 0);
    NONFAILING(*(uint8_t*)0x20000130 = 0);
    NONFAILING(*(uint8_t*)0x20000131 = 0);
    NONFAILING(*(uint8_t*)0x20000132 = 0);
    NONFAILING(*(uint8_t*)0x20000133 = 0);
    NONFAILING(*(uint8_t*)0x20000134 = 0);
    NONFAILING(*(uint8_t*)0x20000135 = 0xaa);
    NONFAILING(*(uint16_t*)0x20000136 = htobe16(0));
    NONFAILING(*(uint16_t*)0x20000138 = htobe16(0x4e20));
    NONFAILING(*(uint32_t*)0x2000013a = 0x41424344);
    NONFAILING(*(uint32_t*)0x2000013e = 0x41424344);
    NONFAILING(STORE_BY_BITMASK(uint8_t, , 0x20000142, 0, 0, 1));
    NONFAILING(STORE_BY_BITMASK(uint8_t, , 0x20000142, 0, 1, 3));
    NONFAILING(STORE_BY_BITMASK(uint8_t, , 0x20000142, 5, 4, 4));
    NONFAILING(*(uint8_t*)0x20000143 = 2);
    NONFAILING(*(uint16_t*)0x20000144 = htobe16(0));
    NONFAILING(*(uint16_t*)0x20000146 = htobe16(0));
    NONFAILING(*(uint16_t*)0x20000148 = htobe16(0));
    struct csum_inet csum_4;
    csum_inet_init(&csum_4);
    NONFAILING(csum_inet_update(&csum_4, (const uint8_t*)0x20000116, 16));
    NONFAILING(csum_inet_update(&csum_4, (const uint8_t*)0x20000126, 16));
    uint32_t csum_4_chunk_2 = 0x14000000;
    csum_inet_update(&csum_4, (const uint8_t*)&csum_4_chunk_2, 4);
    uint32_t csum_4_chunk_3 = 0x6000000;
    csum_inet_update(&csum_4, (const uint8_t*)&csum_4_chunk_3, 4);
    NONFAILING(csum_inet_update(&csum_4, (const uint8_t*)0x20000136, 20));
    NONFAILING(*(uint16_t*)0x20000146 = csum_inet_digest(&csum_4));
    syz_emit_ethernet(0x4a, 0x20000100, 0);
    break;
  case 61:
    res = syscall(__NR_socket, 0x10, 3, 0xc);
    if (res != -1)
      r[17] = res;
    break;
  case 62:
    syscall(__NR_sendmsg, r[17], 0, 0);
    break;
  case 63:
    res = syscall(__NR_socket, 2, 2, 0x88);
    if (res != -1)
      r[18] = res;
    break;
  case 64:
    NONFAILING(memcpy((void*)0x20000180,
                      "\x0a\xdc\x1f\x12\x3c\x12\x3f\x31\x9b\xd0\x70", 11));
    syscall(__NR_ioctl, r[18], 0x1000008912, 0x20000180);
    break;
  case 65:
    res = syscall(__NR_socket, 0x11, 3, 0x300);
    if (res != -1)
      r[19] = res;
    break;
  case 66:
    syscall(__NR_setsockopt, r[19], 0x107, 0x12, 0, 0);
    break;
  case 67:
    res = syscall(__NR_socket, 0xa, 2, 0);
    if (res != -1)
      r[20] = res;
    break;
  case 68:
    syscall(__NR_sendmmsg, r[20], 0x200092c0, 0x400000000000561, 0);
    break;
  case 69:
    res = syscall(__NR_openat, 0xffffff9c, 0, 0x26e1, 0);
    if (res != -1)
      r[21] = res;
    break;
  case 70:
    NONFAILING(memcpy((void*)0x20000000, "memory.events\000", 14));
    res = syscall(__NR_openat, 0xffffff9c, 0x20000000, 0x7a05, 0x1700);
    if (res != -1)
      r[22] = res;
    break;
  case 71:
    NONFAILING(memcpy((void*)0x20000040, "memory.events\000", 14));
    res = syscall(__NR_openat, 0xffffff9c, 0x20000040, 0x7a05, 0x1700);
    if (res != -1)
      r[23] = res;
    break;
  case 72:
    syscall(__NR_ioctl, r[21], 0x40305828, 0);
    break;
  case 73:
    NONFAILING(memcpy(
        (void*)0x20000200,
        "\x4e\xbe\xfa\x1e\x92\x3f\x1e\x01\x8b\x6e\x53\xbf\x48\x15\xb7\x8e\x1f"
        "\x2e\xf9\x21\x2b\x93\x09\x0c\x1f\xf6\xb3\x5c\x20\x8d\x50\xae\xf3\xfd"
        "\x75\x9f\x99\x5b\x53\xdd\x37\xc5\x8c\xf8\x33\x2b\x8a\x6b\x66\x57\x54"
        "\x78\xe0\x2e\xf0\x14\x5b\xf1\x22\xba\x2e\x2c\x53\xa7\xec\x45\xe3\x75"
        "\x68\x34\x75\xa6\x49\x5f\x8d\x7b\x7a\x08\x8f\x5e\x32\xdc\x26\x65\x69"
        "\x07\x43\x19\xbf\x8c\x8d\x3d\x80\x07\xcc\x92\xe2\xba\x0d\x90\x82\xc4"
        "\x1b\x63\xe3\x30\xf3\x53\xa3\xf6\x75\xa9\x8d\x2e\x74\xa0\x8e\x38\x40"
        "\x0f\x7f\x5e\xb1\x13\xa0\xe2\x5f\xd9\x01\x15\xd5\x7a\x7a\xcd\xca\xb1"
        "\x12\x8c\xf4\xf9\xc7\x19\xf3\xf2\x9d\x46\x0c\x50\x7f\x8a\x2a\x65\x94"
        "\xd2\x59\x21\x7d\x32\xea\xe9\xbe\x93\xc6\xed\x17\xa6\x7a\xe2\xe7\xe6"
        "\x89\xa3\x1f\xa8\x44\x9d\xa1\x2f\xd6\x2b\xf4\x23\xcf\xf7\x02\xb0\x9e"
        "\x6e\xe1\xff\x0e\x69\x8b\x8b\xb5\x17\x81\x9e\xb7\x12\xba\x2b\x34\xb5"
        "\x4b\x28\xb7\x9d\x93\x99\xd9\x20\xd5\xa5\x50\x7e\x8a\x85\xf3\x70\x60"
        "\xdf\xe3\x05\x1f\x06\xf8\xd7\xcc\x9b\x06\x84\x95\xee\x5d\x5f\xcc\xe8"
        "\x54\x10\xbc\xd9\xf9\x1d\x1f\x19\x83\x53\xce\x94\xb2\xe0\x33\x70\xe4"
        "\x38\x75\xc1\xa0\x35\xbb\x88\xfd\x26\xfb\xb5\xb1\x25\x2e\x20\x56\xd6"
        "\xb6\x7e\x2b\x2f\x42\x40\x51\xa4\x0a\xd9\x17\x0e\x76\xa8\x1a\x6c\xa4"
        "\xf1\x49\xff\x64\x3d\xb7\x6f\x8f\x2c\x1a\xa8\x02\x4a\x62\x79\x95\x20"
        "\x27\x48\x9b\xba\xd6\x47\x9e\x47\xea\x5b\xa9\xe4\x7d\x81\x36\xdf\x39"
        "\x86\x65\xf6\xcd\xfd\x15\xe9\x3c\xfb\xf2\xce\x11\x51\xaf\xe9\x32\x1e"
        "\xd6\x3f\xe7\x10\x0e\x70\x4b\x23\x26\x46\xfc\x1e\x0e\x93\x6b\x90\xcc"
        "\xea\xaa\x70\x22\x5c\xe7\x16\x40\xe1\x03\x16\xd2\xcc\x63\x73\x55\xed"
        "\xdb\x3c\x4e\x16\xff\x16\x35\xfa\x4e\x65\xa6\x6e\xb5\xab\x2c\xbf\x9d"
        "\x6f\x06\x3e\x05\xf0\xe4\x6f\xcc\x14\xbf\x31\xee\xdf\xb9\xf3\x3c\x21"
        "\x5f\xc1\x49\x46\xcc\x6f\x74\x93\x92\x44\x42\xe9\x39\xf7\x1a\xc4\xbd"
        "\x3e\x35\xe7\x88\x57\xf9\x62\x4c\x66\x3f\x36\x69\xa4\x7a\x71\x46\xe3"
        "\x24\x9e\xe3\xea\xaf\x68\x1f\x37\x1d\x51\x5a\xf5\xb9\x34\xf9\x25\x2c"
        "\x7a\xc2\xa1\x64\xbf\x31\x8f\xc2\xb1\x94\xee\x08\x7b\x2b\x28\xed\x5e"
        "\x46\x18\xc0\x90\x6f\xc3\xf3\x2c\x43\xa3\xb9\xe0\x8a\x2e\x0d\x50\x9f"
        "\x65\xa7\xde\x90\x9e\x8c\x3c\x53\x5f\x1d\x8c\xb9\xc2\x36\x71\x6e\x5a"
        "\xd7\x09",
        512));
    syscall(__NR_pwrite64, r[23], 0x20000200, 0x200, 0x3200);
    break;
  case 74:
    syscall(__NR_write, r[22], 0, 0);
    break;
  case 75:
    syscall(__NR_setsockopt, -1, 6, 0x15, 0, 0);
    break;
  case 76:
    syscall(__NR_setsockopt, -1, 6, 0xd, 0, 0);
    break;
  case 77:
    res = syscall(__NR_socket, 0x1e, 4, 0);
    if (res != -1)
      r[24] = res;
    break;
  case 78:
    NONFAILING(*(uint32_t*)0x20000040 = 0x80);
    NONFAILING(*(uint32_t*)0x20000044 = 0);
    NONFAILING(*(uint32_t*)0x20000048 = 3);
    NONFAILING(*(uint32_t*)0x2000004c = 0x73d);
    syscall(__NR_setsockopt, r[24], 0x10f, 0x87, 0x20000040, 0x29b);
    break;
  case 79:
    NONFAILING(memcpy((void*)0x20000080, "\xb2", 1));
    syscall(__NR_sendto, r[24], 0x20000080, 1, 0, 0, 0);
    break;
  case 80:
    res = syz_init_net_socket(0x1f, 1, 3);
    if (res != -1)
      r[25] = res;
    break;
  case 81:
    syscall(__NR_ioctl, r[25], 0x891b, 0);
    break;
  case 82:
    NONFAILING(*(uint32_t*)0x20000040 = 0x80);
    NONFAILING(*(uint32_t*)0x20000044 = 0);
    NONFAILING(*(uint32_t*)0x20000048 = 3);
    NONFAILING(*(uint32_t*)0x2000004c = 0x73d);
    syscall(__NR_setsockopt, -1, 0x10f, 0x87, 0x20000040, 0x29b);
    break;
  case 83:
    syscall(__NR_recvmmsg, -1, 0, 0, 2, 0);
    break;
  case 84:
    NONFAILING(memcpy((void*)0x20000080, "\xb2", 1));
    syscall(__NR_sendto, -1, 0x20000080, 1, 0, 0, 0);
    break;
  case 85:
    res = syz_init_net_socket(0x1f, 1, 3);
    if (res != -1)
      r[26] = res;
    break;
  case 86:
    syscall(__NR_ioctl, r[26], 0x891b, 0);
    break;
  case 87:
    syscall(__NR_bpf, 5, 0, 0);
    break;
  case 88:
    res = syscall(__NR_socket, 2, 2, 0x88);
    if (res != -1)
      r[27] = res;
    break;
  case 89:
    syscall(__NR_ioctl, r[27], 0x1000008912, 0);
    break;
  case 90:
    NONFAILING(memcpy((void*)0x20000480, "memory.events\000", 14));
    syscall(__NR_openat, 0xffffff9c, 0x20000480, 0x26e1, 0);
    break;
  case 91:
    NONFAILING(memcpy((void*)0x20000000, "memory.events\000", 14));
    res = syscall(__NR_openat, 0xffffff9c, 0x20000000, 0x7a05, 0x1700);
    if (res != -1)
      r[28] = res;
    break;
  case 92:
    syscall(__NR_write, r[28], 0x20000000, 0xfffffcbe);
    break;
  case 93:
    syscall(__NR_ioctl, -1, 0x1000008912, 0);
    break;
  case 94:
    syscall(__NR_ioctl, -1, 0x40305828, 0);
    break;
  case 95:
    syscall(__NR_write, -1, 0x20000000, 0xfffffcbe);
    break;
  case 96:
    res = syscall(__NR_socket, 0xa, 0x805, 0);
    if (res != -1)
      r[29] = res;
    break;
  case 97:
    NONFAILING(*(uint64_t*)0x20000680 = 0);
    NONFAILING(*(uint32_t*)0x20000688 = 0);
    NONFAILING(*(uint64_t*)0x20000690 = 0);
    NONFAILING(*(uint64_t*)0x20000698 = 0);
    NONFAILING(*(uint64_t*)0x200006a0 = 0);
    NONFAILING(*(uint64_t*)0x200006a8 = 0);
    NONFAILING(*(uint32_t*)0x200006b0 = 0);
    syscall(__NR_sendmsg, r[29], 0x20000680, 0);
    break;
  case 98:
    NONFAILING(*(uint64_t*)0x200005c0 = 0);
    NONFAILING(*(uint32_t*)0x200005c8 = 0);
    NONFAILING(*(uint64_t*)0x200005d0 = 0x20000540);
    NONFAILING(*(uint64_t*)0x20000540 = 0x20000200);
    NONFAILING(*(uint64_t*)0x20000548 = 0);
    NONFAILING(*(uint64_t*)0x200005d8 = 1);
    NONFAILING(*(uint64_t*)0x200005e0 = 0);
    NONFAILING(*(uint64_t*)0x200005e8 = 0);
    NONFAILING(*(uint32_t*)0x200005f0 = 0);
    syscall(__NR_sendmsg, r[29], 0x200005c0, 0);
    break;
  case 99:
    res = syscall(__NR_socket, 0xa, 0x805, 0);
    if (res != -1)
      r[30] = res;
    break;
  case 100:
    syscall(__NR_close, r[30]);
    break;
  case 101:
    NONFAILING(*(uint32_t*)0x202a0fb8 = 0x12);
    NONFAILING(*(uint32_t*)0x202a0fbc = 3);
    NONFAILING(*(uint64_t*)0x202a0fc0 = 0x20000280);
    NONFAILING(*(uint8_t*)0x20000280 = 0x85);
    NONFAILING(STORE_BY_BITMASK(uint8_t, , 0x20000281, 0, 0, 4));
    NONFAILING(STORE_BY_BITMASK(uint8_t, , 0x20000281, 0, 4, 4));
    NONFAILING(*(uint16_t*)0x20000282 = 0);
    NONFAILING(*(uint32_t*)0x20000284 = 0x2e);
    NONFAILING(*(uint8_t*)0x20000288 = 0x54);
    NONFAILING(*(uint8_t*)0x20000289 = 0);
    NONFAILING(*(uint16_t*)0x2000028a = 0);
    NONFAILING(*(uint32_t*)0x2000028c = 0);
    NONFAILING(*(uint8_t*)0x20000290 = 0x95);
    NONFAILING(*(uint8_t*)0x20000291 = 0);
    NONFAILING(*(uint16_t*)0x20000292 = 0);
    NONFAILING(*(uint32_t*)0x20000294 = 0);
    NONFAILING(*(uint64_t*)0x202a0fc8 = 0x20000140);
    NONFAILING(memcpy((void*)0x20000140, "GPL\000", 4));
    NONFAILING(*(uint32_t*)0x202a0fd0 = 1);
    NONFAILING(*(uint32_t*)0x202a0fd4 = 0);
    NONFAILING(*(uint64_t*)0x202a0fd8 = 0);
    NONFAILING(*(uint32_t*)0x202a0fe0 = 0);
    NONFAILING(*(uint32_t*)0x202a0fe4 = 0);
    NONFAILING(*(uint8_t*)0x202a0fe8 = 0);
    NONFAILING(*(uint8_t*)0x202a0fe9 = 0);
    NONFAILING(*(uint8_t*)0x202a0fea = 0);
    NONFAILING(*(uint8_t*)0x202a0feb = 0);
    NONFAILING(*(uint8_t*)0x202a0fec = 0);
    NONFAILING(*(uint8_t*)0x202a0fed = 0);
    NONFAILING(*(uint8_t*)0x202a0fee = 0);
    NONFAILING(*(uint8_t*)0x202a0fef = 0);
    NONFAILING(*(uint8_t*)0x202a0ff0 = 0);
    NONFAILING(*(uint8_t*)0x202a0ff1 = 0);
    NONFAILING(*(uint8_t*)0x202a0ff2 = 0);
    NONFAILING(*(uint8_t*)0x202a0ff3 = 0);
    NONFAILING(*(uint8_t*)0x202a0ff4 = 0);
    NONFAILING(*(uint8_t*)0x202a0ff5 = 0);
    NONFAILING(*(uint8_t*)0x202a0ff6 = 0);
    NONFAILING(*(uint8_t*)0x202a0ff7 = 0);
    NONFAILING(*(uint32_t*)0x202a0ff8 = 0);
    NONFAILING(*(uint32_t*)0x202a0ffc = 8);
    NONFAILING(*(uint32_t*)0x202a1000 = -1);
    NONFAILING(*(uint32_t*)0x202a1004 = 8);
    NONFAILING(*(uint64_t*)0x202a1008 = 0x20000000);
    NONFAILING(*(uint32_t*)0x20000000 = 0);
    NONFAILING(*(uint32_t*)0x20000004 = 0);
    NONFAILING(*(uint32_t*)0x202a1010 = 8);
    NONFAILING(*(uint32_t*)0x202a1014 = 0x10);
    NONFAILING(*(uint64_t*)0x202a1018 = 0x20000000);
    NONFAILING(*(uint32_t*)0x20000000 = 0);
    NONFAILING(*(uint32_t*)0x20000004 = 0);
    NONFAILING(*(uint32_t*)0x20000008 = 0);
    NONFAILING(*(uint32_t*)0x2000000c = 0);
    NONFAILING(*(uint32_t*)0x202a1020 = 0x10);
    syscall(__NR_bpf, 5, 0x202a0fb8, 0x70);
    break;
  case 102:
    NONFAILING(*(uint64_t*)0x20000680 = 0x20000000);
    NONFAILING(*(uint16_t*)0x20000000 = 0xa);
    NONFAILING(*(uint16_t*)0x20000002 = htobe16(0));
    NONFAILING(*(uint32_t*)0x20000004 = htobe32(0));
    NONFAILING(*(uint8_t*)0x20000008 = 0xfe);
    NONFAILING(*(uint8_t*)0x20000009 = 0x80);
    NONFAILING(*(uint8_t*)0x2000000a = 0);
    NONFAILING(*(uint8_t*)0x2000000b = 0);
    NONFAILING(*(uint8_t*)0x2000000c = 0);
    NONFAILING(*(uint8_t*)0x2000000d = 0);
    NONFAILING(*(uint8_t*)0x2000000e = 0);
    NONFAILING(*(uint8_t*)0x2000000f = 0);
    NONFAILING(*(uint8_t*)0x20000010 = 0);
    NONFAILING(*(uint8_t*)0x20000011 = 0);
    NONFAILING(*(uint8_t*)0x20000012 = 0);
    NONFAILING(*(uint8_t*)0x20000013 = 0);
    NONFAILING(*(uint8_t*)0x20000014 = 0);
    NONFAILING(*(uint8_t*)0x20000015 = 0);
    NONFAILING(*(uint8_t*)0x20000016 = 0);
    NONFAILING(*(uint8_t*)0x20000017 = 0xbb);
    NONFAILING(*(uint32_t*)0x20000018 = 3);
    NONFAILING(*(uint32_t*)0x20000688 = 0x80);
    NONFAILING(*(uint64_t*)0x20000690 = 0x200008c0);
    NONFAILING(*(uint64_t*)0x200008c0 = 0x20000800);
    NONFAILING(*(uint64_t*)0x200008c8 = 0);
    NONFAILING(*(uint64_t*)0x20000698 = 1);
    NONFAILING(*(uint64_t*)0x200006a0 = 0);
    NONFAILING(*(uint64_t*)0x200006a8 = 0);
    NONFAILING(*(uint32_t*)0x200006b0 = 0);
    syscall(__NR_sendmsg, -1, 0x20000680, 0);
    break;
  case 103:
    syscall(__NR_close, -1);
    break;
  case 104:
    NONFAILING(*(uint32_t*)0x20000000 = 3);
    NONFAILING(*(uint32_t*)0x20000004 = 0);
    NONFAILING(*(uint32_t*)0x20000008 = 0x77fffb);
    NONFAILING(*(uint32_t*)0x2000000c = 0);
    NONFAILING(*(uint32_t*)0x20000010 = 0x820005);
    NONFAILING(*(uint32_t*)0x20000014 = 0);
    NONFAILING(*(uint32_t*)0x20000018 = 0);
    NONFAILING(*(uint8_t*)0x2000001c = 0);
    NONFAILING(*(uint8_t*)0x2000001d = 0);
    NONFAILING(*(uint8_t*)0x2000001e = 0);
    NONFAILING(*(uint8_t*)0x2000001f = 0);
    NONFAILING(*(uint8_t*)0x20000020 = 0);
    NONFAILING(*(uint8_t*)0x20000021 = 0);
    NONFAILING(*(uint8_t*)0x20000022 = 0);
    NONFAILING(*(uint8_t*)0x20000023 = 0);
    NONFAILING(*(uint8_t*)0x20000024 = 0);
    NONFAILING(*(uint8_t*)0x20000025 = 0);
    NONFAILING(*(uint8_t*)0x20000026 = 0);
    NONFAILING(*(uint8_t*)0x20000027 = 0);
    NONFAILING(*(uint8_t*)0x20000028 = 0);
    NONFAILING(*(uint8_t*)0x20000029 = 0);
    NONFAILING(*(uint8_t*)0x2000002a = 0);
    NONFAILING(*(uint8_t*)0x2000002b = 0);
    NONFAILING(*(uint32_t*)0x2000002c = 0);
    NONFAILING(*(uint32_t*)0x20000030 = -1);
    NONFAILING(*(uint32_t*)0x20000034 = 0);
    NONFAILING(*(uint32_t*)0x20000038 = 0);
    res = syscall(__NR_bpf, 2, 0x20000000, 0x2c);
    if (res != -1)
      r[31] = res;
    break;
  case 105:
    syscall(__NR_ioctl, r[31], 0x400c6615, 0);
    break;
  case 106:
    res = syscall(__NR_socket, 2, 2, 0x88);
    if (res != -1)
      r[32] = res;
    break;
  case 107:
    syscall(__NR_ioctl, r[32], 0x1000008912, 0);
    break;
  case 108:
    syscall(__NR_write, -1, 0x20000000, 0xfffffcbe);
    break;
  case 109:
    res = syscall(__NR_socket, 0x11, 2, 0x300);
    if (res != -1)
      r[33] = res;
    break;
  case 110:
    NONFAILING(*(uint16_t*)0x20000000 = 0);
    NONFAILING(*(uint8_t*)0x20000002 = 0);
    NONFAILING(*(uint8_t*)0x20000003 = 0xfc);
    syscall(__NR_setsockopt, r[33], 0x107, 0x12, 0x20000000, 4);
    break;
  case 111:
    syscall(__NR_read, r[33], 0x20000100, 4);
    break;
  case 112:
    syscall(__NR_socket, 2, 2, 0x88);
    break;
  case 113:
    syscall(__NR_socket, 2, 2, 0x88);
    break;
  case 114:
    NONFAILING(*(uint16_t*)0x20000000 = 2);
    NONFAILING(*(uint16_t*)0x20000002 = htobe16(0));
    NONFAILING(*(uint8_t*)0x20000004 = 0xac);
    NONFAILING(*(uint8_t*)0x20000005 = 0x14);
    NONFAILING(*(uint8_t*)0x20000006 = 0x14);
    NONFAILING(*(uint8_t*)0x20000007 = 0xaa);
    syscall(__NR_connect, -1, 0x20000000, 0x10);
    break;
  case 115:
    syscall(__NR_setsockopt, -1, 0, 0xd, 0, 0);
    break;
  case 116:
    res = syscall(__NR_socket, 2, 2, 0x88);
    if (res != -1)
      r[34] = res;
    break;
  case 117:
    syscall(__NR_ioctl, r[34], 0x1000008912, 0x200001c0);
    break;
  case 118:
    syscall(__NR_connect, -1, 0, 0);
    break;
  case 119:
    syscall(__NR_setsockopt, -1, 0, 0x23, 0, 0);
    break;
  case 120:
    res = syscall(__NR_socket, 0x11, 2, 0x300);
    if (res != -1)
      r[35] = res;
    break;
  case 121:
    syscall(__NR_read, r[35], 0x20000100, 4);
    break;
  case 122:
    syscall(__NR_sendmsg, -1, 0, 0);
    break;
  case 123:
    res = syscall(__NR_socket, 2, 2, 0x88);
    if (res != -1)
      r[36] = res;
    break;
  case 124:
    syscall(__NR_socket, 2, 3, 0x19);
    break;
  case 125:
    NONFAILING(*(uint32_t*)0x20000000 = htobe32(0xe0000002));
    NONFAILING(*(uint32_t*)0x20000010 = htobe32(0xe0000001));
    NONFAILING(*(uint16_t*)0x20000020 = htobe16(0));
    NONFAILING(*(uint16_t*)0x20000022 = htobe16(0));
    NONFAILING(*(uint16_t*)0x20000024 = htobe16(0));
    NONFAILING(*(uint16_t*)0x20000026 = htobe16(0));
    NONFAILING(*(uint16_t*)0x20000028 = 0);
    NONFAILING(*(uint8_t*)0x2000002a = 0);
    NONFAILING(*(uint8_t*)0x2000002b = 0);
    NONFAILING(*(uint8_t*)0x2000002c = 0);
    NONFAILING(*(uint32_t*)0x20000030 = 0);
    NONFAILING(*(uint32_t*)0x20000034 = 0);
    NONFAILING(*(uint64_t*)0x20000038 = 0);
    NONFAILING(*(uint64_t*)0x20000040 = 0);
    NONFAILING(*(uint64_t*)0x20000048 = 0);
    NONFAILING(*(uint64_t*)0x20000050 = 0);
    NONFAILING(*(uint64_t*)0x20000058 = 0);
    NONFAILING(*(uint64_t*)0x20000060 = 0);
    NONFAILING(*(uint64_t*)0x20000068 = 0);
    NONFAILING(*(uint64_t*)0x20000070 = 0);
    NONFAILING(*(uint64_t*)0x20000078 = 0);
    NONFAILING(*(uint64_t*)0x20000080 = 0);
    NONFAILING(*(uint64_t*)0x20000088 = 0);
    NONFAILING(*(uint64_t*)0x20000090 = 0);
    NONFAILING(*(uint32_t*)0x20000098 = 0);
    NONFAILING(*(uint32_t*)0x2000009c = 0);
    NONFAILING(*(uint8_t*)0x200000a0 = 0);
    NONFAILING(*(uint8_t*)0x200000a1 = 0);
    NONFAILING(*(uint8_t*)0x200000a2 = 0);
    NONFAILING(*(uint8_t*)0x200000a3 = 0);
    NONFAILING(memcpy(
        (void*)0x200000a8,
        "\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000",
        16));
    NONFAILING(*(uint32_t*)0x200000b8 = htobe32(0));
    NONFAILING(*(uint8_t*)0x200000bc = 0);
    NONFAILING(*(uint16_t*)0x200000c0 = 0);
    NONFAILING(*(uint64_t*)0x200000c4 = htobe64(0));
    NONFAILING(*(uint64_t*)0x200000cc = htobe64(1));
    NONFAILING(*(uint32_t*)0x200000d4 = 0);
    NONFAILING(*(uint8_t*)0x200000d8 = 0);
    NONFAILING(*(uint8_t*)0x200000d9 = 0);
    NONFAILING(*(uint8_t*)0x200000da = 0);
    NONFAILING(*(uint32_t*)0x200000dc = 0);
    NONFAILING(*(uint32_t*)0x200000e0 = 0);
    NONFAILING(*(uint32_t*)0x200000e4 = 0);
    syscall(__NR_setsockopt, r[36], 0, 0x23, 0x20000000, 0xe8);
    break;
  case 126:
    syscall(__NR_socket, 2, 2, 0x88);
    break;
  case 127:
    res = syscall(__NR_socket, 0xa, 2, 0);
    if (res != -1)
      r[37] = res;
    break;
  case 128:
    NONFAILING(*(uint16_t*)0x200001c0 = 0xa);
    NONFAILING(*(uint16_t*)0x200001c2 = htobe16(0));
    NONFAILING(*(uint32_t*)0x200001c4 = htobe32(0));
    NONFAILING(*(uint8_t*)0x200001c8 = 0xfe);
    NONFAILING(*(uint8_t*)0x200001c9 = 0x80);
    NONFAILING(*(uint8_t*)0x200001ca = 0);
    NONFAILING(*(uint8_t*)0x200001cb = 0);
    NONFAILING(*(uint8_t*)0x200001cc = 0);
    NONFAILING(*(uint8_t*)0x200001cd = 0);
    NONFAILING(*(uint8_t*)0x200001ce = 0);
    NONFAILING(*(uint8_t*)0x200001cf = 0);
    NONFAILING(*(uint8_t*)0x200001d0 = 0);
    NONFAILING(*(uint8_t*)0x200001d1 = 0);
    NONFAILING(*(uint8_t*)0x200001d2 = 0);
    NONFAILING(*(uint8_t*)0x200001d3 = 0);
    NONFAILING(*(uint8_t*)0x200001d4 = 0);
    NONFAILING(*(uint8_t*)0x200001d5 = 0);
    NONFAILING(*(uint8_t*)0x200001d6 = 0);
    NONFAILING(*(uint8_t*)0x200001d7 = 0);
    NONFAILING(*(uint32_t*)0x200001d8 = 4);
    syscall(__NR_connect, r[37], 0x200001c0, 0x1c);
    break;
  case 129:
    res = syscall(__NR_socket, 0x18, 1, 1);
    if (res != -1)
      r[38] = res;
    break;
  case 130:
    NONFAILING(*(uint64_t*)0x20006440 = 0);
    NONFAILING(*(uint32_t*)0x20006448 = 0);
    NONFAILING(*(uint64_t*)0x20006450 = 0x200062c0);
    NONFAILING(*(uint64_t*)0x200062c0 = 0);
    NONFAILING(*(uint64_t*)0x200062c8 = 0);
    NONFAILING(*(uint64_t*)0x200062d0 = 0x20005e40);
    NONFAILING(*(uint64_t*)0x200062d8 = 0x3e);
    NONFAILING(*(uint64_t*)0x200062e0 = 0);
    NONFAILING(*(uint64_t*)0x200062e8 = 0);
    NONFAILING(*(uint64_t*)0x200062f0 = 0);
    NONFAILING(*(uint64_t*)0x200062f8 = 0);
    NONFAILING(*(uint64_t*)0x20006300 = 0x20005f80);
    NONFAILING(*(uint64_t*)0x20006308 = 0x9f);
    NONFAILING(*(uint64_t*)0x20006310 = 0x20006040);
    NONFAILING(*(uint64_t*)0x20006318 = 0x91);
    NONFAILING(*(uint64_t*)0x20006320 = 0);
    NONFAILING(*(uint64_t*)0x20006328 = 0);
    NONFAILING(*(uint64_t*)0x20006330 = 0);
    NONFAILING(*(uint64_t*)0x20006338 = 0);
    NONFAILING(*(uint64_t*)0x20006458 = 8);
    NONFAILING(*(uint64_t*)0x20006460 = 0x20006340);
    NONFAILING(*(uint64_t*)0x20006468 = 0xff);
    NONFAILING(*(uint32_t*)0x20006470 = 0);
    syscall(__NR_recvmsg, -1, 0x20006440, 0);
    break;
  case 131:
    syscall(__NR_connect, r[38], 0, 0);
    break;
  case 132:
    syscall(__NR_sendmmsg, r[38], 0, 0, 0);
    break;
  case 133:
    NONFAILING(*(uint16_t*)0x20000080 = 0);
    NONFAILING(*(uint16_t*)0x20000082 = 0);
    NONFAILING(*(uint64_t*)0x20000088 = 0);
    NONFAILING(*(uint64_t*)0x20000090 = 0x7fffffff);
    NONFAILING(*(uint32_t*)0x20000098 = 0);
    NONFAILING(*(uint32_t*)0x2000009c = 0);
    NONFAILING(*(uint32_t*)0x200000a0 = 0);
    NONFAILING(*(uint32_t*)0x200000a4 = 0);
    NONFAILING(*(uint32_t*)0x200000a8 = 0);
    NONFAILING(*(uint32_t*)0x200000ac = 0);
    syscall(__NR_ioctl, -1, 0x40305828, 0x20000080);
    break;
  case 134:
    syscall(__NR_pwrite64, -1, 0, 0, 0);
    break;
  case 135:
    syscall(__NR_ioctl, -1, 0x40086602, 0);
    break;
  case 136:
    syscall(__NR_ioctl, -1, 0, 0);
    break;
  case 137:
    syscall(__NR_socket, 0x10, 0x100000803, 0);
    break;
  case 138:
    NONFAILING(memcpy((void*)0x20000180, "memory.events\000", 14));
    res = syscall(__NR_openat, 0xffffff9c, 0x20000180, 0x26e1, 0);
    if (res != -1)
      r[39] = res;
    break;
  case 139:
    NONFAILING(*(uint16_t*)0x200000c0 = 0);
    NONFAILING(*(uint16_t*)0x200000c2 = 0);
    NONFAILING(*(uint64_t*)0x200000c8 = 0);
    NONFAILING(*(uint64_t*)0x200000d0 = 0x20000fff);
    NONFAILING(*(uint32_t*)0x200000d8 = 0x45020000);
    NONFAILING(*(uint32_t*)0x200000dc = 0);
    NONFAILING(*(uint32_t*)0x200000e0 = 0);
    NONFAILING(*(uint32_t*)0x200000e4 = 0);
    NONFAILING(*(uint32_t*)0x200000e8 = 0);
    NONFAILING(*(uint32_t*)0x200000ec = 0);
    syscall(__NR_ioctl, r[39], 0x40305828, 0x200000c0);
    break;
  case 140:
    syscall(__NR_setsockopt, r[39], 0x84, 0x1e, 0, 0);
    break;
  case 141:
    syscall(__NR_sendmsg, r[39], 0, 0x8000);
    break;
  case 142:
    res = syscall(__NR_socket, 2, 2, 0x88);
    if (res != -1)
      r[40] = res;
    break;
  case 143:
    syscall(__NR_ioctl, r[40], 0x1000008912, 0x20000000);
    break;
  case 144:
    syscall(__NR_mmap, 0x20000000, 0xb36000, 3, 0x8031, -1, 0);
    break;
  case 145:
    res = syscall(__NR_socket, 0x10, 3, 0);
    if (res != -1)
      r[41] = res;
    break;
  case 146:
    NONFAILING(memcpy((void*)0x20000080,
                      "ip_vti0\000\000\000\000\000\000\000\000\000", 16));
    NONFAILING(*(uint64_t*)0x20000090 = 0);
    syscall(__NR_ioctl, r[41], 0x89f0, 0x20000080);
    break;
  case 147:
    NONFAILING(*(uint32_t*)0x20000000 = -1);
    NONFAILING(*(uint16_t*)0x20000004 = 0);
    NONFAILING(*(uint16_t*)0x20000006 = 0);
    NONFAILING(*(uint32_t*)0x20000008 = -1);
    NONFAILING(*(uint16_t*)0x2000000c = 0);
    NONFAILING(*(uint16_t*)0x2000000e = 0);
    NONFAILING(*(uint32_t*)0x20000010 = -1);
    NONFAILING(*(uint16_t*)0x20000014 = 3);
    NONFAILING(*(uint16_t*)0x20000016 = 0);
    syscall(__NR_poll, 0x20000000, 0x2266, 0);
    break;
  case 148:
    res = syscall(__NR_socket, 0x26, 5, 0);
    if (res != -1)
      r[42] = res;
    break;
  case 149:
    syscall(__NR_bind, r[42], 0, 0);
    break;
  case 150:
    syscall(__NR_setsockopt, r[42], 0x117, 1, 0x20000200, 0);
    break;
  case 151:
    syscall(__NR_write, -1, 0, 0);
    break;
  case 152:
    NONFAILING(*(uint64_t*)0x20004ec0 = 0);
    NONFAILING(*(uint32_t*)0x20004ec8 = 0);
    NONFAILING(*(uint64_t*)0x20004ed0 = 0);
    NONFAILING(*(uint64_t*)0x20004ed8 = 0);
    NONFAILING(*(uint64_t*)0x20004ee0 = 0);
    NONFAILING(*(uint64_t*)0x20004ee8 = 0);
    NONFAILING(*(uint32_t*)0x20004ef0 = 0);
    NONFAILING(*(uint32_t*)0x20004ef8 = 0);
    syscall(__NR_recvmmsg, -1, 0x20004ec0, 1, 0, 0);
    break;
  case 153:
    NONFAILING(memcpy(
        (void*)0x20000540,
        "hqgetl\024\000\000\000\t\000\000\000age_ir?\000\000\000es\000p\200#"
        "\276\304\345\005\253\315\177\323so2\313\205o\325\021\376.\266\371\362;"
        "\320\276\246\351\271\244Aa\276\373\234\377\361",
        65));
    res = syscall(__NR_openat, 0xffffff9c, 0x20000540, 0x275a, 0);
    if (res != -1)
      r[43] = res;
    break;
  case 154:
    NONFAILING(*(uint16_t*)0x20000080 = 0);
    NONFAILING(*(uint16_t*)0x20000082 = 0);
    NONFAILING(*(uint64_t*)0x20000088 = 0);
    NONFAILING(*(uint64_t*)0x20000090 = 0x7fffffff);
    NONFAILING(*(uint32_t*)0x20000098 = 0);
    NONFAILING(*(uint32_t*)0x2000009c = 0);
    NONFAILING(*(uint32_t*)0x200000a0 = 0);
    NONFAILING(*(uint32_t*)0x200000a4 = 0);
    NONFAILING(*(uint32_t*)0x200000a8 = 0);
    NONFAILING(*(uint32_t*)0x200000ac = 0);
    syscall(__NR_ioctl, r[43], 0x40305828, 0x20000080);
    break;
  case 155:
    syscall(__NR_pwrite64, -1, 0, 0, 0);
    break;
  case 156:
    syscall(__NR_ioctl, r[43], 0x40086602, 0);
    break;
  case 157:
    syscall(__NR_ioctl, -1, 0, 0);
    break;
  case 158:
    syscall(__NR_socket, 0x10, 0x100000803, 0);
    break;
  case 159:
    NONFAILING(*(uint32_t*)0x20000400 = 0);
    syscall(__NR_setsockopt, -1, 0x84, 0x1e, 0x20000400, 4);
    break;
  case 160:
    syscall(__NR_sendmsg, -1, 0, 0x8000);
    break;
  case 161:
    NONFAILING(*(uint32_t*)0x20000240 = -1);
    NONFAILING(*(uint32_t*)0x20000244 = 0);
    NONFAILING(*(uint64_t*)0x20000248 = 0);
    syscall(__NR_bpf, 0xf, 0x20000240, 0x10);
    break;
  case 162:
    syscall(__NR_ioctl, -1, 4, 0x20000440);
    break;
  }
}
int main(void)
{
  syscall(__NR_mmap, 0x20000000, 0x1000000, 3, 0x32, -1, 0);
  install_segv_handler();
  for (procid = 0; procid < 6; procid++) {
    if (fork() == 0) {
      use_temporary_dir();
      do_sandbox_none();
    }
  }
  sleep(1000000);
  return 0;
}
