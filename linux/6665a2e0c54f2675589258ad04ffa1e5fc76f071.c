// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <pthread.h>
#include <setjmp.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <time.h>
#include <unistd.h>

#include <linux/futex.h>
#include <linux/loop.h>

unsigned long long procid;

static __thread int skip_segv;
static __thread jmp_buf segv_env;

static void segv_handler(int sig, siginfo_t* info, void* ctx)
{
  uintptr_t addr = (uintptr_t)info->si_addr;
  const uintptr_t prog_start = 1 << 20;
  const uintptr_t prog_end = 100 << 20;
  if (__atomic_load_n(&skip_segv, __ATOMIC_RELAXED) &&
      (addr < prog_start || addr > prog_end)) {
    _longjmp(segv_env, 1);
  }
  exit(sig);
}

static void install_segv_handler(void)
{
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  syscall(SYS_rt_sigaction, 0x20, &sa, NULL, 8);
  syscall(SYS_rt_sigaction, 0x21, &sa, NULL, 8);
  memset(&sa, 0, sizeof(sa));
  sa.sa_sigaction = segv_handler;
  sa.sa_flags = SA_NODEFER | SA_SIGINFO;
  sigaction(SIGSEGV, &sa, NULL);
  sigaction(SIGBUS, &sa, NULL);
}

#define NONFAILING(...)                                                        \
  {                                                                            \
    __atomic_fetch_add(&skip_segv, 1, __ATOMIC_SEQ_CST);                       \
    if (_setjmp(segv_env) == 0) {                                              \
      __VA_ARGS__;                                                             \
    }                                                                          \
    __atomic_fetch_sub(&skip_segv, 1, __ATOMIC_SEQ_CST);                       \
  }

static void sleep_ms(uint64_t ms)
{
  usleep(ms * 1000);
}

static uint64_t current_time_ms(void)
{
  struct timespec ts;
  if (clock_gettime(CLOCK_MONOTONIC, &ts))
    exit(1);
  return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}

static void thread_start(void* (*fn)(void*), void* arg)
{
  pthread_t th;
  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 128 << 10);
  int i;
  for (i = 0; i < 100; i++) {
    if (pthread_create(&th, &attr, fn, arg) == 0) {
      pthread_attr_destroy(&attr);
      return;
    }
    if (errno == EAGAIN) {
      usleep(50);
      continue;
    }
    break;
  }
  exit(1);
}

typedef struct {
  int state;
} event_t;

static void event_init(event_t* ev)
{
  ev->state = 0;
}

static void event_reset(event_t* ev)
{
  ev->state = 0;
}

static void event_set(event_t* ev)
{
  if (ev->state)
    exit(1);
  __atomic_store_n(&ev->state, 1, __ATOMIC_RELEASE);
  syscall(SYS_futex, &ev->state, FUTEX_WAKE | FUTEX_PRIVATE_FLAG, 1000000);
}

static void event_wait(event_t* ev)
{
  while (!__atomic_load_n(&ev->state, __ATOMIC_ACQUIRE))
    syscall(SYS_futex, &ev->state, FUTEX_WAIT | FUTEX_PRIVATE_FLAG, 0, 0);
}

static int event_isset(event_t* ev)
{
  return __atomic_load_n(&ev->state, __ATOMIC_ACQUIRE);
}

static int event_timedwait(event_t* ev, uint64_t timeout)
{
  uint64_t start = current_time_ms();
  uint64_t now = start;
  for (;;) {
    uint64_t remain = timeout - (now - start);
    struct timespec ts;
    ts.tv_sec = remain / 1000;
    ts.tv_nsec = (remain % 1000) * 1000 * 1000;
    syscall(SYS_futex, &ev->state, FUTEX_WAIT | FUTEX_PRIVATE_FLAG, 0, &ts);
    if (__atomic_load_n(&ev->state, __ATOMIC_RELAXED))
      return 1;
    now = current_time_ms();
    if (now - start > timeout)
      return 0;
  }
}

struct fs_image_segment {
  void* data;
  uintptr_t size;
  uintptr_t offset;
};

#define IMAGE_MAX_SEGMENTS 4096
#define IMAGE_MAX_SIZE (129 << 20)

#define sys_memfd_create 319

static unsigned long fs_image_segment_check(unsigned long size,
                                            unsigned long nsegs, long segments)
{
  unsigned long i;
  struct fs_image_segment* segs = (struct fs_image_segment*)segments;
  if (nsegs > IMAGE_MAX_SEGMENTS)
    nsegs = IMAGE_MAX_SEGMENTS;
  for (i = 0; i < nsegs; i++) {
    if (segs[i].size > IMAGE_MAX_SIZE)
      segs[i].size = IMAGE_MAX_SIZE;
    segs[i].offset %= IMAGE_MAX_SIZE;
    if (segs[i].offset > IMAGE_MAX_SIZE - segs[i].size)
      segs[i].offset = IMAGE_MAX_SIZE - segs[i].size;
    if (size < segs[i].offset + segs[i].offset)
      size = segs[i].offset + segs[i].offset;
  }
  if (size > IMAGE_MAX_SIZE)
    size = IMAGE_MAX_SIZE;
  return size;
}

static long syz_read_part_table(volatile unsigned long size,
                                volatile unsigned long nsegs,
                                volatile long segments)
{
  char loopname[64], linkname[64];
  int loopfd, err = 0, res = -1;
  unsigned long i, j;
  NONFAILING(size = fs_image_segment_check(size, nsegs, segments));
  int memfd = syscall(sys_memfd_create, "syz_read_part_table", 0);
  if (memfd == -1) {
    err = errno;
    goto error;
  }
  if (ftruncate(memfd, size)) {
    err = errno;
    goto error_close_memfd;
  }
  for (i = 0; i < nsegs; i++) {
    struct fs_image_segment* segs = (struct fs_image_segment*)segments;
    int res1 = 0;
    NONFAILING(res1 =
                   pwrite(memfd, segs[i].data, segs[i].size, segs[i].offset));
    if (res1 < 0) {
    }
  }
  snprintf(loopname, sizeof(loopname), "/dev/loop%llu", procid);
  loopfd = open(loopname, O_RDWR);
  if (loopfd == -1) {
    err = errno;
    goto error_close_memfd;
  }
  if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
    if (errno != EBUSY) {
      err = errno;
      goto error_close_loop;
    }
    ioctl(loopfd, LOOP_CLR_FD, 0);
    usleep(1000);
    if (ioctl(loopfd, LOOP_SET_FD, memfd)) {
      err = errno;
      goto error_close_loop;
    }
  }
  struct loop_info64 info;
  if (ioctl(loopfd, LOOP_GET_STATUS64, &info)) {
    err = errno;
    goto error_clear_loop;
  }
  info.lo_flags |= LO_FLAGS_PARTSCAN;
  if (ioctl(loopfd, LOOP_SET_STATUS64, &info)) {
    err = errno;
    goto error_clear_loop;
  }
  res = 0;
  for (i = 1, j = 0; i < 8; i++) {
    snprintf(loopname, sizeof(loopname), "/dev/loop%llup%d", procid, (int)i);
    struct stat statbuf;
    if (stat(loopname, &statbuf) == 0) {
      snprintf(linkname, sizeof(linkname), "./file%d", (int)j++);
      if (symlink(loopname, linkname)) {
      }
    }
  }
error_clear_loop:
  ioctl(loopfd, LOOP_CLR_FD, 0);
error_close_loop:
  close(loopfd);
error_close_memfd:
  close(memfd);
error:
  errno = err;
  return res;
}

struct thread_t {
  int created, call;
  event_t ready, done;
};

static struct thread_t threads[16];
static void execute_call(int call);
static int running;

static void* thr(void* arg)
{
  struct thread_t* th = (struct thread_t*)arg;
  for (;;) {
    event_wait(&th->ready);
    event_reset(&th->ready);
    execute_call(th->call);
    __atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
    event_set(&th->done);
  }
  return 0;
}

static void loop(void)
{
  int i, call, thread;
  for (call = 0; call < 3; call++) {
    for (thread = 0; thread < (int)(sizeof(threads) / sizeof(threads[0]));
         thread++) {
      struct thread_t* th = &threads[thread];
      if (!th->created) {
        th->created = 1;
        event_init(&th->ready);
        event_init(&th->done);
        event_set(&th->done);
        thread_start(thr, th);
      }
      if (!event_isset(&th->done))
        continue;
      event_reset(&th->done);
      th->call = call;
      __atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
      event_set(&th->ready);
      event_timedwait(&th->done, 45);
      break;
    }
  }
  for (i = 0; i < 100 && __atomic_load_n(&running, __ATOMIC_RELAXED); i++)
    sleep_ms(1);
}

uint64_t r[1] = {0xffffffffffffffff};

void execute_call(int call)
{
  intptr_t res;
  switch (call) {
  case 0:
    NONFAILING(memcpy((void*)0x20000040, "/dev/null\000", 10));
    res =
        syscall(__NR_openat, 0xffffffffffffff9cul, 0x20000040ul, 0x100ul, 0ul);
    if (res != -1)
      r[0] = res;
    break;
  case 1:
    NONFAILING(*(uint32_t*)0x200004c0 = 2);
    NONFAILING(*(uint32_t*)0x200004c4 = 0);
    NONFAILING(*(uint32_t*)0x200004c8 = 0x1c);
    NONFAILING(*(uint32_t*)0x200004cc = 0x15);
    NONFAILING(*(uint32_t*)0x200004d0 = 0x143);
    NONFAILING(*(uint64_t*)0x200004d8 = 0x200000c0);
    NONFAILING(memcpy(
        (void*)0x200000c0,
        "\x8b\x8e\x8e\xcd\x7b\xd8\x86\x73\x3a\x51\xd4\x51\x64\xcb\xcb\x52\x4c"
        "\x91\x77\x54\x91\xb2\xff\x4a\x50\x6b\x65\x06\x73\xd3\x2f\xf0\xbf\x1a"
        "\x36\x81\x42\x47\x59\x0a\x1f\xe5\x0c\xa1\xbd\x9e\xf8\x72\x5d\xf1\x5d"
        "\x2f\x9b\x47\x20\x14\x86\x41\xcb\xc0\xdb\x92\x29\xd8\x67\xb8\xa4\xa1"
        "\x28\x2f\xa2\x7f\x69\x13\x98\x12\xf2\x4e\x08\x63\x7b\x6a\x32\x4f\x03"
        "\x5b\x15\xde\x8f\x4a\x6a\x78\xe2\x9e\x3d\x6c\x5e\xac\x55\x1c\x0b\xb3"
        "\xc8\x4a\x6c\x63\xd0\xb7\xf7\x1d\xcf\x07\xa7\x1b\x8c\xdb\x25\x15\x14"
        "\x14\x0e\xb8\x56\x6c\x87\x5c\xf9\xf8\xd1\x4a\x4b\xdb\xf2\xb0\xd7\x22"
        "\xd3\x97\x4c\x46\xd1\x63\x28\xb6\xbd\xf8\xeb\x7a\x0a\x86\x4a\xb8\x68"
        "\xfb\x88\xbe\x41\x99\xc2\x80\xe4\x1d\xef\x97\xfb\x2c\x21\x7e\x15\x06"
        "\x3a\x20\x94\xb4\x9a\x54\xee\x32\xdb\x46\x46\xc5\xdb\x4b\x2a\xdf\x56"
        "\x15\x9c\x6c\x39\xbb\xba\x4a\x42\x34\x08\x01\x67\xea\x6c\x8d\x7f\x07"
        "\x09\x49\xe5\x1e\xa3\x4b\xba\x37\xcd\xaf\x44\x5a\xd1\xaa\x6a\x2f\xc7"
        "\x99\x2f\x36\x32\x35\x44\xe9\x75\x1f\x25\x5b\x1d\x7e\x8e\xd5\x15\xbc"
        "\x8d\x0a\x10\x16\x77\xa9\x96\xf3\x4a\xc8\xd7\xfd\xf8\xd2\x75\x7c\x84"
        "\x11\xca\x3d\x50\x9d\x48\xe9\xcb\x75\x28\x9f\xad\xdf\xc6\xcd\x60\x57"
        "\xab\xeb\x96\xae\xb1\x0d\x29\xd8\xce\x4d\x4c\xd2\x6d\xda\xb7\xf2\xa2"
        "\x85\x69\x65\xc0\xf1\x34\x20\x75\x8c\xcd\xce\xc9\xe5\x61\x68\xf6\x4e"
        "\x3b\x8d\x8e\xc7\x32\xdf\x3b\x70\x7c\x7b\xe0\x68\xaa\xc2\xcc\xa9\x72"
        "\x9e\x53\x88\xb8\x63\x9d\xac\x8d\xae\x87\x4a\xda\x70\x52\xf5\x34\xd1"
        "\xde\x34\x70\x6b\xa8\x64\x85\xfa\x49\x2b\xfa\xd5\x3a\x91\x64\x24\x6d"
        "\xe8\x54\xe8\x26\xb1\xf0\x5f\x8e\x9c\xb9\xb6\x71\x42\xf7\x18\x39\x58"
        "\x94\x7d\x17\x3f\x74\x9c\x95\x2f\x1d\xa4\xfc\x9b\x54\x8b\x8e\x7c\x85"
        "\xf1\x7d\x27\x96\x4b\xcc\xcf\xf4\xac\x6c\x0e\x92\x67\x2d\x59\x55\x84"
        "\x52\x62\xa9\xb9\xa1\x56\xc4\x2f\x10\xf0\x0a\xc9\x00\x34\xd6\x97\xa3"
        "\x19\x7f\x60\xc8\xff\x00\xc9\xae\xc2\x0d\x29\x8d\xb4\x44\xa5\x58\x56"
        "\x45\x52\x0b\x63\x6c\xf0\xc6\x05\x15\xd8\xde\x1b\xde\xf5\x32\xe3\xfc"
        "\xfe\x2e\xbd\xfc\x30\xf2\x82\x7d\x58\x2a\x4a\xf0\xc2\xa5\x0f\xc7\x3b"
        "\x6c\x45\x6e\x74\x09\xfa\x15\x0e\xaa\x60\x4f\x1d\xc5\x5d\x90\x76\x2b"
        "\x42\x71\xdb\x6d\xb9\x7d\x8f\x97\x23\xd3\xc5\x72\x73\x2d\x96\x66\x32"
        "\xf9\x2d\x74\x7a\x85\xd0\x20\x12\x9c\x9b\xe0\x32\xbc\x2c\x9a\xd0\x79"
        "\x89\x59\x04\xbe\x09\x00\xa6\x0f\x1d\x48\x22\x78\xac\x53\xd5\xf3\xcc"
        "\xde\x0a\xfd\x88\xe4\xc2\x45\x1f\x31\x02\xac\x61\x0b\x80\xf4\x4d\xa1"
        "\x97\x33\x5d\x14\x9b\x08\xb1\xcc\x74\x81\xe4\x63\x91\xe8\x42\x5e\x9d"
        "\x74\x68\x15\xb4\x24\xda\x50\xf0\xaf\xe5\x25\xdb\x11\xe1\x85\xd5\x3e"
        "\xab\xa5\x6b\xf5\xc9\xa8\x26\x50\x95\xa9\x3d\x20\x65\xfe\xe0\xc3\xb0"
        "\xa9\x65\xa8\xaa\xbd\x7c\xb5\xe9\xc6\x14\x7e\x46\x67\xb2\xe6\xf6\xd7"
        "\x6c\x33\xa4\x53\x8c\xb7\x63\x33\xbd\x8d\x78\xd1\xa7\xc3\x39\x60\x92"
        "\x62\xb4\x62\x23\xe1\x31\x3a\x8e\xa1\x7a\x96\x5a\xcb\xef\xd3\xaf\x90"
        "\x0c\x32\x49\xe7\x72\xdd\xf5\xa8\x5b\x65\x11\xaf\xba\x96\xcf\xd9\xbe"
        "\x98\xea\x75\x9b\x08\xaa\xb9\x40\x99\x43\x40\x0d\x24\x15\x13\x65\xe2"
        "\x0d\x92\x62\xff\x05\x6c\x5e\x76\x04\xde\x18\xdd\x56\xfe\xb1\x09\x28"
        "\x0d\x3d\x70\xda\x6b\x14\x0b\x53\xe0\x3a\xee\xf3\x30\xed\xae\x88\x4f"
        "\x84\x5a\x27\xb6\xce\x7a\x3e\x5d\x6f\x08\x02\x6c\xc3\x59\xf2\x55\x98"
        "\x9e\x94\xfc\x2b\x6d\xf4\x75\x1f\x94\xf5\x18\xb8\x19\x4d\x1c\xd2\x0f"
        "\xee\xc2\x55\xf8\x5d\x51\x79\xbb\xb9\xa1\xe9\xcc\xac\x93\xc1\x4a\x00"
        "\x86\xe8\x60\x50\xc0\xcc\x96\xfc\x5d\xc6\x7b\x36\x47\x59\x99\xd3\x8b"
        "\x34\xd3\x9c\x39\xc6\x0b\x67\x91\x7b\xab\xc8\x29\x82\xf5\x39\xf3\x97"
        "\x18\x99\x41\xca\x38\x28\x1d\x17\xc9\x9c\x32\x73\xfb\x3b\xb7\x27\x82"
        "\xe5\x81\xa8\x7c\x39\xf6\x26\x30\x5a\x49\x96\xa0\xf1\x9b\xf8\x59\xd5"
        "\x46\x0b\x5b\x60\x7d\xfc\xd7\x48\xc3\x24\x61\xa9\xec\xdc\x1f\xd5\x73"
        "\x86\x94\x71\xe1\x1e\x68\x55\x05\x16\x62\x0a\x94\xcb\x51\x95\x8e\x75"
        "\xbd\xd3\x3e\x76\xf8\x0a\x4f\x23\xc4\x7d\x07\x21\xcc\xd1\x17\xa6\xe7"
        "\x0b\x8d\xa8\x30\x20\x5b\x80\x48\x94\x26\x83\xc7\x0c\x35\x51\x00\x92"
        "\x72\x9e\x25\xdf\x9e\xc1\x99\xe5\x50\x6e\x24\x08\xf8\x1e\x77\x8b\x12"
        "\x2e\xb8\xc0\xf7\x6f\xbd\xb7\x65\xfa\x51\x9a\xe2\x8e\xef\x06\x3b\x81"
        "\x22\x1d\xe4\xbe\xc7\x02\x80\xf4\xd1\xfe\x67\xad\xf6\x78\xfe\x39\x16"
        "\xd2\x6d\x21\xff\xb8\xbc\xdd\xa0\x6d\x1d\x17\x70\x71\xd3\x15\xf0\x7d"
        "\xc5\xa2\x6d\x8d\x7f\x68\xaf\x60\xdf\x6f\xb6\x74\xe5\xae\x14\x45\xd4"
        "\x1c\x53\x4e\xd4\x23\xdc\x0c\xa5\x8b\xc9\x5d\x87\xbe\x25\x03\xac\xf7"
        "\xef\x62\xc4\x0c",
        1024));
    syscall(__NR_ioctl, r[0], 0x4b72ul, 0x200004c0ul);
    break;
  case 2:
    NONFAILING(*(uint64_t*)0x20000080 = 0x20000000);
    NONFAILING(memcpy(
        (void*)0x20000000,
        "\x02\x01\xa5\xff\xff\xff\x01\x00\x00\x00\xff\x07\x00\x00\x00\xff\xff"
        "\xff\xfd\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x40\x00\xff\xff\xff"
        "\x85\x00\x00\x00\x00\x00\x00\x00\x88\x77\x00\x72\x00\x30\xb5\x82\x92"
        "\x37\xc3\x00\x00\x00\x00\x00\x00\x80\x00\x00\x55\xaa",
        64));
    NONFAILING(*(uint64_t*)0x20000088 = 0x40);
    NONFAILING(*(uint64_t*)0x20000090 = 0x1c0);
    syz_read_part_table(0, 0x1bf, 0x20000080);
    break;
  }
}
int main(void)
{
  syscall(__NR_mmap, 0x20000000ul, 0x1000000ul, 3ul, 0x32ul, -1, 0);
  install_segv_handler();
  loop();
  return 0;
}
