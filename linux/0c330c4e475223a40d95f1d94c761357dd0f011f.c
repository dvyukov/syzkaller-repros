// general protection fault in kvm_lapic_hv_timer_in_use
// https://syzkaller.appspot.com/bug?id=0c330c4e475223a40d95f1d94c761357dd0f011f
// status:fixed
// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <arpa/inet.h>
#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <net/if_arp.h>
#include <netinet/in.h>
#include <pthread.h>
#include <sched.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/uio.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#include <linux/futex.h>
#include <linux/if.h>
#include <linux/if_ether.h>
#include <linux/if_tun.h>
#include <linux/ip.h>
#include <linux/kvm.h>
#include <linux/net.h>
#include <linux/netfilter_bridge/ebtables.h>
#include <linux/tcp.h>

unsigned long long procid;

static __thread int skip_segv;
static __thread jmp_buf segv_env;

static void segv_handler(int sig, siginfo_t* info, void* ctx)
{
  uintptr_t addr = (uintptr_t)info->si_addr;
  const uintptr_t prog_start = 1 << 20;
  const uintptr_t prog_end = 100 << 20;
  if (__atomic_load_n(&skip_segv, __ATOMIC_RELAXED) &&
      (addr < prog_start || addr > prog_end)) {
    _longjmp(segv_env, 1);
  }
  exit(sig);
}

static void install_segv_handler(void)
{
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  syscall(SYS_rt_sigaction, 0x20, &sa, NULL, 8);
  syscall(SYS_rt_sigaction, 0x21, &sa, NULL, 8);
  memset(&sa, 0, sizeof(sa));
  sa.sa_sigaction = segv_handler;
  sa.sa_flags = SA_NODEFER | SA_SIGINFO;
  sigaction(SIGSEGV, &sa, NULL);
  sigaction(SIGBUS, &sa, NULL);
}

#define NONFAILING(...)                                                        \
  {                                                                            \
    __atomic_fetch_add(&skip_segv, 1, __ATOMIC_SEQ_CST);                       \
    if (_setjmp(segv_env) == 0) {                                              \
      __VA_ARGS__;                                                             \
    }                                                                          \
    __atomic_fetch_sub(&skip_segv, 1, __ATOMIC_SEQ_CST);                       \
  }

static void sleep_ms(uint64_t ms)
{
  usleep(ms * 1000);
}

static uint64_t current_time_ms(void)
{
  struct timespec ts;
  if (clock_gettime(CLOCK_MONOTONIC, &ts))
    exit(1);
  return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}

static void use_temporary_dir(void)
{
  char tmpdir_template[] = "./syzkaller.XXXXXX";
  char* tmpdir = mkdtemp(tmpdir_template);
  if (!tmpdir)
    exit(1);
  if (chmod(tmpdir, 0777))
    exit(1);
  if (chdir(tmpdir))
    exit(1);
}

static void thread_start(void* (*fn)(void*), void* arg)
{
  pthread_t th;
  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 128 << 10);
  if (pthread_create(&th, &attr, fn, arg))
    exit(1);
  pthread_attr_destroy(&attr);
}

typedef struct {
  int state;
} event_t;

static void event_init(event_t* ev)
{
  ev->state = 0;
}

static void event_reset(event_t* ev)
{
  ev->state = 0;
}

static void event_set(event_t* ev)
{
  if (ev->state)
    exit(1);
  __atomic_store_n(&ev->state, 1, __ATOMIC_RELEASE);
  syscall(SYS_futex, &ev->state, FUTEX_WAKE | FUTEX_PRIVATE_FLAG);
}

static void event_wait(event_t* ev)
{
  while (!__atomic_load_n(&ev->state, __ATOMIC_ACQUIRE))
    syscall(SYS_futex, &ev->state, FUTEX_WAIT | FUTEX_PRIVATE_FLAG, 0, 0);
}

static int event_isset(event_t* ev)
{
  return __atomic_load_n(&ev->state, __ATOMIC_ACQUIRE);
}

static int event_timedwait(event_t* ev, uint64_t timeout)
{
  uint64_t start = current_time_ms();
  uint64_t now = start;
  for (;;) {
    uint64_t remain = timeout - (now - start);
    struct timespec ts;
    ts.tv_sec = remain / 1000;
    ts.tv_nsec = (remain % 1000) * 1000 * 1000;
    syscall(SYS_futex, &ev->state, FUTEX_WAIT | FUTEX_PRIVATE_FLAG, 0, &ts);
    if (__atomic_load_n(&ev->state, __ATOMIC_RELAXED))
      return 1;
    now = current_time_ms();
    if (now - start > timeout)
      return 0;
  }
}

static void vsnprintf_check(char* str, size_t size, const char* format,
                            va_list args)
{
  int rv;
  rv = vsnprintf(str, size, format, args);
  if (rv < 0)
    exit(1);
  if ((size_t)rv >= size)
    exit(1);
}

#define COMMAND_MAX_LEN 128
#define PATH_PREFIX                                                            \
  "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin "
#define PATH_PREFIX_LEN (sizeof(PATH_PREFIX) - 1)

static void execute_command(bool panic, const char* format, ...)
{
  va_list args;
  char command[PATH_PREFIX_LEN + COMMAND_MAX_LEN];
  int rv;
  va_start(args, format);
  memcpy(command, PATH_PREFIX, PATH_PREFIX_LEN);
  vsnprintf_check(command + PATH_PREFIX_LEN, COMMAND_MAX_LEN, format, args);
  va_end(args);
  rv = system(command);
  if (rv) {
    if (panic)
      exit(1);
  }
}

static int tunfd = -1;
static int tun_frags_enabled;
#define SYZ_TUN_MAX_PACKET_SIZE 1000

#define TUN_IFACE "syz_tun"

#define LOCAL_MAC "aa:aa:aa:aa:aa:aa"
#define REMOTE_MAC "aa:aa:aa:aa:aa:bb"

#define LOCAL_IPV4 "172.20.20.170"
#define REMOTE_IPV4 "172.20.20.187"

#define LOCAL_IPV6 "fe80::aa"
#define REMOTE_IPV6 "fe80::bb"

#define IFF_NAPI 0x0010
#define IFF_NAPI_FRAGS 0x0020

static void initialize_tun(void)
{
  tunfd = open("/dev/net/tun", O_RDWR | O_NONBLOCK);
  if (tunfd == -1) {
    printf("tun: can't open /dev/net/tun: please enable CONFIG_TUN=y\n");
    printf("otherwise fuzzing or reproducing might not work as intended\n");
    return;
  }
  const int kTunFd = 240;
  if (dup2(tunfd, kTunFd) < 0)
    exit(1);
  close(tunfd);
  tunfd = kTunFd;
  struct ifreq ifr;
  memset(&ifr, 0, sizeof(ifr));
  strncpy(ifr.ifr_name, TUN_IFACE, IFNAMSIZ);
  ifr.ifr_flags = IFF_TAP | IFF_NO_PI | IFF_NAPI | IFF_NAPI_FRAGS;
  if (ioctl(tunfd, TUNSETIFF, (void*)&ifr) < 0) {
    ifr.ifr_flags = IFF_TAP | IFF_NO_PI;
    if (ioctl(tunfd, TUNSETIFF, (void*)&ifr) < 0)
      exit(1);
  }
  if (ioctl(tunfd, TUNGETIFF, (void*)&ifr) < 0)
    exit(1);
  tun_frags_enabled = (ifr.ifr_flags & IFF_NAPI_FRAGS) != 0;
  execute_command(0, "sysctl -w net.ipv6.conf.%s.accept_dad=0", TUN_IFACE);
  execute_command(0, "sysctl -w net.ipv6.conf.%s.router_solicitations=0",
                  TUN_IFACE);
  execute_command(1, "ip link set dev %s address %s", TUN_IFACE, LOCAL_MAC);
  execute_command(1, "ip addr add %s/24 dev %s", LOCAL_IPV4, TUN_IFACE);
  execute_command(1, "ip neigh add %s lladdr %s dev %s nud permanent",
                  REMOTE_IPV4, REMOTE_MAC, TUN_IFACE);
  execute_command(0, "ip -6 addr add %s/120 dev %s", LOCAL_IPV6, TUN_IFACE);
  execute_command(0, "ip -6 neigh add %s lladdr %s dev %s nud permanent",
                  REMOTE_IPV6, REMOTE_MAC, TUN_IFACE);
  execute_command(1, "ip link set dev %s up", TUN_IFACE);
}

#define DEV_IPV4 "172.20.20.%d"
#define DEV_IPV6 "fe80::%02hx"
#define DEV_MAC "aa:aa:aa:aa:aa:%02hx"

static void snprintf_check(char* str, size_t size, const char* format, ...)
{
  va_list args;
  va_start(args, format);
  vsnprintf_check(str, size, format, args);
  va_end(args);
}
static void initialize_netdevices(void)
{
  unsigned i;
  const char* devtypes[] = {"ip6gretap", "bridge", "vcan", "bond", "team"};
  const char* devnames[] = {"lo",
                            "sit0",
                            "bridge0",
                            "vcan0",
                            "tunl0",
                            "gre0",
                            "gretap0",
                            "ip_vti0",
                            "ip6_vti0",
                            "ip6tnl0",
                            "ip6gre0",
                            "ip6gretap0",
                            "erspan0",
                            "bond0",
                            "veth0",
                            "veth1",
                            "team0",
                            "veth0_to_bridge",
                            "veth1_to_bridge",
                            "veth0_to_bond",
                            "veth1_to_bond",
                            "veth0_to_team",
                            "veth1_to_team"};
  const char* devmasters[] = {"bridge", "bond", "team"};
  for (i = 0; i < sizeof(devtypes) / (sizeof(devtypes[0])); i++)
    execute_command(0, "ip link add dev %s0 type %s", devtypes[i], devtypes[i]);
  execute_command(0, "ip link add type veth");
  for (i = 0; i < sizeof(devmasters) / (sizeof(devmasters[0])); i++) {
    execute_command(
        0, "ip link add name %s_slave_0 type veth peer name veth0_to_%s",
        devmasters[i], devmasters[i]);
    execute_command(
        0, "ip link add name %s_slave_1 type veth peer name veth1_to_%s",
        devmasters[i], devmasters[i]);
    execute_command(0, "ip link set %s_slave_0 master %s0", devmasters[i],
                    devmasters[i]);
    execute_command(0, "ip link set %s_slave_1 master %s0", devmasters[i],
                    devmasters[i]);
    execute_command(0, "ip link set veth0_to_%s up", devmasters[i]);
    execute_command(0, "ip link set veth1_to_%s up", devmasters[i]);
  }
  execute_command(0, "ip link set bridge_slave_0 up");
  execute_command(0, "ip link set bridge_slave_1 up");
  for (i = 0; i < sizeof(devnames) / (sizeof(devnames[0])); i++) {
    char addr[32];
    snprintf_check(addr, sizeof(addr), DEV_IPV4, i + 10);
    execute_command(0, "ip -4 addr add %s/24 dev %s", addr, devnames[i]);
    snprintf_check(addr, sizeof(addr), DEV_IPV6, i + 10);
    execute_command(0, "ip -6 addr add %s/120 dev %s", addr, devnames[i]);
    snprintf_check(addr, sizeof(addr), DEV_MAC, i + 10);
    execute_command(0, "ip link set dev %s address %s", devnames[i], addr);
    execute_command(0, "ip link set dev %s up", devnames[i]);
  }
}

static int read_tun(char* data, int size)
{
  if (tunfd < 0)
    return -1;
  int rv = read(tunfd, data, size);
  if (rv < 0) {
    if (errno == EAGAIN)
      return -1;
    if (errno == EBADFD)
      return -1;
    exit(1);
  }
  return rv;
}

static void flush_tun()
{
  char data[SYZ_TUN_MAX_PACKET_SIZE];
  while (read_tun(&data[0], sizeof(data)) != -1) {
  }
}

static long syz_kvm_setup_cpu(long a0, long a1, long a2, long a3, long a4,
                              long a5, long a6, long a7)
{
  return 0;
}

static bool write_file(const char* file, const char* what, ...)
{
  char buf[1024];
  va_list args;
  va_start(args, what);
  vsnprintf(buf, sizeof(buf), what, args);
  va_end(args);
  buf[sizeof(buf) - 1] = 0;
  int len = strlen(buf);
  int fd = open(file, O_WRONLY | O_CLOEXEC);
  if (fd == -1)
    return false;
  if (write(fd, buf, len) != len) {
    int err = errno;
    close(fd);
    errno = err;
    return false;
  }
  close(fd);
  return true;
}

#define XT_TABLE_SIZE 1536
#define XT_MAX_ENTRIES 10

struct xt_counters {
  uint64_t pcnt, bcnt;
};

struct ipt_getinfo {
  char name[32];
  unsigned int valid_hooks;
  unsigned int hook_entry[5];
  unsigned int underflow[5];
  unsigned int num_entries;
  unsigned int size;
};

struct ipt_get_entries {
  char name[32];
  unsigned int size;
  void* entrytable[XT_TABLE_SIZE / sizeof(void*)];
};

struct ipt_replace {
  char name[32];
  unsigned int valid_hooks;
  unsigned int num_entries;
  unsigned int size;
  unsigned int hook_entry[5];
  unsigned int underflow[5];
  unsigned int num_counters;
  struct xt_counters* counters;
  char entrytable[XT_TABLE_SIZE];
};

struct ipt_table_desc {
  const char* name;
  struct ipt_getinfo info;
  struct ipt_replace replace;
};

static struct ipt_table_desc ipv4_tables[] = {
    {.name = "filter"}, {.name = "nat"},      {.name = "mangle"},
    {.name = "raw"},    {.name = "security"},
};

static struct ipt_table_desc ipv6_tables[] = {
    {.name = "filter"}, {.name = "nat"},      {.name = "mangle"},
    {.name = "raw"},    {.name = "security"},
};

#define IPT_BASE_CTL 64
#define IPT_SO_SET_REPLACE (IPT_BASE_CTL)
#define IPT_SO_GET_INFO (IPT_BASE_CTL)
#define IPT_SO_GET_ENTRIES (IPT_BASE_CTL + 1)

struct arpt_getinfo {
  char name[32];
  unsigned int valid_hooks;
  unsigned int hook_entry[3];
  unsigned int underflow[3];
  unsigned int num_entries;
  unsigned int size;
};

struct arpt_get_entries {
  char name[32];
  unsigned int size;
  void* entrytable[XT_TABLE_SIZE / sizeof(void*)];
};

struct arpt_replace {
  char name[32];
  unsigned int valid_hooks;
  unsigned int num_entries;
  unsigned int size;
  unsigned int hook_entry[3];
  unsigned int underflow[3];
  unsigned int num_counters;
  struct xt_counters* counters;
  char entrytable[XT_TABLE_SIZE];
};

struct arpt_table_desc {
  const char* name;
  struct arpt_getinfo info;
  struct arpt_replace replace;
};

static struct arpt_table_desc arpt_tables[] = {
    {.name = "filter"},
};

#define ARPT_BASE_CTL 96
#define ARPT_SO_SET_REPLACE (ARPT_BASE_CTL)
#define ARPT_SO_GET_INFO (ARPT_BASE_CTL)
#define ARPT_SO_GET_ENTRIES (ARPT_BASE_CTL + 1)

static void checkpoint_iptables(struct ipt_table_desc* tables, int num_tables,
                                int family, int level)
{
  struct ipt_get_entries entries;
  socklen_t optlen;
  int fd, i;
  fd = socket(family, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < num_tables; i++) {
    struct ipt_table_desc* table = &tables[i];
    strcpy(table->info.name, table->name);
    strcpy(table->replace.name, table->name);
    optlen = sizeof(table->info);
    if (getsockopt(fd, level, IPT_SO_GET_INFO, &table->info, &optlen)) {
      switch (errno) {
      case EPERM:
      case ENOENT:
      case ENOPROTOOPT:
        continue;
      }
      exit(1);
    }
    if (table->info.size > sizeof(table->replace.entrytable))
      exit(1);
    if (table->info.num_entries > XT_MAX_ENTRIES)
      exit(1);
    memset(&entries, 0, sizeof(entries));
    strcpy(entries.name, table->name);
    entries.size = table->info.size;
    optlen = sizeof(entries) - sizeof(entries.entrytable) + table->info.size;
    if (getsockopt(fd, level, IPT_SO_GET_ENTRIES, &entries, &optlen))
      exit(1);
    table->replace.valid_hooks = table->info.valid_hooks;
    table->replace.num_entries = table->info.num_entries;
    table->replace.size = table->info.size;
    memcpy(table->replace.hook_entry, table->info.hook_entry,
           sizeof(table->replace.hook_entry));
    memcpy(table->replace.underflow, table->info.underflow,
           sizeof(table->replace.underflow));
    memcpy(table->replace.entrytable, entries.entrytable, table->info.size);
  }
  close(fd);
}

static void reset_iptables(struct ipt_table_desc* tables, int num_tables,
                           int family, int level)
{
  struct xt_counters counters[XT_MAX_ENTRIES];
  struct ipt_get_entries entries;
  struct ipt_getinfo info;
  socklen_t optlen;
  int fd, i;
  fd = socket(family, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < num_tables; i++) {
    struct ipt_table_desc* table = &tables[i];
    if (table->info.valid_hooks == 0)
      continue;
    memset(&info, 0, sizeof(info));
    strcpy(info.name, table->name);
    optlen = sizeof(info);
    if (getsockopt(fd, level, IPT_SO_GET_INFO, &info, &optlen))
      exit(1);
    if (memcmp(&table->info, &info, sizeof(table->info)) == 0) {
      memset(&entries, 0, sizeof(entries));
      strcpy(entries.name, table->name);
      entries.size = table->info.size;
      optlen = sizeof(entries) - sizeof(entries.entrytable) + entries.size;
      if (getsockopt(fd, level, IPT_SO_GET_ENTRIES, &entries, &optlen))
        exit(1);
      if (memcmp(table->replace.entrytable, entries.entrytable,
                 table->info.size) == 0)
        continue;
    }
    table->replace.num_counters = info.num_entries;
    table->replace.counters = counters;
    optlen = sizeof(table->replace) - sizeof(table->replace.entrytable) +
             table->replace.size;
    if (setsockopt(fd, level, IPT_SO_SET_REPLACE, &table->replace, optlen))
      exit(1);
  }
  close(fd);
}

static void checkpoint_arptables(void)
{
  struct arpt_get_entries entries;
  socklen_t optlen;
  unsigned i;
  int fd;
  fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < sizeof(arpt_tables) / sizeof(arpt_tables[0]); i++) {
    struct arpt_table_desc* table = &arpt_tables[i];
    strcpy(table->info.name, table->name);
    strcpy(table->replace.name, table->name);
    optlen = sizeof(table->info);
    if (getsockopt(fd, SOL_IP, ARPT_SO_GET_INFO, &table->info, &optlen)) {
      switch (errno) {
      case EPERM:
      case ENOENT:
      case ENOPROTOOPT:
        continue;
      }
      exit(1);
    }
    if (table->info.size > sizeof(table->replace.entrytable))
      exit(1);
    if (table->info.num_entries > XT_MAX_ENTRIES)
      exit(1);
    memset(&entries, 0, sizeof(entries));
    strcpy(entries.name, table->name);
    entries.size = table->info.size;
    optlen = sizeof(entries) - sizeof(entries.entrytable) + table->info.size;
    if (getsockopt(fd, SOL_IP, ARPT_SO_GET_ENTRIES, &entries, &optlen))
      exit(1);
    table->replace.valid_hooks = table->info.valid_hooks;
    table->replace.num_entries = table->info.num_entries;
    table->replace.size = table->info.size;
    memcpy(table->replace.hook_entry, table->info.hook_entry,
           sizeof(table->replace.hook_entry));
    memcpy(table->replace.underflow, table->info.underflow,
           sizeof(table->replace.underflow));
    memcpy(table->replace.entrytable, entries.entrytable, table->info.size);
  }
  close(fd);
}

static void reset_arptables()
{
  struct xt_counters counters[XT_MAX_ENTRIES];
  struct arpt_get_entries entries;
  struct arpt_getinfo info;
  socklen_t optlen;
  unsigned i;
  int fd;
  fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < sizeof(arpt_tables) / sizeof(arpt_tables[0]); i++) {
    struct arpt_table_desc* table = &arpt_tables[i];
    if (table->info.valid_hooks == 0)
      continue;
    memset(&info, 0, sizeof(info));
    strcpy(info.name, table->name);
    optlen = sizeof(info);
    if (getsockopt(fd, SOL_IP, ARPT_SO_GET_INFO, &info, &optlen))
      exit(1);
    if (memcmp(&table->info, &info, sizeof(table->info)) == 0) {
      memset(&entries, 0, sizeof(entries));
      strcpy(entries.name, table->name);
      entries.size = table->info.size;
      optlen = sizeof(entries) - sizeof(entries.entrytable) + entries.size;
      if (getsockopt(fd, SOL_IP, ARPT_SO_GET_ENTRIES, &entries, &optlen))
        exit(1);
      if (memcmp(table->replace.entrytable, entries.entrytable,
                 table->info.size) == 0)
        continue;
    } else {
    }
    table->replace.num_counters = info.num_entries;
    table->replace.counters = counters;
    optlen = sizeof(table->replace) - sizeof(table->replace.entrytable) +
             table->replace.size;
    if (setsockopt(fd, SOL_IP, ARPT_SO_SET_REPLACE, &table->replace, optlen))
      exit(1);
  }
  close(fd);
}

struct ebt_table_desc {
  const char* name;
  struct ebt_replace replace;
  char entrytable[XT_TABLE_SIZE];
};

static struct ebt_table_desc ebt_tables[] = {
    {.name = "filter"},
    {.name = "nat"},
    {.name = "broute"},
};

static void checkpoint_ebtables(void)
{
  socklen_t optlen;
  unsigned i;
  int fd;
  fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < sizeof(ebt_tables) / sizeof(ebt_tables[0]); i++) {
    struct ebt_table_desc* table = &ebt_tables[i];
    strcpy(table->replace.name, table->name);
    optlen = sizeof(table->replace);
    if (getsockopt(fd, SOL_IP, EBT_SO_GET_INIT_INFO, &table->replace,
                   &optlen)) {
      switch (errno) {
      case EPERM:
      case ENOENT:
      case ENOPROTOOPT:
        continue;
      }
      exit(1);
    }
    if (table->replace.entries_size > sizeof(table->entrytable))
      exit(1);
    table->replace.num_counters = 0;
    table->replace.entries = table->entrytable;
    optlen = sizeof(table->replace) + table->replace.entries_size;
    if (getsockopt(fd, SOL_IP, EBT_SO_GET_INIT_ENTRIES, &table->replace,
                   &optlen))
      exit(1);
  }
  close(fd);
}

static void reset_ebtables()
{
  struct ebt_replace replace;
  char entrytable[XT_TABLE_SIZE];
  socklen_t optlen;
  unsigned i, j, h;
  int fd;
  fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  if (fd == -1) {
    switch (errno) {
    case EAFNOSUPPORT:
    case ENOPROTOOPT:
      return;
    }
    exit(1);
  }
  for (i = 0; i < sizeof(ebt_tables) / sizeof(ebt_tables[0]); i++) {
    struct ebt_table_desc* table = &ebt_tables[i];
    if (table->replace.valid_hooks == 0)
      continue;
    memset(&replace, 0, sizeof(replace));
    strcpy(replace.name, table->name);
    optlen = sizeof(replace);
    if (getsockopt(fd, SOL_IP, EBT_SO_GET_INFO, &replace, &optlen))
      exit(1);
    replace.num_counters = 0;
    table->replace.entries = 0;
    for (h = 0; h < NF_BR_NUMHOOKS; h++)
      table->replace.hook_entry[h] = 0;
    if (memcmp(&table->replace, &replace, sizeof(table->replace)) == 0) {
      memset(&entrytable, 0, sizeof(entrytable));
      replace.entries = entrytable;
      optlen = sizeof(replace) + replace.entries_size;
      if (getsockopt(fd, SOL_IP, EBT_SO_GET_ENTRIES, &replace, &optlen))
        exit(1);
      if (memcmp(table->entrytable, entrytable, replace.entries_size) == 0)
        continue;
    }
    for (j = 0, h = 0; h < NF_BR_NUMHOOKS; h++) {
      if (table->replace.valid_hooks & (1 << h)) {
        table->replace.hook_entry[h] =
            (struct ebt_entries*)table->entrytable + j;
        j++;
      }
    }
    table->replace.entries = table->entrytable;
    optlen = sizeof(table->replace) + table->replace.entries_size;
    if (setsockopt(fd, SOL_IP, EBT_SO_SET_ENTRIES, &table->replace, optlen))
      exit(1);
  }
  close(fd);
}

static void checkpoint_net_namespace(void)
{
  checkpoint_ebtables();
  checkpoint_arptables();
  checkpoint_iptables(ipv4_tables, sizeof(ipv4_tables) / sizeof(ipv4_tables[0]),
                      AF_INET, SOL_IP);
  checkpoint_iptables(ipv6_tables, sizeof(ipv6_tables) / sizeof(ipv6_tables[0]),
                      AF_INET6, SOL_IPV6);
}

static void reset_net_namespace(void)
{
  reset_ebtables();
  reset_arptables();
  reset_iptables(ipv4_tables, sizeof(ipv4_tables) / sizeof(ipv4_tables[0]),
                 AF_INET, SOL_IP);
  reset_iptables(ipv6_tables, sizeof(ipv6_tables) / sizeof(ipv6_tables[0]),
                 AF_INET6, SOL_IPV6);
}

static void setup_cgroups()
{
  if (mkdir("/syzcgroup", 0777)) {
  }
  if (mkdir("/syzcgroup/unified", 0777)) {
  }
  if (mount("none", "/syzcgroup/unified", "cgroup2", 0, NULL)) {
  }
  if (chmod("/syzcgroup/unified", 0777)) {
  }
  if (!write_file("/syzcgroup/unified/cgroup.subtree_control",
                  "+cpu +memory +io +pids +rdma")) {
  }
  if (mkdir("/syzcgroup/cpu", 0777)) {
  }
  if (mount("none", "/syzcgroup/cpu", "cgroup", 0,
            "cpuset,cpuacct,perf_event,hugetlb")) {
  }
  if (!write_file("/syzcgroup/cpu/cgroup.clone_children", "1")) {
  }
  if (chmod("/syzcgroup/cpu", 0777)) {
  }
  if (mkdir("/syzcgroup/net", 0777)) {
  }
  if (mount("none", "/syzcgroup/net", "cgroup", 0,
            "net_cls,net_prio,devices,freezer")) {
  }
  if (chmod("/syzcgroup/net", 0777)) {
  }
  if (!write_file("/proc/self/oom_score_adj", "-1000")) {
  }
}
static void setup_binfmt_misc()
{
  if (mount(0, "/proc/sys/fs/binfmt_misc", "binfmt_misc", 0, 0)) {
  }
  if (!write_file("/proc/sys/fs/binfmt_misc/register",
                  ":syz0:M:0:\x01::./file0:")) {
  }
  if (!write_file("/proc/sys/fs/binfmt_misc/register",
                  ":syz1:M:1:\x02::./file0:POC")) {
  }
}

static void setup_common()
{
  if (mount(0, "/sys/fs/fuse/connections", "fusectl", 0, 0)) {
  }
  setup_cgroups();
  setup_binfmt_misc();
}

static void loop();

static void sandbox_common()
{
  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
  setpgrp();
  setsid();
  struct rlimit rlim;
  rlim.rlim_cur = rlim.rlim_max = 160 << 20;
  setrlimit(RLIMIT_AS, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 8 << 20;
  setrlimit(RLIMIT_MEMLOCK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 136 << 20;
  setrlimit(RLIMIT_FSIZE, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 1 << 20;
  setrlimit(RLIMIT_STACK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 0;
  setrlimit(RLIMIT_CORE, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 256;
  setrlimit(RLIMIT_NOFILE, &rlim);
  if (unshare(CLONE_NEWNS)) {
  }
  if (unshare(CLONE_NEWIPC)) {
  }
  if (unshare(0x02000000)) {
  }
  if (unshare(CLONE_NEWUTS)) {
  }
  if (unshare(CLONE_SYSVSEM)) {
  }
}

int wait_for_loop(int pid)
{
  if (pid < 0)
    exit(1);
  int status = 0;
  while (waitpid(-1, &status, __WALL) != pid) {
  }
  return WEXITSTATUS(status);
}

static int do_sandbox_none(void)
{
  if (unshare(CLONE_NEWPID)) {
  }
  int pid = fork();
  if (pid != 0)
    return wait_for_loop(pid);
  setup_common();
  sandbox_common();
  if (unshare(CLONE_NEWNET)) {
  }
  initialize_tun();
  initialize_netdevices();
  loop();
  exit(1);
}

#define FS_IOC_SETFLAGS _IOW('f', 2, long)
static void remove_dir(const char* dir)
{
  DIR* dp;
  struct dirent* ep;
  int iter = 0;
retry:
  while (umount2(dir, MNT_DETACH) == 0) {
  }
  dp = opendir(dir);
  if (dp == NULL) {
    if (errno == EMFILE) {
      exit(1);
    }
    exit(1);
  }
  while ((ep = readdir(dp))) {
    if (strcmp(ep->d_name, ".") == 0 || strcmp(ep->d_name, "..") == 0)
      continue;
    char filename[FILENAME_MAX];
    snprintf(filename, sizeof(filename), "%s/%s", dir, ep->d_name);
    while (umount2(filename, MNT_DETACH) == 0) {
    }
    struct stat st;
    if (lstat(filename, &st))
      exit(1);
    if (S_ISDIR(st.st_mode)) {
      remove_dir(filename);
      continue;
    }
    int i;
    for (i = 0;; i++) {
      if (unlink(filename) == 0)
        break;
      if (errno == EPERM) {
        int fd = open(filename, O_RDONLY);
        if (fd != -1) {
          long flags = 0;
          if (ioctl(fd, FS_IOC_SETFLAGS, &flags) == 0)
            close(fd);
          continue;
        }
      }
      if (errno == EROFS) {
        break;
      }
      if (errno != EBUSY || i > 100)
        exit(1);
      if (umount2(filename, MNT_DETACH))
        exit(1);
    }
  }
  closedir(dp);
  int i;
  for (i = 0;; i++) {
    if (rmdir(dir) == 0)
      break;
    if (i < 100) {
      if (errno == EPERM) {
        int fd = open(dir, O_RDONLY);
        if (fd != -1) {
          long flags = 0;
          if (ioctl(fd, FS_IOC_SETFLAGS, &flags) == 0)
            close(fd);
          continue;
        }
      }
      if (errno == EROFS) {
        break;
      }
      if (errno == EBUSY) {
        if (umount2(dir, MNT_DETACH))
          exit(1);
        continue;
      }
      if (errno == ENOTEMPTY) {
        if (iter < 100) {
          iter++;
          goto retry;
        }
      }
    }
    exit(1);
  }
}

static void kill_and_wait(int pid, int* status)
{
  kill(-pid, SIGKILL);
  kill(pid, SIGKILL);
  int i;
  for (i = 0; i < 100; i++) {
    if (waitpid(-1, status, WNOHANG | __WALL) == pid)
      return;
    usleep(1000);
  }
  DIR* dir = opendir("/sys/fs/fuse/connections");
  if (dir) {
    for (;;) {
      struct dirent* ent = readdir(dir);
      if (!ent)
        break;
      if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
        continue;
      char abort[300];
      snprintf(abort, sizeof(abort), "/sys/fs/fuse/connections/%s/abort",
               ent->d_name);
      int fd = open(abort, O_WRONLY);
      if (fd == -1) {
        continue;
      }
      if (write(fd, abort, 1) < 0) {
      }
      close(fd);
    }
    closedir(dir);
  } else {
  }
  while (waitpid(-1, status, __WALL) != pid) {
  }
}

#define SYZ_HAVE_SETUP_LOOP 1
static void setup_loop()
{
  int pid = getpid();
  char cgroupdir[64];
  char file[128];
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/unified/syz%llu", procid);
  if (mkdir(cgroupdir, 0777)) {
  }
  snprintf(file, sizeof(file), "%s/pids.max", cgroupdir);
  if (!write_file(file, "32")) {
  }
  snprintf(file, sizeof(file), "%s/memory.low", cgroupdir);
  if (!write_file(file, "%d", 198 << 20)) {
  }
  snprintf(file, sizeof(file), "%s/memory.high", cgroupdir);
  if (!write_file(file, "%d", 199 << 20)) {
  }
  snprintf(file, sizeof(file), "%s/memory.max", cgroupdir);
  if (!write_file(file, "%d", 200 << 20)) {
  }
  if (!write_file("/proc/self/oom_score_adj", "-1000")) {
  }
  snprintf(file, sizeof(file), "%s/cgroup.procs", cgroupdir);
  if (!write_file(file, "%d", pid)) {
  }
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/cpu/syz%llu", procid);
  if (mkdir(cgroupdir, 0777)) {
  }
  snprintf(file, sizeof(file), "%s/cgroup.procs", cgroupdir);
  if (!write_file(file, "%d", pid)) {
  }
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/net/syz%llu", procid);
  if (mkdir(cgroupdir, 0777)) {
  }
  snprintf(file, sizeof(file), "%s/cgroup.procs", cgroupdir);
  if (!write_file(file, "%d", pid)) {
  }
  checkpoint_net_namespace();
}

#define SYZ_HAVE_RESET_LOOP 1
static void reset_loop()
{
  reset_net_namespace();
}

#define SYZ_HAVE_SETUP_TEST 1
static void setup_test()
{
  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
  setpgrp();
  char cgroupdir[64];
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/unified/syz%llu", procid);
  if (symlink(cgroupdir, "./cgroup")) {
  }
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/cpu/syz%llu", procid);
  if (symlink(cgroupdir, "./cgroup.cpu")) {
  }
  snprintf(cgroupdir, sizeof(cgroupdir), "/syzcgroup/net/syz%llu", procid);
  if (symlink(cgroupdir, "./cgroup.net")) {
  }
  if (!write_file("/proc/self/oom_score_adj", "0")) {
  }
  flush_tun();
}

#define SYZ_HAVE_RESET_TEST 1
static void reset_test()
{
  int fd;
  for (fd = 3; fd < 30; fd++)
    close(fd);
}

struct thread_t {
  int created, call;
  event_t ready, done;
};

static struct thread_t threads[16];
static void execute_call(int call);
static int running;

static void* thr(void* arg)
{
  struct thread_t* th = (struct thread_t*)arg;
  for (;;) {
    event_wait(&th->ready);
    event_reset(&th->ready);
    execute_call(th->call);
    __atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
    event_set(&th->done);
  }
  return 0;
}

static void execute_one(void)
{
  int i, call, thread;
  int collide = 0;
again:
  for (call = 0; call < 5; call++) {
    for (thread = 0; thread < (int)(sizeof(threads) / sizeof(threads[0]));
         thread++) {
      struct thread_t* th = &threads[thread];
      if (!th->created) {
        th->created = 1;
        event_init(&th->ready);
        event_init(&th->done);
        event_set(&th->done);
        thread_start(thr, th);
      }
      if (!event_isset(&th->done))
        continue;
      event_reset(&th->done);
      th->call = call;
      __atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
      event_set(&th->ready);
      if (collide && (call % 2) == 0)
        break;
      event_timedwait(&th->done, 45);
      break;
    }
  }
  for (i = 0; i < 100 && __atomic_load_n(&running, __ATOMIC_RELAXED); i++)
    sleep_ms(1);
  if (!collide) {
    collide = 1;
    goto again;
  }
}

static void execute_one(void);

#define WAIT_FLAGS __WALL

static void loop(void)
{
  setup_loop();
  int iter;
  for (iter = 0;; iter++) {
    char cwdbuf[32];
    sprintf(cwdbuf, "./%d", iter);
    if (mkdir(cwdbuf, 0777))
      exit(1);
    reset_loop();
    int pid = fork();
    if (pid < 0)
      exit(1);
    if (pid == 0) {
      if (chdir(cwdbuf))
        exit(1);
      setup_test();
      execute_one();
      reset_test();
      exit(0);
    }
    int status = 0;
    uint64_t start = current_time_ms();
    for (;;) {
      if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
        break;
      sleep_ms(1);
      if (current_time_ms() - start < 5 * 1000)
        continue;
      kill_and_wait(pid, &status);
      break;
    }
    remove_dir(cwdbuf);
  }
}

uint64_t r[3] = {0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff};

void execute_call(int call)
{
  long res;
  switch (call) {
  case 0:
    NONFAILING(memcpy((void*)0x20000140, "/dev/kvm", 9));
    res = syscall(__NR_openat, 0xffffffffffffff9c, 0x20000140, 0, 0);
    if (res != -1)
      r[0] = res;
    break;
  case 1:
    res = syscall(__NR_ioctl, r[0], 0xae01, 0);
    if (res != -1)
      r[1] = res;
    break;
  case 2:
    res = syscall(__NR_ioctl, r[1], 0xae41, 0);
    if (res != -1)
      r[2] = res;
    break;
  case 3:
    NONFAILING(*(uint64_t*)0x20000100 = 0x40);
    NONFAILING(*(uint64_t*)0x20000108 = 0x20000500);
    NONFAILING(
        memcpy((void*)0x20000500,
               "\x0f\x08\x66\xb8\xed\x00\x8e\xc0\x66\xba\x40\x00\xb0\x00\xee"
               "\xd2\xa8\x07\x00\x00\x00\x41\x0f\x01\xca\xb9\x8e\x0b\x00\x00"
               "\xb8\x62\x00\x00\x00\xba\x00\x00\x00\x00\x0f\x30\xb9\x0b\x08"
               "\x00\x00\x0f\x32\x0f\xc7\x2a\x8f\x2a\x60\x12\x8f\x00\x00\x00"
               "\x00\x00\x30\x00\x00\x0f\xc7\xaa\x00\x10\x00\x00",
               72));
    NONFAILING(*(uint64_t*)0x20000110 = 0x48);
    syz_kvm_setup_cpu(-1, r[2], 0x20000000, 0x20000100, 1, 0, 0x20000000,
                      0x1000000000000040);
    break;
  case 4:
    NONFAILING(*(uint16_t*)0x20001040 = 0);
    NONFAILING(*(uint16_t*)0x20001042 = 0);
    NONFAILING(*(uint32_t*)0x20001044 = 0x2080);
    NONFAILING(*(uint64_t*)0x20001048 = 0);
    NONFAILING(*(uint64_t*)0x20001050 = 0);
    NONFAILING(*(uint16_t*)0x20001058 = 0);
    NONFAILING(*(uint8_t*)0x20001060 = 0);
    NONFAILING(*(uint8_t*)0x20001061 = 0);
    NONFAILING(*(uint8_t*)0x20001062 = 0);
    NONFAILING(*(uint8_t*)0x20001063 = 0);
    NONFAILING(*(uint8_t*)0x20001064 = 0);
    NONFAILING(*(uint8_t*)0x20001065 = 0);
    NONFAILING(*(uint8_t*)0x20001066 = 0);
    NONFAILING(*(uint8_t*)0x20001067 = 0);
    NONFAILING(*(uint8_t*)0x20001068 = 0);
    NONFAILING(*(uint8_t*)0x20001069 = 0);
    NONFAILING(*(uint8_t*)0x2000106a = 0);
    NONFAILING(*(uint8_t*)0x2000106b = 0);
    NONFAILING(*(uint8_t*)0x2000106c = 0);
    NONFAILING(*(uint8_t*)0x2000106d = 0);
    NONFAILING(*(uint8_t*)0x2000106e = 0);
    NONFAILING(*(uint8_t*)0x2000106f = 0);
    NONFAILING(*(uint8_t*)0x20001070 = 0);
    NONFAILING(*(uint8_t*)0x20001071 = 0);
    NONFAILING(*(uint8_t*)0x20001072 = 0);
    NONFAILING(*(uint8_t*)0x20001073 = 0);
    NONFAILING(*(uint8_t*)0x20001074 = 0);
    NONFAILING(*(uint8_t*)0x20001075 = 0);
    NONFAILING(*(uint8_t*)0x20001076 = 0);
    NONFAILING(*(uint8_t*)0x20001077 = 0);
    NONFAILING(*(uint8_t*)0x20001078 = 0);
    NONFAILING(*(uint8_t*)0x20001079 = 0);
    NONFAILING(*(uint8_t*)0x2000107a = 0);
    NONFAILING(*(uint8_t*)0x2000107b = 0);
    NONFAILING(*(uint8_t*)0x2000107c = 0);
    NONFAILING(*(uint8_t*)0x2000107d = 0);
    NONFAILING(*(uint8_t*)0x2000107e = 0);
    NONFAILING(*(uint8_t*)0x2000107f = 0);
    NONFAILING(*(uint8_t*)0x20001080 = 0);
    NONFAILING(*(uint8_t*)0x20001081 = 0);
    NONFAILING(*(uint8_t*)0x20001082 = 0);
    NONFAILING(*(uint8_t*)0x20001083 = 0);
    NONFAILING(*(uint8_t*)0x20001084 = 0);
    NONFAILING(*(uint8_t*)0x20001085 = 0);
    NONFAILING(*(uint8_t*)0x20001086 = 0);
    NONFAILING(*(uint8_t*)0x20001087 = 0);
    NONFAILING(*(uint8_t*)0x20001088 = 0);
    NONFAILING(*(uint8_t*)0x20001089 = 0);
    NONFAILING(*(uint8_t*)0x2000108a = 0);
    NONFAILING(*(uint8_t*)0x2000108b = 0);
    NONFAILING(*(uint8_t*)0x2000108c = 0);
    NONFAILING(*(uint8_t*)0x2000108d = 0);
    NONFAILING(*(uint8_t*)0x2000108e = 0);
    NONFAILING(*(uint8_t*)0x2000108f = 0);
    NONFAILING(*(uint8_t*)0x20001090 = 0);
    NONFAILING(*(uint8_t*)0x20001091 = 0);
    NONFAILING(*(uint8_t*)0x20001092 = 0);
    NONFAILING(*(uint8_t*)0x20001093 = 0);
    NONFAILING(*(uint8_t*)0x20001094 = 0);
    NONFAILING(*(uint8_t*)0x20001095 = 0);
    NONFAILING(*(uint8_t*)0x20001096 = 0);
    NONFAILING(*(uint8_t*)0x20001097 = 0);
    NONFAILING(*(uint8_t*)0x20001098 = 0);
    NONFAILING(*(uint8_t*)0x20001099 = 0);
    NONFAILING(*(uint8_t*)0x2000109a = 0);
    NONFAILING(*(uint8_t*)0x2000109b = 0);
    NONFAILING(*(uint8_t*)0x2000109c = 0);
    NONFAILING(*(uint8_t*)0x2000109d = 0);
    NONFAILING(*(uint8_t*)0x2000109e = 0);
    NONFAILING(*(uint8_t*)0x2000109f = 0);
    NONFAILING(*(uint8_t*)0x200010a0 = 0);
    NONFAILING(*(uint8_t*)0x200010a1 = 0);
    NONFAILING(*(uint8_t*)0x200010a2 = 0);
    NONFAILING(*(uint8_t*)0x200010a3 = 0);
    NONFAILING(*(uint8_t*)0x200010a4 = 0);
    NONFAILING(*(uint8_t*)0x200010a5 = 0);
    NONFAILING(*(uint8_t*)0x200010a6 = 0);
    NONFAILING(*(uint8_t*)0x200010a7 = 0);
    NONFAILING(*(uint8_t*)0x200010a8 = 0);
    NONFAILING(*(uint8_t*)0x200010a9 = 0);
    NONFAILING(*(uint8_t*)0x200010aa = 0);
    NONFAILING(*(uint8_t*)0x200010ab = 0);
    NONFAILING(*(uint8_t*)0x200010ac = 0);
    NONFAILING(*(uint8_t*)0x200010ad = 0);
    NONFAILING(*(uint8_t*)0x200010ae = 0);
    NONFAILING(*(uint8_t*)0x200010af = 0);
    NONFAILING(*(uint8_t*)0x200010b0 = 0);
    NONFAILING(*(uint8_t*)0x200010b1 = 0);
    NONFAILING(*(uint8_t*)0x200010b2 = 0);
    NONFAILING(*(uint8_t*)0x200010b3 = 0);
    NONFAILING(*(uint8_t*)0x200010b4 = 0);
    NONFAILING(*(uint8_t*)0x200010b5 = 0);
    NONFAILING(*(uint8_t*)0x200010b6 = 0);
    NONFAILING(*(uint8_t*)0x200010b7 = 0);
    NONFAILING(*(uint8_t*)0x200010b8 = 0);
    NONFAILING(*(uint8_t*)0x200010b9 = 0);
    NONFAILING(*(uint8_t*)0x200010ba = 0);
    NONFAILING(*(uint8_t*)0x200010bb = 0);
    NONFAILING(*(uint8_t*)0x200010bc = 0);
    NONFAILING(*(uint8_t*)0x200010bd = 0);
    NONFAILING(*(uint8_t*)0x200010be = 0);
    NONFAILING(*(uint8_t*)0x200010bf = 0);
    NONFAILING(memcpy(
        (void*)0x200010c0,
        "\xee\x61\x70\x2c\x98\xcd\xa9\x0b\x73\x47\xb0\xe6\x0b\x2e\x18\x6c\xd8"
        "\xa6\x4b\x83\xb2\x05\xd9\x2d\xae\x3f\x45\xe5\x18\xbb\xf5\x2f\x88\x95"
        "\x43\x49\x71\x77\x60\xab\x22\x36\xaa\xd1\x0e\x2f\x36\x97\x52\x06\x87"
        "\x61\xea\x1b\x1e\xf6\x3d\x7d\x67\x1e\x03\xe2\xce\x7d\x6f\xe6\x3d\x7d"
        "\xde\x02\x95\x5f\xdb\xac\x60\xb6\x1e\xb4\xb0\xf8\x26\x62\xd1\xdd\xbb"
        "\x06\x94\xb4\x3e\x31\x95\x97\x36\x2c\x62\xe3\xb0\x78\xf3\x0a\xc5\x35"
        "\x78\x9a\xf9\xea\x46\x53\xf2\xc4\xb8\xfd\xe3\x71\xce\xeb\x5c\xcf\x63"
        "\xec\x21\x34\x19\xba\xcc\xcb\x36\xdb\xd8\xba\x6b\x57\x24\x54\x43\xdc"
        "\x85\xaf\xf7\x4c\x36\x8b\xd9\xf9\xc9\x68\x89\xcb\x53\x4f\x2a\xcf\xa9"
        "\x03\x4d\x59\xdf\xfe\x95\x8f\x43\x57\xe1\xb4\x93\x2c\xbc\x27\xe0\x42"
        "\xea\xe8\xa1\x3a\x52\xa2\x98\xed\x31\x5f\x10\xcc\xb5\xcd\xb9\x81\x6f"
        "\x4d\x14\xb7\xfc\x90\x6c\x29\xc0\xb4\x80\x2f\x4a\xc8\x9d\xa2\x60\x64"
        "\x43\xfd\x7e\x22\x6f\x4a\x46\x4b\xd7\xfa\x57\xb0\x50\x7e\x8d\x60\xcb"
        "\xbe\x50\x0c\x41\x42\xbf\xef\x4d\xc4\x8e\x1a\xaa\xf5\xb6\x65\x3d\x51"
        "\x3a\x17\xcd\x3e\x09\xd0\xbe\xa5\x69\x44\x30\x26\x26\x6a\xd7\x69\x07"
        "\xe9\x9d\x87\x8b\x80\x87\x34\x27\xcf\x90\x2a\xa9\x55\x27\x58\xb6\x5c"
        "\xf1\x6c\x6b\x62\xb8\x7c\xb0\x28\x56\x2b\x19\xf2\x73\x89\xef\x54\x81"
        "\xe6\xd8\x12\x37\xc7\x9d\xa3\xbb\x1f\x92\x80\x09\x48\xc8\x72\xff\xc9"
        "\x75\x6b\x6a\xe6\xd2\xe2\x36\x33\x91\xf5\xd9\x5b\x5b\x7a\xee\x84\x30"
        "\x59\xe2\x74\xff\x61\xd1\x6f\xea\x7a\x15\x61\xb2\xd0\xdc\x47\x79\xc9"
        "\x22\xa5\x0c\xd9\xb4\x86\x08\x4e\x89\x2f\x86\x97\x8e\x54\xb9\x04\x73"
        "\xc3\x83\xf1\x93\x87\x2c\x72\x68\x31\xde\x98\x4c\x77\x09\x87\x67\xdb"
        "\xcc\x47\xf6\x27\xf0\x82\xbc\x0a\xa2\x8b\xd0\x03\xc8\xbe\x28\x9e\xf7"
        "\xd9\xe4\x5f\x49\xdb\xbf\x08\xc6\xd9\x21\x9d\x2e\x97\x1a\x59\x59\x26"
        "\xb5\x2f\xfa\x94\xac\x46\xb0\x09\xf5\x33\xd7\x16\x2a\x35\xa9\x42\xf6"
        "\xe4\x3d\x30\x40\xf7\x00\x1f\x26\x54\x05\x81\x3d\x0c\x44\x2e\x97\x5b"
        "\x30\xc1\x5c\x7d\x78\x50\x05\xfd\xbb\xd9\x00\xa0\x74\x95\xa4\x51\x9d"
        "\xbf\x7a\x36\xd8\x1c\x72\x4a\x7f\xc0\xf6\xc4\xf4\x78\x07\x31\xca\xa1"
        "\x2b\x14\x2d\xe4\x3d\x85\xa6\xad\x8b\xa3\xe3\x56\xa9\x7d\x31\xc4\xd5"
        "\x74\xd3\x75\xec\xe4\x87\x73\xca\x43\x76\xab\x11\xc0\xd3\x3e\x15\x37"
        "\xf1\x60\x55\x3b\x1b\x41\x32\xd5\x02\x50\xd5\x5e\xcd\x9b\xbf\x18\x09"
        "\xf3\xa5\xab\xaa\x61\x29\x12\x1f\x7d\x15\xed\x7b\xbe\xa6\xfc\x2d\xb6"
        "\xcd\x2a\x53\x37\xa9\xe2\xf2\xbb\xce\x23\xe5\x44\xfb\x27\x9a\x09\xdd"
        "\x71\x34\x35\x9b\x88\xda\xd5\x0b\x76\x01\xca\x55\x57\xbf\xa6\x2f\x77"
        "\x13\xeb\xcf\x25\x35\x8b\xaf\xcf\x64\x7d\xd2\x74\x4d\x2a\x4f\x00\xe6"
        "\x46\x0e\x13\x95\x60\xe8\x83\x88\x1f\x3f\x81\xbc\xa0\x31\x4c\x73\x11"
        "\x97\xcc\xb0\x7f\x21\x65\x6c\x13\x7d\xa1\x9b\x5e\x3d\xd9\xd8\x6b\x0a"
        "\x4d\xf0\x31\x31\xd8\x6d\x44\x2d\x5d\x60\x66\x2e\x90\xc0\x7b\xfe\xc7"
        "\x87\xef\x7e\xa0\xf9\xfe\xb1\xf2\xa2\xf5\x92\x57\x65\xb2\xda\x46\x95"
        "\x34\x56\x4c\x7d\x4c\xbd\x8e\x86\x36\xbf\x5f\x1a\x0d\x99\xaf\xb8\x35"
        "\xd2\x16\xe5\x19\x49\x5d\x3f\xd7\x6b\xc7\x10\x93\x1c\xbe\xe9\xe7\x73"
        "\x8b\x7b\x73\x5c\xa3\xda\xb0\x98\x1a\x5e\xca\xb6\xb6\xa6\x3d\x18\xde"
        "\xaf\x23\x85\x14\x7a\x5c\xc2\xd3\xe8\x17\xa9\x64\x8c\x96\xc9\xbd\x0b"
        "\x6a\x8a\xb1\x11\xb0\xd7\xdd\xa1\xa4\x14\x39\xa1\x7a\x27\xff\x7e\x01"
        "\x2c\x04\x0e\xf7\x4d\xc7\x50\xf9\xfd\xb5\x72\x8c\x59\xf7\xd6\x10\xc2"
        "\x6a\x04\x16\xcd\xcd\x99\x1a\xa0\x87\x6a\x56\xed\xfc\xa9\x74\x79\x67"
        "\xd9\x8a\x4d\x87\x9b\x2b\x0e\xe7\xa3\xbc\xd1\x44\xab\xe2\x52\xbc\xa8"
        "\x76\x1d\x66\x60\x2b\x90\x74\xdb\xbc\x20\x76\x51\xbe\xbb\x25\x1e\x9d"
        "\x00\x14\x75\x2a\x32\x01\x92\x43\x39\x5b\x83\xb0\x03\x4b\x34\xdb\x4b"
        "\x9d\x61\x81\xf9\x29\xa2\x84\xcb\xc1\xdc\x3f\x1b\x8f\x6e\x8d\xe4\x39"
        "\x47\xd2\x90\x38\x6a\x66\xb1\xd6\x3a\x3b\xe6\xda\x5e\xea\xb1\xda\x81"
        "\x6e\x7a\x35\xe2\x25\x8a\x92\xd9\xb0\x78\xf6\xde\xad\x0d\x9d\xaf\x2c"
        "\x8d\x47\xf4\x06\xaa\x3a\x57\xdf\x9d\x6c\xf5\x1d\x44\x15\xec\x0f\x33"
        "\xa7\xf1\xac\x51\xc3\x59\x76\x8d\xf6\xd0\x60\x30\xa3\xfb\x2a\x61\xd1"
        "\xa9\xbe\x22\x10\x95\xd2\x5a\x0d\x6d\x90\x7a\xc2\xb1\x48\x27\xd9\xa7"
        "\x67\xa4\x41\xc7\x93\xae\x70\x5e\x62\x7d\x38\x29\x3d\xb2\xa6\x89\x6d"
        "\xbb\xdb\x64\x6e\x49\xcf\xf4\xce\x2b\x25\xcc\x84\x56\xa0\xb0\x7c\x6f"
        "\xa0\xfd\xe4\xa4\x3a\x3c\x27\x27\xa2\xa1\xc5\xa6\x83\xfe\x9d\x65\x09"
        "\x60\x6c\x2e\x28\xa0\x4a\x60\x8a\x91\x11\xb6\xa0\x3d\x71\xf5\x12\x98"
        "\xca\x73\x51\x8a\x33\x4e\x05\x75\xbc\xfd\x6e\x5f\x56\xaa\x22\x94\x2a"
        "\x47\xdc\x0e\x03\x2a\x24\xdd\x7b\x2e\xa7\xf7\x68\x70\x97\x27\x17\x08"
        "\xc2\x89\x2b\x6a\xd2\x4e\xd6\x27\xe4\xb5\x02\xb2\x1e\xbd\x05\xf1\xf1"
        "\xb8\xdf\x87\x08\x61\x9c\xcb\x82\x7c\x47\x0d\x6f\x03\x26\x19\x2a\xd8"
        "\x1b\xc0\x9c\x26\x56\xef\x85\xed\xe3\xed\xea\x17\x7d\xd3\xe8\x0a\x5b"
        "\x22\xa6\xc1\x00\xcd\x15\x57\x3c\xc0\x6b\x1f\x59\x25\xd6\xc1\x20\xc0"
        "\xd3\x10\x2b\xc4\x70\xd4\xb3\x45\x9e\x00\xf1\x76\x0d\xef\xc4\xc8\x00"
        "\x7a\x7a\xa7\x92\x88\x3f\xc4\x7f\x71\xfa\x54\xf0\xcd\x04\x95\x5c\x3c"
        "\xab\x81\x99\xb3\xf8\x12\x06\x50\x7f\xac\xa5\xac\xab\xd7\x60\xd5\x58"
        "\x0e\x80\x02\xc2\x2a\x90\x7f\x52\x07\x37\x76\xd3\x8f\x78\x4a\x87\x97"
        "\x0e\x7d\xfc\x22\x52\x8d\xae\xce\x4d\x9c\xff\xd8\x44\x8e\xcb\x50\x97"
        "\x5c\x59\x8e\x86\x8d\x68\x46\xa7\x37\xbc\x91\x60\x09\xbf\x5c\xbc\x39"
        "\x8f\xea\x2d\x60\x07\x14\x6a\x10\x90\xaf\xf1\x49\xc0\x09\x62\x26\xaa"
        "\xd2\x28\xee\xe1\x10\xe4\x2e\x31\xa7\x03\x91\xd6\xd2\x47\xd1\xe1\x55"
        "\xdd\xe4\x2b\x42\x05\xa1\x6a\xb7\xe8\x1d\xa0\x8d\x2d\x72\x7c\x3e\x5e"
        "\x08\x11\x5f\xd0\x1d\x32\xa2\xc6\x3d\x6b\x57\x4b\xd5\x94\xbe\x73\x5f"
        "\x56\x58\xf9\x87\x49\x93\x68\x13\x0e\x6b\xb6\xa3\x32\x6c\x8f\x3c\xdd"
        "\x88\x87\xb4\x79\xca\x3b\xb8\xfa\x39\x18\x8f\x6b\xf4\xec\x0a\x84\xba"
        "\xe3\x72\x22\x46\xc9\x9d\x05\x8d\xcd\x22\xce\xe0\x62\x41\x43\x1a\x6b"
        "\x4e\x7a\xb2\x70\x20\x0a\x00\x58\x18\x46\x05\x18\xd9\x8e\xd7\x2a\xdb"
        "\xaf\xf8\x62\x41\x3a\x8f\x90\x00\x14\xe2\x6c\xeb\x44\x81\xe1\xdf\x57"
        "\x22\x73\xa0\xbf\xb6\x40\xa2\xb1\x33\x97\x7c\xe1\xc3\x2a\xed\x8e\xee"
        "\x59\xed\xb1\xb2\x2f\xc6\xc2\xaf\xee\x12\x79\x59\x50\x97\x3d\x4b\x64"
        "\x2c\x88\x61\x4a\x4f\x5a\x83\x70\x61\xc4\xb6\xfc\x67\xea\x6a\xf5\x87"
        "\xcc\x1f\x5c\x56\xd4\x6e\x64\xc5\x0c\xa5\xca\x42\xac\xbf\x4d\x8b\x07"
        "\x59\xa1\xc3\x3b\x1e\xae\x40\x82\x9e\x3b\x13\xc2\x70\xf0\xfa\x44\xb0"
        "\x39\x92\x48\xbd\xfe\x91\xa9\x3d\x3c\xda\x81\x38\x1f\x16\x1e\x03\xbb"
        "\xfe\x0e\x2f\xc8\xc2\x74\x42\xa4\x92\xe9\x96\x12\xce\x84\xf5\x3e\xe2"
        "\xc4\x21\xc3\xdd\xd8\xfd\xf2\x18\x1d\x2d\x5f\x1d\xd7\x07\xfe\x69\xd1"
        "\xe5\x2a\x07\x8b\x4d\x05\x01\x72\x46\x93\x12\xc4\x7e\xc3\xf3\x22\xa5"
        "\xaf\x54\x72\x21\x12\x65\xd2\x0d\xb3\x13\x7f\x71\x37\xeb\x94\x8d\xd4"
        "\x30\x62\x1e\xcc\x60\x97\xf5\x54\x0e\x65\x45\xfe\xb3\x79\xd5\x86\x06"
        "\x0e\xc6\xb7\x5c\x05\x81\xbc\xa6\xc5\xb5\xf5\x23\x5e\x0d\xd0\xfe\x85"
        "\xad\x7c\x55\xdf\x9f\x97\xbf\x0f\x9a\xe9\x95\xfe\x0b\xf2\xd0\xaf\xbf"
        "\xf6\x0b\x9a\xc4\xe8\x8f\x44\x88\x8b\x6b\x87\xd7\x40\xce\x6f\x6b\xbb"
        "\xb6\xae\x05\x44\x81\xd7\xaa\x3e\xca\x0d\x59\x9d\xe3\x4c\xe0\x62\x5e"
        "\x29\xb5\x6e\x1e\x3e\xa9\xee\xe7\xaa\x37\x76\x97\x33\x21\x8f\xe5\x0a"
        "\x7c\x00\xee\xce\x66\xae\xa9\x12\x48\x5b\xaf\x84\xa4\x4d\x56\x57\x61"
        "\x3d\x30\x15\x95\x68\x31\x78\xe1\x6d\xf4\x04\x6b\x11\x2f\x1e\x46\xad"
        "\x00\xf8\x0a\xde\x92\x5c\xc9\x87\x96\x7b\xef\x8f\x17\x28\x87\x90\x4c"
        "\x77\x52\x0c\x3f\x44\xbe\x86\xe1\x98\xf5\xb0\x26\x65\x53\x81\x4d\x58"
        "\x1c\xb1\xdd\x84\xa6\x3e\x07\x66\x59\x5f\x5c\xd4\x95\x81\x1b\xbf\xb4"
        "\x85\xed\xd8\xe6\xbe\xef\x08\xb6\x2d\x00\xa3\x82\xb3\x9a\xbe\xb1\x8c"
        "\xfa\xc3\x8e\xa1\xc3\x16\x64\x10\xa9\x28\x45\xd2\xbd\x50\x1e\xa8\x37"
        "\xf4\xca\x72\x43\x8a\x7e\xaa\x9e\xef\x7e\x02\xb7\x2c\x57\x0a\xc1\x94"
        "\x61\x65\x7d\x0e\xc3\xc4\xd9\x90\xeb\x91\x1a\xa9\xd2\xfb\xbf\x16\x75"
        "\x33\x5d\x22\xc0\xbe\x12\x3e\x16\x9c\x7e\x64\x17\xce\x90\x79\x1b\x1a"
        "\x3c\x77\x0a\x56\x88\xf2\xf8\xfe\x14\x6a\x21\x7e\x8e\x9d\xa7\x36\x8d"
        "\x1b\x79\xd7\x47\x0c\xf6\xcb\x7d\xb0\x28\xdb\xa0\xf6\x86\xfc\xb2\x0f"
        "\x6a\xdb\xae\xfd\xe2\x30\x6d\x92\x56\x6c\xcb\xea\xdc\xf0\x1d\x13\xb4"
        "\x60\x61\xc3\x82\xe2\x88\x1c\x71\xfb\x08\xa9\xe6\xdf\x52\x2d\x40\x88"
        "\xed\x59\x74\x42\xb0\xd8\x22\x7f\xd3\x89\x81\xb9\xf4\x3c\x45\x67\xab"
        "\xf1\x92\xc8\x7c\x8a\xf5\x4c\x21\x53\x3a\x74\x54\x1f\xbb\xd5\x09\xb0"
        "\x45\x35\xfb\x28\xe7\xf5\x19\x9d\xff\x53\xdf\x69\x67\x17\x6f\x9c\x21"
        "\xff\x42\xbe\xe3\xb8\x36\x11\xdb\x22\xb0\x0e\x6f\xb9\x8c\xe2\x8e\x67"
        "\xb7\x01\x50\x23\x25\x97\x75\xa2\x15\x6e\xa5\xcb\x3e\x10\x8a\xc9\xcb"
        "\xdb\x07\x52\x21\x22\xb0\xaa\xca\x63\x7a\xd5\x08\x49\xd9\xf3\x40\x04"
        "\x99\xbe\x62\x11\x1c\x22\x20\xcb\x90\x46\xee\x4a\x2e\x83\x32\xce\xee"
        "\x7b\x48\x9d\xc6\xf9\x37\x49\x58\x4e\x6b\x4c\x07\xae\x3b\xfb\x09\x00"
        "\xe7\x7d\x33\xf0\x65\x79\x13\xcc\xfb\x13\x1e\xcd\x9f\xdd\xac\x74\x7c"
        "\xa6\x59\x8f\x7e\xe9\x54\xc1\x57\x5e\x3c\x09\x09\x11\xcd\x1a\x46\xdf"
        "\x42\xa2\xe8\x1b\x4a\xd6\x86\x49\x81\xe5\xd6\xcb\xe3\x65\x44\x7d\x14"
        "\x07\xdc\x9b\x5e\x9a\x40\x4b\x5e\x2d\xbb\x82\x1f\x15\xdc\xbf\x42\xde"
        "\x8f\x7e\x1c\x9d\x40\x1f\x04\xc7\x83\x09\xa9\x04\x43\xb0\x61\x84\x0f"
        "\x8b\x0e\x91\xf5\x74\x6b\x14\xa2\x85\xae\x92\xac\x86\x21\x8e\x88\x00"
        "\x14\x6c\x4d\xf5\x91\xf5\xf5\xeb\x56\x4a\x8e\x70\x9a\x30\x62\x3f\x25"
        "\x1a\x33\x6f\x77\x96\x61\xf9\x53\x5d\x8f\x95\x7d\x16\x42\x71\xfa\xa1"
        "\x20\xe3\xad\x83\xa8\xf5\xd7\xd5\xf9\xa9\x0f\x87\xc8\xba\xf3\xa2\x6d"
        "\x2d\xae\x38\x8e\x31\x7f\x19\xab\x2e\x24\x39\xf9\x01\x9c\x11\xb4\xa8"
        "\x47\x04\x44\x96\x11\x7c\xf4\x24\x90\xcf\x03\x9e\x60\x73\xb1\x34\x84"
        "\xb0\x43\xcb\x49\x4e\x40\x0e\x52\xa9\x92\x1b\xc9\x26\x68\x91\x26\x0f"
        "\x3e\x62\x40\x1b\x30\x7f\x35\x58\xef\xf5\xd0\x04\xf5\xf4\x7e\xa9\x07"
        "\x74\xca\xef\xfd\x59\x98\x47\xde\xeb\xf3\x60\xdf\x84\x49\xc7\xc2\xa7"
        "\xb2\x42\xd1\xab\x6c\xcb\xa7\xc4\x18\xe6\x9e\x50\x87\x5e\x98\xc8\x37"
        "\x1f\xf4\x29\x0a\xbb\xfd\xa2\x5a\x87\x6c\xb1\xf9\x08\xa6\x46\xda\x9b"
        "\x5d\xb0\x05\xca\x6b\x55\x08\x2a\xf4\x82\xa4\x6a\x44\xf2\xe9\xec\xb8"
        "\x3b\x2c\x3b\x28\x74\x99\x7b\x26\xab\xdf\x8a\x62\x26\xc3\xaa\x9f\xec"
        "\x1e\x49\x08\x41\x7b\xa6\xaa\x1b\xca\x9c\xa4\x8b\x50\xd1\x3e\x2b\x3b"
        "\x04\x0f\x93\xc8\x5f\x3d\xc2\xfe\xf8\xeb\x6c\x0f\x19\xd8\x6a\x60\x05"
        "\xf5\xf4\x8f\xc5\xc5\x86\xf1\xc1\x17\xa1\xb2\xe1\xf9\x0e\x23\xa5\x0e"
        "\x8e\x35\xac\x81\x73\x77\x23\x40\xf9\x8f\x70\x26\x0d\xeb\x9e\x9d\x4b"
        "\xc4\xee\xfc\x39\x87\xab\x9f\xc8\xe7\x16\x60\x04\xa3\xf7\x53\x22\xfe"
        "\x38\x58\x4a\x0b\xf5\xfa\x78\xc7\xe4\xd6\xab\xb0\xb9\x8e\x4d\xc7\x83"
        "\x93\x19\xe2\xc1\xee\xca\x74\x65\x73\xa0\xe0\x9c\xa3\x41\x92\x3b\xae"
        "\x64\xf8\x2b\xe9\xb6\x0c\x20\x0f\x31\x2a\xd6\x48\x63\xdd\x4a\x0e\x97"
        "\xd9\xb4\x97\x9a\x02\xdc\x67\xd1\x15\xae\xe3\xb8\xff\xc2\x36\x34\x16"
        "\x0d\xcd\xb5\xc6\x52\xf7\x27\xee\xa4\xd7\xd3\xa4\xb7\x7f\xdc\xd4\xd7"
        "\xe8\x60\xe2\x13\xa4\xb2\x39\x29\x95\x35\x5d\x7c\xf5\x87\xbc\xfb\x33"
        "\xfd\xc1\xeb\x42\x37\xcd\xed\x66\x9a\xc1\xfc\x10\x24\xb9\x45\xf0\xa9"
        "\x9d\xcb\xe0\xd0\xff\x4c\x35\x0f\xdb\x88\x83\xbf\x4f\xca\x1d\x7b\x80"
        "\x6e\x31\xcf\x4c\xba\xca\x6d\x5c\xe7\x6a\xfb\x18\xb1\x09\xf7\x69\xff"
        "\x32\xd2\x53\x1a\x38\x10\x20\x47\x3b\x7f\x4c\x70\x45\x4c\x45\x0b\x0e"
        "\x68\xe6\xf6\x9e\xa3\x49\xa1\xc4\xff\x9e\x20\x8e\xfb\xe5\x26\xbb\xbc"
        "\x0f\x3e\x14\x99\x87\x69\xf0\xd8\x9f\xfd\x6b\x92\x06\x99\x6e\x04\x25"
        "\x73\x4e\x68\xe2\x34\xac\x45\x71\x3a\xf3\xf4\x6d\xf7\x97\x0b\x5a\xc6"
        "\x7e\x08\xc0\x8a\xd8\xe3\x53\x91\x9f\xc4\x15\x2f\x87\x52\x9e\xa2\x8e"
        "\x63\x4f\x8d\x0b\xbe\x7d\x81\x35\x0d\x14\xd5\x50\x68\xaf\xd3\xba\xe7"
        "\x22\x4a\x37\x7d\x1e\x5d\x77\x83\x2d\x2b\x93\x75\x0b\x80\x93\xb2\xbd"
        "\x3e\x83\xb6\x77\xc7\x78\x19\x8d\xa4\xa3\x19\x89\x3f\x38\xaa\xea\x08"
        "\xa2\x97\xe0\x65\xcb\x97\xce\xb7\x16\xd5\x25\xef\x28\xb1\xd3\x87\xb0"
        "\x1a\x78\x9b\xb1\x97\x48\xb9\xa6\x30\xc0\xb2\xd6\x5d\xcf\x2b\x3f\x9f"
        "\x8c\xce\xa0\xed\xe4\x91\x4d\x01\x01\x77\xed\x09\xd2\x32\x31\xad\xcb"
        "\x78\x06\x21\x12\x56\xe7\x75\x3d\x30\x15\xd1\x74\xc4\x9a\x2d\x5f\x7c"
        "\xcd\xbf\x36\xdb\xbc\xb4\x3a\x01\xe4\x88\xd7\xcb\xaa\xa4\xc0\x4b\x2c"
        "\xb3\x16\x6c\x19\x67\x70\xc6\xee\x02\xab\x75\xa5\x57\x29\xfe\xdb\x01"
        "\x25\x92\xf0\x70\xa0\x02\xea\x96\x82\x8d\xbc\x08\x6f\x93\x95\x66\xca"
        "\xc1\x7c\x83\x79\xdf\xd5\x93\x93\xc4\x79\x91\x0a\x56\x14\x49\x13\x9a"
        "\x7e\x67\x2b\x42\x10\x09\x15\x15\x3b\xb9\x28\x54\xe5\x0f\x3b\x42\x65"
        "\xa6\xb0\xc5\xe2\x91\x03\x28\x26\x0e\xc7\x61\xc8\x40\x3e\xb7\xd1\x28"
        "\x88\xb7\x03\x2d\x80\x25\xb9\x78\x37\x37\xc5\xa2\xb2\xfa\xc2\x78\xc0"
        "\x22\x15\xa9\xef\x4e\xe5\xa6\x4d\x18\x81\xcd\x8f\xcb\xa8\x9c\xd6\xc6"
        "\x1c\x87\x33\xb4\x0d\x7d\x4d\x98\x83\x89\xb0\xce\x6a\xb3\x8d\xc6\x16"
        "\x28\xde\x76\x38\xea\x48\xdf\xa8\xf8\xb8\xb4\xc2\x6e\xb2\xb8\x14\x35"
        "\x8e\xcc\x66\x02\x1a\xc3\xe8\xc8\x54\x6b\x57\xcf\x7a\x1a\x14\x5c\x11"
        "\xfb\x01\x82\xae\x63\x34\x88\x32\x66\x0f\x04\x1e\x7e\x33\xc8\x6f\xaf"
        "\x8e\x94\x59\xf8\x06\x7d\x79\xc7\xc5\x39\x7a\x33\x7e\x5d\x5e\x54\xfa"
        "\x27\x3d\xb9\x94\x40\x08\x6e\xc7\x91\xcf\x5d\xfe\x9a\x4b\xcc\x64\xc6"
        "\x4b\x2c\x96\x87\x03\x45\x95\xf1\xf9\x54\x9a\xeb\x41\x2b\x7c\x3d\xa3"
        "\xc5\xf0\xce\x05\xe9\x01\x98\x2f\xcc\x7e\xdd\x54\x08\xde\x7d\xef\x4d"
        "\x46\x41\x25\xaa\x7c\x9c\x51\xdd\x43\x76\xc4\x86\x2f\xa3\xd0\xa9\x01"
        "\x39\xd3\x26\x9d\x44\x3d\xb8\x2a\xcb\x4d\xb9\x0d\x7f\x0c\xc0\x98\xdd"
        "\xde\x8d\x63\x05\x1e\x84\xba\xe9\x59\xb9\xc2\xd3\x15\x3d\x48\x5c\xb9"
        "\xc2\xe8\x6b\x28\x50\xb2\x79\x4b\x13\xa1\x4e\x68\xf3\xb7\xf6\x5d\xb8"
        "\x4c\xb7\x90\xc0\x77\x6e\x86\x0a\x9d\xf8\xb4\x5b\x51\xa6\xfb\x7e\x7a"
        "\x32\x94\x17\x5f\xa3\x8e\x13\x4c\xe0\x53\xb7\x0b\x65\x0c\x1e\x88\xd0"
        "\x74\xbd\xc6\xde\xb5\x03\xe4\x09\x42\x54\xb3\x46\x10\xe4\xca\x0f\x32"
        "\x8a\x90\x72\x90\x5a\x49\xfe\x58\x57\x0f\xea\xcd\xc2\x9d\xfb\xb7\x0e"
        "\xd6\x3d\xce\x6e\x33\x59\xed\x93\xe5\xc9\x94\xbe\x36\x51\xaa\x2b\x6a"
        "\x5f\xca\xa3\x75\xd7\x0b\xd7\xdb\x8d\x1e\x74\x70\xd2\xad\xc7\x51\x9c"
        "\x9f\x7f\xa5\x05\xff\x86\x56\xef\x61\xc2\x70\x7c\x42\xc8\x82\xf6\x90"
        "\xbe\x40\x72\xbd\xa2\x57\xa1\x7f\xca\x72\x6a\xcb\x9d\x87\xf4\x52\x48"
        "\x93\xe2\x25\xf9\xbc\x1b\xac\x00\x19\x63\xdb\x09\x97\xce\xeb\x69\x13"
        "\x78\xa9\x72\xc6\xa9\x16\x58\xd7\x77\x65\x89\x45\x20\xe5\x82\x4a\x83"
        "\x24\xc2\xaf\xc4\xb3\x97\xba\xa0\x71\x8c\x07\x58\x2a\xc5\xe2\xf4\x04"
        "\x1c\xde\x7e\x73\xa9\x02\x8b\xd8\x68\x76\x68\xe6\xf7\x9f\xbf\xe2\xba"
        "\xe5\x15\xf9\x3b\x7f\xa1\x8c\x79\x8f\x17\xfd\x74\xa0\xa8\x3e\x81\x41"
        "\x4a\xf3\x7a\x56\x5e\xf7\x14\x16\xfa\xf6\x8c\x58\x9a\x4d\xad\xae\x7d"
        "\x6f\x2b\x8e\x65\x7d\x0c\x8d\x8d\x1c\x8a\x67\x8d\x4b\x1b\x5e\x5b\xb2"
        "\xa1\x37\x26\x9c\x3e\x22\x27\x3e\xe6\x41\x00\xca\x36\xb2\xee\xd2\x19"
        "\x6c\x86\xb9\x75\x49\x4f\x3a\x30\xae\x5d\x43\xe1\x0f\x67\x12\x15\xe5"
        "\xea\xf9\x82\x1a\x0a\x19\x33\x6b\x75\xdf\x2e\xb9\x31\xf8\xfc\x8e\x28"
        "\xd3\x5f\x54\x49\x6b\x72\x0b\x54\x9c\xd8\xbb\x7e\x08\x8d\x68\x43\xee"
        "\x07\x1e\x24\x36\x09\xeb\x54\x55\x6c\xa1\x23\x85\x4c\x29\xc9\x3e\xc8"
        "\x18\xec\x53\x0a\x27\x5b\xad\xd2\xa3\x20\x0b\xfa\x65\xe7\x17\x8c\xbd"
        "\x6d\x87\xf1\xb1\x3d\x39\xd3\x18\x19\x45\xf0\x9c\xf8\x8a\xb0\xf4\xd2"
        "\xc1\x59\xf7\xdd\x3d\xc4\x29\x08\xea\x24\x3a\x31\x9f\x58\x71\x72\x45"
        "\x76\x64\x8e\x8a\x3e\x70\xe7\x6c\x27\x66\x48\x30\xe8\x25\xba\xa8\x60"
        "\xc5\xe1\x7b\xa9\x82\x6c\xe9\x17\xb4\xa7\x2a\xf1\x31\x76\x44\x23\x54"
        "\x5b\x57\x51\x6a\x7f\x5d\xd9\xc6\x89\x2f\x79\xbe\xd4\xec\x4c\x85\x65"
        "\x46\x0d\x8a\x03\x30\x0b\x66\x34\xbb\x86\xe8\x19\x53\x2b\x48\x91\x57"
        "\x38\xa4\x11\xe5\x83\xae\x21\x0a\x0c\x30\xe5\x18\x75\x8b\xf9\xb7\xe8"
        "\x37\x5f\xdc\xbe\x74\xfa\xd5\x0b\xd7\xed\x6c\xf8\x9c\xdd\x61\xd3\xc2"
        "\x49\xb9\xba\x0b\x25\xbc\xf5\xaf\x61\xc7\x5b\x53\xa4\xc6\xe4\x35\xb2"
        "\xc2\x04\x1c\x87\xba\x17\xf8\xcf\xb8\x98\xc8\x0a\x52\x3c\xea\x64\x44"
        "\xb4\x39\x66\xf2\x1a\x1c\x77\x2f\x1c\x63\x30\x4e\x11\x77\xd7\x99\x4e"
        "\xb6\xbd\x64\xfd\xeb\x0d\xd5\x69\xd4\x7f\x07\x45\x1b\xe3\x8d\xb0\x5a"
        "\x22\xa3\x24\x4e\x67\xc4\x26\xb3\x78\x36\x77\x0c\x97\xbe\x5b\x02\xad"
        "\xac\x8d\x48\xad\x03\x2e\x45\x20\x91\xe5\x34\x74\x40\xf0\xf9\x90\x93"
        "\xa0\x81\x69\x38\xd8\x58\x54\x47\x0d\x62\xfe\xdb\xd2\x04\xba\x89\xb6"
        "\x36\x9f\xf6\xf0\x02\xdc\xb7\xfe\x78\x9e\x9f\x85\x2c\xf9\xfe\x76\x30"
        "\x4b\x81\xd3\xd2\x05\xf5\x44\x39\x24\x38\xcd\xc0\x10\xb6\x51\x8e\xaa"
        "\xd6\xa6\x62\x39\x31\xf1\x0b\x3a\xed\xb4\x33\x6d\xbb\x2f\xca\x01\xcc"
        "\x8f\x74\xbc\xe6\x9a\x28\x3d\xa9\x0a\x23\x1d\x57\x07\x25\xf4\x28\xdc"
        "\xb9\xb2\x74\x60\x72\x17\x2a\x20\x69\x5f\xd3\x94\x50\xfb\x19\xba\xfb"
        "\x5f\x33\x33\xdf\x89\xf3\xce\xac\x73\x51\x81\x15\x5d\x53\x92\x52\x84"
        "\xeb\x9c\xfc\xeb\xc5\xa1\x87\xa9\xfc\x3e\x7d\x78\xd7\x94\x9d\x05\x34"
        "\xae\xda\x24\xdb\x57\xed\x79\xbf\x91\x00\x83\x2d\xab\x57\xb0\xf2\x73"
        "\x04\xe3\x60\xf6\x22\x4f\x03\x6d\xd9\xc2\x57\x7f\x71\x45\x50\x28\x7c"
        "\xd9\xa1\x90\x31\x70\xaf\x01\x15\x94\xe4\x11\xde\x77\x66\x75\xa8\xe8"
        "\x49\x7c\xa5\x8e\x13\xc1\x6f\x22\x94\x9b\x8c\xcd\x26\x30\xbb\x5e\x0d"
        "\x47\x40\x11\xce\x68\x82\x02\x6e\xcf\xdb\x46\xea\x34\x26\x71\x12\x19"
        "\xf0\x42\x37\xf3\x14\xe9\x81\x76\x11\x12\x00\x49\x8f\x0e\x5d\xe4\x0e"
        "\x51\x37\xb9\x1e\x45\xf3\x1d\xc0\x00\x25\xe4\xf5\x7b\xc3\x4c\xc0\x7f"
        "\xb9\x3a\x1b\x65\x38\x6a\xbb\x91\x3c\xf0\x40\xe7\x16\x77\x17\x95\xce"
        "\xb6\xc8\xbf\x50\x79\xd9\x22\x8a\xfa\xfc\x34\x18\x48\x59\xbd\x2f\xd3"
        "\x06\x70\xcf\xa5\x4e\x45\xbd\xc7\x66\x8a\xb4\x84\x70\x26\x7b\x18\x81"
        "\x49\x7f\xec\x49\xb1\x33\xae\x75\x31\x21\xc7\xf6\x94\x70\x0b\x9a\xfa"
        "\x1c\xe1\xfa\xff\x11\xed\x6f\x13\xc7\x55\xf8\x22\x74\xd9\x54\x01\x0b"
        "\xb8\xe4\xca\x28\x87\xbd\xae\x89\xd3\xd3\x62\xe5\x70\xf3\x78\xfe\x50"
        "\x38\x67\x84\x17\x80\x7e\x11\x8f\x08\x80\xec\x90\x02\xd7\xed\xcb\xf7"
        "\x34\x32\x4b\x4c\x24\x79\x8f\xc6\x36\x23\x45\x54\xd7\xb6\x4a\x6f\x90"
        "\x49\x14\xa5\xe7\x10\x00\xd2\x27\x01\x6d\xb1\xc3\xee\x3c\x22\x28",
        4096));
    NONFAILING(memcpy(
        (void*)0x200020c0,
        "\x47\x4b\x41\xa0\x1e\x62\xe4\x4b\xa9\xe3\xf2\x8c\xd2\x5a\x75\xe0\xee"
        "\xfb\x15\x9d\x4d\x40\x34\xe3\x1d\xe6\xab\xdb\xc8\x96\xba\xa7\xda\xb2"
        "\x68\x1a\x61\xea\x6d\xd6\x02\xe1\x69\x76\x24\x84\xf0\x78\xd9\xf4\xb0"
        "\xb1\x61\x15\xfc\xda\xc3\x4e\xdc\x2c\xe3\x05\xcb\x41\xa1\xe1\xbb\x69"
        "\x4a\x1e\xfe\x4e\x9b\x77\xf9\xc8\x93\x2f\x22\x94\x03\x2f\x87\x13\xc6"
        "\x4d\x0e\xe1\x80\xe2\x1e\x53\x72\xe5\xc2\x93\x48\xc8\x69\x0a\xca\x46"
        "\xe6\x1a\xe5\xa0\x47\xc1\x86\xe5\x5a\x97\xb7\x80\xdf\xd3\x7a\x97\xb2"
        "\x09\xd3\xfd\x01\x74\x0d\xce\x27\x54\x85\x9b\x4f\xde\x0a\xaf\xeb\x2d"
        "\xf7\xdc\xb4\xa9\x27\x34\x01\xd2\x96\x83\xce\x06\xbd\xba\x1b\xe0\xdc"
        "\xda\xa4\x24\x55\x8a\xd9\xaa\xf3\x3b\x0e\xa7\x14\x4a\xca\x80\x45\x6f"
        "\x32\x65\x7f\x28\x40\x46\x33\x8c\x23\x74\xa3\x22\xb8\xb8\x9d\x28\x62"
        "\x02\x8c\xe5\x46\x62\xb0\x04\xc1\xe5\x8b\xc3\xf6\x43\x8c\xd9\x63\x0c"
        "\x2c\xd8\x8b\x86\x99\x80\x8e\x8d\x5d\x19\x1c\x0f\xea\x68\x00\x2d\xf0"
        "\x66\xfd\xb6\x1f\x04\x3d\x88\x06\xf6\x1c\xdc\x83\xab\xbf\xd0\xec\x79"
        "\x6b\x6f\x85\xf2\x3a\xa0\x7d\x87\xb2\xf0\x2a\x7d\x19\x84\xa1\x82\x54"
        "\x4f\x92\x9b\x43\x6d\x8d\x57\xcc\x6f\x7e\x52\x63\xf9\x09\xc2\x6c\xe2"
        "\x40\x52\x6f\x5f\xf7\x25\x87\xd8\x74\x86\x9d\xa5\x01\x33\xcd\x8c\x0b"
        "\x0f\x64\x74\x71\xe1\x90\x30\xfd\xd7\xe1\x0b\x0e\xfc\x76\x44\x9a\xa8"
        "\x5e\xdb\x6b\xe3\x00\xcb\x29\x94\x33\xed\x62\xc1\x81\xdc\x3e\x7a\x7b"
        "\x5a\xae\x9f\x92\x74\xb1\x57\xec\xe2\x61\x92\xe0\xef\x1c\xf8\xcf\x35"
        "\x28\xdb\x1e\x82\x7c\x46\xcf\xaa\xbb\x07\x34\x06\xf4\xf9\x52\xd6\x17"
        "\x34\x26\xd0\x38\xff\x53\x63\xa3\x9b\x62\x9b\x35\xd9\xfa\xda\xb9\xcc"
        "\x5b\x7b\xfe\xf7\x7f\xbe\x27\xfb\x8e\x43\xe0\x34\x26\x6d\xe7\x3b\x07"
        "\xd5\x9e\x6f\x8a\xce\x9b\x3e\x8a\x85\x62\xcc\xdb\x61\xad\x72\x32\xed"
        "\x9c\xc6\xb7\xfa\x93\x5c\x5b\x72\xe5\xaf\x74\x11\x3d\xb1\xce\x05\x62"
        "\x52\xec\xb6\x25\x9f\x1a\xe7\x07\xd8\x4a\x5f\xde\xcd\x69\x10\x73\x62"
        "\x2f\x33\x8a\x64\x1d\xbc\x09\x80\x4d\xa3\x2e\xdd\x3d\x1e\xf1\x07\xe4"
        "\xf3\x3f\x7d\x25\x2d\x78\x27\x1b\x56\xb4\x42\x8b\xb5\x93\x05\xb2\x86"
        "\x96\x26\xd4\xc0\x9f\xe1\xda\x4b\xbd\x30\x1f\x8d\xdf\x90\xb6\x46\xeb"
        "\xb7\xcc\x88\x6a\xa4\x75\x63\x04\x1f\x78\x65\x5c\x70\xf5\x70\x04\x9b"
        "\xee\x9d\x90\x4c\xe8\xce\x10\x88\x21\xad\x0c\x0c\x78\x19\x96\x8f\xf2"
        "\x67\x17\xe8\x93\x65\xe2\x66\xab\xce\x7b\x36\x37\x2d\x21\x91\x80\x1a"
        "\x6c\x13\x26\xd1\x45\x67\x19\xff\xd7\xc5\xbe\x04\x2a\x19\xb4\x4b\x9d"
        "\x9a\x18\xe4\x60\x01\xe4\x68\x1d\xc9\xce\x16\x3d\x59\x49\x9a\xbd\x2a"
        "\x6e\x94\xff\xb1\x37\xd8\x82\x73\x04\xc3\x36\x77\x67\x68\xec\x3e\x4c"
        "\xa3\x5b\x1b\x51\x55\x63\xed\x79\x14\x25\x05\x29\x27\x3b\x5e\x98\xed"
        "\x97\x0d\x27\xc7\x65\x6e\xd3\xa2\x04\x30\xe7\x22\x01\x09\x97\x9f\x16"
        "\x4b\x18\x44\xb7\xe3\xda\x1c\xf9\x5e\x42\x3c\x4e\x9d\xf3\x5c\xc4\x26"
        "\xa2\x5e\x5c\x67\x6e\xa4\x43\x18\x74\x67\x37\x91\xe5\x88\x83\xe3\x16"
        "\xca\x23\x7b\x9c\x6e\xd4\x67\x80\x2b\x67\x1d\x35\x26\x7f\xac\xc1\xcd"
        "\x65\x95\x8f\x4a\x29\xb6\xf0\x5f\xa2\x6c\xc3\x3b\x5f\x4b\x92\x4f\xe8"
        "\x80\xa6\x5f\x9c\xe8\x32\x63\xb0\x70\xe2\x15\xa6\xc4\xe8\x4f\xb1\xbb"
        "\x24\xb6\x18\xe4\xfb\xd5\x3d\xe8\x54\xc7\x3a\xe0\xe7\x11\x1b\xf2\x7c"
        "\xf1\xc2\x67\xd1\xab\xc9\xc8\x06\x25\x05\x9f\x70\x82\x91\x47\xaf\xda"
        "\xbb\x98\xf9\x6a\x44\x6e\xe7\x98\x06\xd9\x11\xfb\x68\x83\xb5\x0c\xd1"
        "\xc4\x61\xc0\xc3\x78\x4b\x89\xae\xcf\x9f\xbd\xd4\x8e\xd5\x74\x99\x45"
        "\xe1\x22\x29\xb4\xc1\x8c\xf0\xc9\x41\xbf\xd5\x6e\x0f\x05\xfe\xdc\xf1"
        "\xa2\x6c\xd8\xce\x1f\x28\xd8\xa9\x38\xa7\xde\x42\x63\x05\xad\x17\x19"
        "\x9b\xfa\xa1\x83\xea\x61\x76\x03\x68\xd8\xf3\xaf\x6a\x27\xd0\xd3\x50"
        "\xda\x23\x1f\xdb\x7c\xde\x68\x14\xdc\x99\xbb\x8f\xa9\xc8\xce\x8d\xf7"
        "\xcb\xec\x1c\xb1\xa1\x61\x55\x9b\xf8\xa6\x46\x8b\xc6\xf9\x04\x30\xac"
        "\xda\xfa\x28\x8b\xcf\xa8\xc6\xe6\x83\xd7\x92\xe8\x69\x7a\xaa\xbd\x90"
        "\x12\x1e\xe6\x9c\x4d\x02\x14\xd5\xd5\xd1\xbd\xf2\x32\x65\x7e\x08\x81"
        "\xa7\x7c\x15\x1b\x98\xef\xe8\x18\x6f\xa2\xdd\xe5\xad\x79\x5e\x40\xc5"
        "\xf2\xcc\xf2\x90\x55\xd0\x65\xc4\xf5\xb2\xe1\xb3\xeb\x93\x28\x15\x58"
        "\xc7\x21\x0f\x5d\xfd\x01\xb4\x57\x9d\x24\x36\x53\x5e\x01\x9e\x2e\x3d"
        "\x14\x35\x40\x4b\x51\x5d\xbc\xe5\x58\xf5\x42\xda\x6f\x86\x1c\xca\x4f"
        "\x3c\xe3\x49\xfa\xfe\x83\x67\x3c\xab\x4a\x9b\xe1\x02\x40\xe7\x46\x30"
        "\x79\x4c\xb2\xa6\x27\xdc\x09\x63\x56\x3b\x03\x41\xb6\x85\x80\xa6\xc1"
        "\x18\x30\x4c\xed\x33\x77\xa5\x29\xb3\x98\x38\x8d\x0c\x48\x49\x41\x43"
        "\x37\x17\x0b\xde\x1a\xb8\x7f\x24\x49\xd5\xde\x73\x4d\x54\x39\xda\xac"
        "\xec\xab\x69\x98\x0d\xd8\x2a\x57\x17\xdf\x13\x20\x04\xc2\x60\xd8\xb6"
        "\x01\xea\xa2\x77\x57\xef\x6a\x2d\xe7\x32\xc7\xba\x62\x4e\x82\x24\x09"
        "\x69\xca\x87\x2e\x82\x62\xb3\x8e\x3d\x3d\x5a\x65\xd9\x8a\xda\x6d\xb7"
        "\xfa\x76\x46\x5e\xb4\x09\xef\x56\x93\x1f\x1f\xde\x66\x37\xaf\x3a\x78"
        "\xc5\x3e\x28\x3e\x53\xe2\x3a\xd9\x09\x4c\x9e\x56\x7e\x47\x59\x1a\x75"
        "\xc5\xdb\x74\x3e\x5e\xad\x6e\xce\xb5\x8e\x35\x38\xf3\xdd\xe1\x97\x96"
        "\x8e\x41\xa5\xf6\x06\x05\xe0\xf4\x08\x14\x58\xac\x55\x7c\xa0\x7c\x02"
        "\xf8\x2b\x1e\xbe\x61\x0c\x07\x3e\xee\x89\x1d\x5a\x8d\x4a\x49\xde\x0a"
        "\x66\x10\x99\xde\xea\xaf\x2c\x42\x61\x0a\x5f\x07\x53\x42\x78\x0f\x77"
        "\x9d\x74\x40\xf7\x53\x8c\x48\xcc\x2c\xe2\xf1\x2e\x56\x47\xaf\x79\x6b"
        "\xbb\xb5\x9b\x24\x82\x03\x2a\xdc\x92\xfb\xbd\x23\xea\x6c\x29\x66\x93"
        "\xac\xe8\xd7\x45\x7c\x39\x80\xbd\xef\xf0\x94\x59\x26\x87\xca\xd3\xae"
        "\x2a\x58\xdd\xa8\x3c\x3b\xd2\x04\x2f\x07\x0f\xc2\x84\x60\x9c\x4f\xb4"
        "\xd4\xbc\x64\x27\x0e\x5f\x6e\xef\xec\xd9\x1f\x19\x0c\xd9\x00\x1c\x15"
        "\x95\x7f\xb0\x77\x54\x51\xad\xcb\xa9\x5f\x59\x05\xf3\xa2\xd8\x94\x6b"
        "\xf9\x28\x76\xae\x4a\xdd\xf4\xdf\x70\xdb\x24\xc7\xf3\xf3\xb3\xd6\xc2"
        "\xde\x4f\x5c\xd9\x7a\x22\x7e\xee\x40\x66\x90\xce\x45\xbb\xdb\x44\xd4"
        "\x8c\x3e\xd3\xf6\x3e\x92\xd0\x51\x3e\x03\x25\x44\xab\x25\xb6\x54\xcf"
        "\xd2\x32\xd0\xac\x34\x22\xd2\x36\x20\x84\xed\x35\x20\x71\x83\x45\xb2"
        "\x25\xe1\x0e\x4c\x37\xc5\x05\x58\xd9\x49\x2c\xf0\xa2\xc8\xf7\x73\xb3"
        "\xc3\x4f\xec\xf8\xde\x11\xb6\xc9\xaf\x7e\xe5\xe3\x38\xa0\x70\x0e\xdb"
        "\x02\xb6\xa5\xb5\xfd\x34\x1c\x7d\xd3\xb4\x6a\x27\xda\x5f\xb5\xb0\xb7"
        "\xbf\x67\xea\xdd\x9e\xe5\x48\x43\xfa\xb6\x2c\x71\x48\x4f\x1d\x23\x66"
        "\x64\x6e\x2f\x86\x96\x54\xbb\x71\x65\xbe\x5d\x6e\x35\xb1\x69\x25\x5b"
        "\xe8\xce\x24\x76\x78\xa6\x3e\xd6\x0a\x2f\x97\x57\xd2\x40\x5e\x2a\xb1"
        "\xd9\xf3\x10\x38\x9d\x99\x17\x0e\xc6\x30\x13\x9e\x08\x50\x6f\x3a\x48"
        "\x14\x82\x9c\x1e\xfc\x15\xeb\x94\x56\x3d\xb9\x4d\x36\x09\x53\xc5\xb4"
        "\x95\xc0\xbd\xad\x17\x39\x2c\xb3\x22\x6d\xf8\x16\x01\xa2\x9d\xe5\x6c"
        "\x9d\x12\x71\x4d\x4b\x1a\x20\x7f\x7d\x8e\x47\xd4\xb4\x50\x53\x2c\xa5"
        "\x85\x3a\x81\x5a\xda\xf0\x12\x59\x82\x14\xef\x77\xe1\x2d\xe9\x5d\x1a"
        "\x16\x4a\xd6\x4d\x9b\x8b\xa4\x0c\xcc\x47\x8d\x96\x1a\x28\xe2\x23\xe6"
        "\xc9\xb5\x0d\xcf\xa3\x8d\xb7\x64\x65\x8c\xa6\x73\x03\xd7\x3d\xad\xd5"
        "\x46\x46\x8b\x07\x24\x16\x04\x80\x2e\x28\xac\xc1\x48\x91\x6d\x82\x6c"
        "\xb0\x95\xa2\x29\x32\x42\xd3\x86\xd6\xbf\xaa\xe6\x5c\xdb\x71\xa3\x88"
        "\x47\x77\x5b\x83\x45\x6c\xb0\xde\x7f\x69\xc6\x30\x6c\x37\x7d\x61\x5f"
        "\x6a\xa5\x06\x57\x21\x16\x38\x53\xac\x13\x24\xd8\xdd\x4e\x31\x90\x81"
        "\x8c\xee\xa6\x04\xd7\xf1\x32\xbb\x8b\x0f\x57\x9c\xe5\x22\x43\xe7\x65"
        "\xcb\x6c\xe3\x8d\xe7\xc5\xee\x7f\xcc\x56\xd8\x74\x90\xa4\xe6\xe3\x32"
        "\x19\x73\xf5\x28\x1b\xf8\x4a\x21\xce\xd4\x24\xe3\x6c\xbf\x96\x7c\xd7"
        "\x70\x54\xc4\xc3\xa5\xb5\x33\x22\xa9\x15\xf9\xd6\x33\x74\xda\xa8\x78"
        "\x3d\x22\xa7\x2e\xc3\x16\xfc\xbc\x1d\x64\x4a\x0d\x1c\xae\xb4\x9c\x89"
        "\x5e\x47\xc1\xc5\xc6\xd2\xd2\x0a\xec\xa8\xc8\xa9\x2c\x49\xf6\x65\x41"
        "\x4e\xf4\x77\xa5\x32\x54\xc1\x41\x11\xf6\xb9\xbc\x45\x61\x28\x11\x27"
        "\xc0\x9c\xfe\xac\x37\x34\x93\xba\xfd\x6c\x4b\x03\x7c\x11\x3c\x7c\xd0"
        "\x1c\xca\x55\xd2\x58\xab\x21\x74\xc1\xf6\x9e\xbf\x72\x28\x90\x4a\x80"
        "\x31\xcd\x06\xae\x3c\xcb\x1f\x69\xa1\x32\x8d\x5a\x33\x97\xc9\x0e\xe0"
        "\x1d\x41\x26\x69\x49\x58\xae\x8f\x79\xf5\xae\x20\x43\x02\xff\x27\x9f"
        "\x1f\x49\x72\xfc\xbf\x38\xe6\xdd\xeb\x2f\x60\x55\x9e\x5b\xb5\xe6\xea"
        "\x10\x18\x4a\xbb\x0e\x33\xd8\x89\xe0\xcb\x77\x61\x95\x05\xf5\x94\x90"
        "\xcc\x1e\x84\x8e\x03\x51\x5b\xe0\x60\xd6\xdb\xbf\x7b\xdc\x8c\xe9\xf7"
        "\xd9\xf4\x42\x05\xe3\x9e\x72\xa3\x80\x57\xfe\x32\x29\x95\xae\x2b\xac"
        "\x3c\x5f\x84\x76\x33\x46\xde\x2c\x47\x5f\xe9\xe6\xb6\x2c\xaa\x0b\x0b"
        "\xa4\x0a\xdd\xe7\x6a\x68\xc0\x77\x77\x66\x54\x2b\x29\x24\xf5\x3a\x26"
        "\xf8\x9b\xbd\x22\x90\x0d\x09\x9a\xa4\x82\xaa\xa8\x46\xc2\x75\x93\x17"
        "\x55\xeb\xa9\x15\xad\x08\x2e\x6b\x93\x52\x19\xd6\x08\x4d\xcd\xe2\xb4"
        "\x9c\x76\xac\x9e\x0c\xd1\xa6\xd5\xeb\xa0\x89\xad\x9a\x83\x61\xd2\x86"
        "\x8a\xf4\xeb\x57\xac\xa9\xfa\x35\x5d\x8e\x72\x26\x0f\xd3\x53\x69\x9a"
        "\xbd\x7b\xc4\x95\x79\x31\xf9\xac\x69\xa1\x58\x80\x68\x93\x34\xd3\x03"
        "\x26\x97\x38\x71\x5c\x5e\xc5\x0a\x91\x2f\x1a\x1f\x21\xb4\x91\xae\xa8"
        "\x7c\x7c\x0e\x64\x6a\x94\xa3\xc9\x6b\x67\x91\xa6\xeb\x4a\x36\xb2\xf4"
        "\x76\x5a\xa1\x5f\x02\xf0\x02\xf4\xb4\x1f\x20\x4f\x98\x65\x38\xc9\xe7"
        "\x1a\x48\xdc\xcd\xde\x4f\x69\x27\xb9\x10\x6d\xd6\x6f\xb6\x33\xe7\x0a"
        "\xf5\x09\xd6\x7d\xa6\x02\xa6\xe4\x99\xcc\xbb\x62\xb6\x03\xc0\xad\x3e"
        "\xd8\x4c\xfc\x95\x6a\xb8\x4f\xe7\x7f\x89\x15\xcc\xf2\xb0\xcd\x03\x32"
        "\x04\x31\x98\xc8\x4a\x56\x08\x8c\xda\x33\xf8\x1c\xe7\xd0\x86\x50\x6f"
        "\x80\xde\x78\x07\xa3\xf2\xc9\x3d\x0d\x4a\x34\xf5\xd6\xc5\xb3\xda\x84"
        "\x82\x7e\x01\x0f\x4d\x70\x35\x8c\xcb\x63\x7a\xe4\xfb\xdf\xa3\x7d\xcf"
        "\x39\xf3\xc3\xe9\x02\xd9\xba\xe1\x04\x84\x0d\xbe\x2d\xfc\xb8\xb1\x30"
        "\x21\xa9\x8b\x0c\x0f\x17\x2a\x09\x08\xe5\xe8\xc1\xdc\xbe\xc6\x1f\x6d"
        "\x68\xcb\x22\x93\xe1\x3b\xf3\x66\x76\x16\x25\x32\xef\xbe\x1e\xf8\xd9"
        "\x84\x06\xca\x28\x7f\x74\x39\x9b\xa2\x10\xb3\x78\x41\xad\x54\x25\x04"
        "\xcb\xd5\xc9\x59\xb1\x30\xaa\x83\x23\x1d\x31\x0b\x39\x88\x29\x65\xaa"
        "\x78\xbc\xb0\x77\x66\x03\x46\xdf\x57\xa1\x76\xd8\xf1\x7b\xb7\xe0\x51"
        "\x60\xac\xfb\x90\xeb\x52\xa5\x8a\x51\x50\x85\x8b\x99\xdb\x89\x5d\xef"
        "\xfc\x70\xb9\x07\x46\x80\x42\x32\xc9\x27\xab\xf2\x90\x75\x79\x54\x54"
        "\x5d\xaf\x9f\xb7\x7a\x64\x6a\xd7\x3d\x46\x10\x0a\xe4\x0e\xf2\x65\x75"
        "\x0b\x73\x17\xbf\xc4\x4d\xfd\x1f\xa2\x69\xbc\xa9\xae\xe0\x27\xfe\x8f"
        "\xba\xec\x53\xc8\x75\xa7\xf9\x96\x71\xaf\x76\xae\x24\x64\x2d\xd9\x1a"
        "\x5e\xb7\x4a\xe7\x74\x5f\xbe\xeb\x46\xc1\xde\xe2\x23\x53\x02\x6c\xe4"
        "\x73\x6c\x06\xfa\x02\xb5\xbb\xcb\xf9\xbc\x05\xe5\xe8\xbd\x05\xa0\x5b"
        "\xdd\x26\xa6\x59\xbf\xe8\x15\x7a\xb5\x6b\x7e\x78\x4e\xb5\xd6\x34\x8c"
        "\x3a\x9f\x47\x1a\x39\x30\x4d\xfc\xd4\xd6\x58\x15\x13\x18\xec\x1c\x23"
        "\xdd\x31\x0e\x7a\x05\xfb\x91\x78\x8f\xcb\x8a\x1a\x04\x45\x52\xa0\x3d"
        "\x07\x1f\xd1\xaf\x19\x62\x2e\x58\x3d\xb9\x6b\xf8\xcf\x46\x47\x73\xc0"
        "\x64\xfa\x32\x6c\xd7\x86\x79\xc0\x0e\xfe\x7a\x79\x8d\xfb\x43\x55\x22"
        "\xbe\xc4\xac\x83\x6a\xbd\xfb\x6f\x43\x03\xff\x1d\x0c\xe4\x01\x24\xdc"
        "\x77\xf6\xaa\x4a\x7f\x7d\xa6\x63\x30\x51\x3c\x60\xb5\xa0\x31\xca\x58"
        "\x4a\xa9\x01\x10\xb8\x9a\x17\x61\xaf\xcd\x29\x3c\xb0\x44\x65\x10\xd0"
        "\x13\x39\x34\x27\xde\xbb\x2f\x6f\x03\x4d\xdb\x9d\xd0\x8d\x39\xd9\x71"
        "\x5e\x6a\x47\x9f\x13\x96\xfa\xec\x4d\xc6\xe4\x9d\xe1\x85\x85\x9e\x0a"
        "\xf8\x2b\xdb\x4c\x59\x60\x56\x4a\x7f\x97\x09\x5f\x8e\x06\x22\x17\x61"
        "\x26\x03\x85\x8a\x58\x04\x11\x04\x5a\x9e\x18\x97\x94\xd8\xfa\x49\x11"
        "\x1e\x05\xa8\x75\x4d\x37\x73\x0d\xf2\xf6\xd2\x56\x67\x29\xa5\xbc\x77"
        "\xc0\xb4\x98\xbd\x69\xcd\x27\x62\x2a\xa6\x83\x7a\xd5\xbb\x9d\x9e\x35"
        "\x79\x24\xc2\xdb\x16\x8e\x7f\xdf\xa0\xd8\x70\x86\x5e\xa0\x62\x66\xd7"
        "\x78\x16\x35\x72\x62\x94\x5c\xa6\x16\x30\x6e\xf9\x5c\x43\x5e\x65\xa3"
        "\x4b\xe0\x1a\x5a\x79\xdf\x38\xae\xe0\xee\x34\x65\x93\x97\x91\xa4\x13"
        "\xdc\xa4\xc7\x01\x2b\xa6\x06\xbc\xb3\x08\xbe\x62\x0b\x1c\xee\x6a\xc2"
        "\x25\x84\x16\xa7\x47\xc0\x5d\x47\x7c\x4f\x78\xc9\xf3\x50\x42\xe8\x0a"
        "\xf5\x57\x07\x51\x38\x2e\x2f\x21\x09\x0a\xbc\x9d\xfc\x01\xde\x10\xbd"
        "\x16\x6d\x86\x0d\xa0\xcf\xa3\x60\x90\x94\x4e\xe9\xfa\x6c\x74\x4a\xf8"
        "\x15\x88\x02\xb9\xcd\x9f\xb3\xd1\x34\xf6\xdd\x84\xa0\x8a\xe5\x11\x71"
        "\x4c\xad\x83\x75\xad\xfa\x61\xa2\x42\xd3\xce\x0b\x99\xa9\x64\x1b\xcd"
        "\x32\x04\x8a\x05\x95\xc6\x59\x45\x5e\x67\x7f\x59\x5e\x59\xcf\x71\x1f"
        "\xe8\x3d\x42\x3c\x0c\xc6\x7c\x0b\x2e\xca\x6c\x48\x06\x9c\xb0\xcd\xbb"
        "\xac\x52\xd0\xbd\xb6\x38\xc8\xe9\xab\x6c\xbf\xbd\x21\xe7\x4f\xad\x1e"
        "\x7e\x31\xc6\x7e\x5d\x0d\xd9\x97\xf8\xd3\xbc\x0d\x2a\x64\xcf\x7b\xc8"
        "\x92\xd0\x86\xa9\xa8\x8a\x0f\x4a\x8c\x84\x03\xc3\x10\x51\x88\x71\xb0"
        "\x15\x65\xe5\x00\x16\xc4\x0f\x64\x89\xa9\xd6\x24\xb6\x13\x25\x36\xa8"
        "\xca\x66\x3f\xea\x0e\xef\x59\xc1\x3d\xb3\x03\x72\x77\x46\x74\xa4\xe4"
        "\xb5\xbb\x56\x8c\x02\xc1\x80\x10\x55\x19\x2c\xc5\xe4\x0e\x3f\x1a\xe1"
        "\x3b\xe3\xed\x72\xb8\x72\x9e\x40\xb5\x09\x95\xe4\x05\xcf\x5b\x1d\x2a"
        "\xf0\x49\xff\xbc\xc3\x35\x89\xe6\x8f\x07\xec\xc4\x20\x7f\xea\x59\x19"
        "\xba\xd6\x3b\x39\xb1\xa1\x55\x2a\x21\xe0\xe1\xd9\xc1\xc2\x66\xd5\xde"
        "\x22\xe4\x6f\x5d\x68\x26\xa2\x80\x9b\x7e\xbc\x5c\x3c\x5f\x56\x3c\xea"
        "\xbf\xb0\x22\x01\x0d\x3e\x14\x18\xde\x0f\xaa\x18\x7b\x22\xa7\x38\xd0"
        "\xa6\x2c\xe7\x3b\x78\x1e\x48\xf1\x15\x67\xc9\xdb\x24\x99\xb4\x8e\x84"
        "\x29\x62\x85\xd6\x90\x25\xb4\xc6\xea\x21\x13\x00\x62\xd1\x98\x60\x16"
        "\x6c\xdd\x26\x12\x41\x38\x15\x66\xe7\x95\x73\x0b\x13\xb9\x7a\x13\x34"
        "\x30\x60\x5c\xc8\xbf\x00\xbe\x29\x8c\xa5\xdb\x3f\xbd\x58\x8c\x3c\x48"
        "\xa6\x61\xfd\x50\x3b\x86\x40\x09\x06\x71\x20\x8f\x07\xcb\x48\x33\x37"
        "\x78\xa7\xc1\x14\xc0\xb5\x55\xd4\xcd\xac\x90\x9b\x35\x17\x91\x9a\x2d"
        "\x9b\x25\x95\xf7\xd0\x99\x6d\x8e\x38\x2a\x9e\x14\x58\xd4\x65\xe0\x34"
        "\x63\xa9\x31\x36\x76\xd1\xc6\xbf\x8f\xf2\x94\xd4\xd6\x49\x85\xaf\x4f"
        "\x6b\x44\xd4\xe8\x4d\xf2\x61\xe0\xf2\xc2\x83\x48\x83\x21\x5a\xc5\x49"
        "\x3e\xc4\x52\x8c\xb0\xf2\x8c\x3a\x46\xc3\x52\x0e\x6b\xa2\x22\xc1\xfd"
        "\x44\x0b\x06\xd6\x23\x0c\x21\x0f\x16\x78\x30\x8d\xeb\xe7\x93\xca\x73"
        "\xe5\x4d\xe8\x47\x10\xd0\x0a\x33\x18\xaf\x53\xa7\x03\x0a\x78\xd1\x6b"
        "\x61\x64\x57\xf2\xb2\x96\x8c\xf0\x10\x35\xc4\x64\x85\xd4\x18\xa8\xc3"
        "\xe7\xe2\x38\x65\xe0\x34\x1c\x2a\xe6\xbe\x7e\x17\x52\xe6\x85\x42\xec"
        "\x6d\xa2\xc4\x10\x35\xd9\xac\x01\x21\xfd\xe5\x93\xd5\x53\x95\xc8\x9f"
        "\x7e\x1c\x57\x39\x32\x7c\x37\x71\x5c\x3d\x75\x4d\x64\x5b\x3c\x02\xb2"
        "\xaf\xde\xdb\xc8\x29\xad\x84\xdb\x88\xa7\x0b\xdd\xb8\xc8\x61\xb5\xb9"
        "\x2b\x2f\x1f\x38\xde\x4f\x88\xbf\xe3\xd8\x8b\xd6\x26\xe6\xe8\x40\xa7"
        "\xd6\xca\x25\xa3\x62\xba\x01\x08\xb6\x29\x7d\x7d\x01\x6a\xc1\xcc\x4c"
        "\x63\x5f\x82\x66\xd2\x7c\x9e\xbb\x2a\x6a\xb6\x99\x56\x2a\xde\x99\xdc"
        "\x18\x4a\xc2\x8d\xe5\x8a\x70\x3a\x75\x7a\xbc\x19\xa4\x8f\xcd\x02\x00"
        "\xd7\x2c\x79\xf5\x0b\x9d\x3a\xf5\x5f\xb3\xbd\x01\xe7\xe3\x9a\x07\x48"
        "\x28\xfd\xc7\xd8\xca\x9e\xa5\x06\x37\x9c\x45\x6b\x46\x5d\x5f\x6b\x75"
        "\xfb\xbc\xef\x8f\x9e\xf6\x2a\x24\x19\x5f\x63\xb4\xbc\x14\x8c\xc2\xbc"
        "\x16\xe7\x4f\x02\xb3\xb9\x3a\x68\x7d\xa2\x8f\x3e\xf5\xd5\xf1\x18\x7b"
        "\x82\x06\xae\xfd\xf9\x6f\xaf\xad\x21\x96\x70\x70\x8c\x9d\x68\xa1\x1f"
        "\x0a\x1d\xa3\xfe\xaa\xdf\x1a\x4c\x73\xe6\xf3\xf9\x20\xbc\x6e\x3c\x72"
        "\xfd\xf5\x98\x75\xcb\x14\x93\x1a\x85\xa0\x21\x03\xbc\x68\xef\x78\xe7"
        "\x30\x70\xc9\xe1\x9c\x89\xba\x43\x04\x35\x6b\x6c\x2e\xeb\x14\x02\xb6"
        "\xb3\x40\xa3\x75\x19\xe4\xa7\x93\x70\x5b\x62\x63\xcc\x0e\x3d\x11\x45"
        "\xae\xed\xb2\x1a\x29\x61\x9e\x91\x10\x60\x18\xc7\xcf\xb9\x41\x08\x80"
        "\x12\x1d\x5c\x0c\x42\xc7\x60\x3d\x40\xb8\x5b\x9f\x3e\xae\x5a\xf9\xc5"
        "\xe7\x38\xc5\x6a\xcf\x16\x71\xa5\x5a\x73\x01\x25\x98\x8e\x03\x9b\x66"
        "\x5b\x81\x5a\x40\x18\xc0\x28\x49\x82\x4a\xae\x6a\xf9\x0b\x56\x45\xa8"
        "\xcd\x79\x4b\xc1\x22\x1e\x17\x3e\x68\x0d\x66\x67\x3d\xb2\x8d\xc3\xd9"
        "\x8a\x78\x78\x60\x75\x7d\x95\x19\xdd\xd1\xa3\x86\x3f\x82\x12\x1a\x12"
        "\xfb\x60\x3c\xd7\xf5\xaf\x66\x94\xd4\x29\x08\x41\x42\x07\x15\xa4\x93"
        "\x25\x8c\xf3\x63\x17\x1e\x9e\x9c\xc7\xf8\x14\xd4\x6e\xc5\x0a\xad\x49"
        "\x80\x3d\x63\xae\x6d\x3e\xaa\xb8\xc0\xb2\xb0\x79\x9b\xa7\xba\x27\x2b"
        "\x76\xb9\xe6\x7b\x35\x79\x35\xe8\x7c\xa5\x9b\xab\x5b\x1d\x11\xdd\xfd"
        "\x43\x56\xf1\x55\x74\xd3\x49\x42\x33\xc5\xd5\xc7\xb7\x9d\x96\x06\xd9"
        "\x31\xd7\xdb\x7c\xaa\x8a\x0a\xe5\xc5\xb3\x31\x9e\x0c\xb1\x32\x5f\x71"
        "\xb9\x78\xac\xdb\x29\x48\xf4\x72\x20\xd9\xc6\x28\x5d\xc9\xee\xa5\xb3"
        "\x44\xc4\xb5\x27\x67\x60\xe8\x6a\x63\x0a\x50\x71\x6e\x00\x3d\xd8\xc5"
        "\xd9\x92\x51\xbb\xa3\x20\xd2\x3e\x64\x5f\xfa\xb5\xaa\xf2\x3e\xa1\xb2"
        "\xa8\x3f\x7b\xea\x39\x6b\xf2\x12\x35\x93\x1d\x60\xa7\xd8\x14\x14\x35"
        "\x51\xd0\xfd\xc8\x92\x5a\xef\x8a\x78\xa3\x2b\x8b\xac\x1d\xa2\x89\x19"
        "\x51\x1c\x50\x75\xbc\x96\x6f\x63\x47\xb8\x89\xc7\x00\xa2\x05\x4d\xab"
        "\x5c\x74\x29\xd6\xa0\x94\x7a\xf7\x79\x73\x1b\xc4\x0c\x7a\xc6\x69\x7c"
        "\x9b\x77\xab\x41\xff\x96\xd7\x7b\x30\x08\x8c\x9b\xd7\x9b\xd0\x66\x7a"
        "\x81\x7a\x7a\x6c\xbe\x07\xb2\xec\x92\xfd\xd6\x05\xe6\x59\x09\xc6\xf5"
        "\x56\xc2\xe9\xd4\x9e\xea\xca\xf9\x74\x1a\xd3\x55\x36\x1e\x5e\xdb\x44"
        "\xbf\x80\x3b\xc4\x7f\x00\x8c\x1e\x5d\x35\xdf\xc2\x6c\x71\x26\x4d\x82"
        "\xe2\xae\x4c\xd7\x3c\xa3\xf5\xc4\x83\xaf\x38\xbb\xaa\x38\xea\xad\x0f"
        "\x03\x81\x46\x19\xd8\xea\xbc\xac\x22\x81\x7f\xfc\xdd\xfb\x29\x20\xf9"
        "\xa8\x15\x74\x10\xe6\xec\x12\x8b\x13\x5b\x3f\x78\xc3\xa5\xdf\x9f\xc2"
        "\x88\xb3\x90\x66\xd0\x31\xec\xed\xd2\x01\xc8\xd6\x9f\xe4\x16\x8c\x11"
        "\x77\x6b\xcd\x3b\x2f\x68\x8c\xf2\xc8\x5f\xba\x79\xc7\x09\x79\x0a\x2a"
        "\x10\x5e\x7e\xe3\x77\x6e\xb4\x3b\xd0\x80\x45\x3c\x23\x19\xb9\x7e\x43"
        "\xa9\x6e\xe8\xce\x86\xca\x15\xa5\x7e\xf0\xcd\x0d\x87\x56\x50\x3f\x8b"
        "\x7f\x14\xfa\xce\x5d\x33\x5e\xc7\x13\x56\x77\x76\x37\xb1\xa0\x3b\x9a"
        "\x22\x58\xec\x9c\x81\xaa\xdc\x7f\xb0\x9e\x34\x3c\x6b\xc5\x7c\x13\xbe"
        "\x15\x6b\x1c\x71\xaf\x86\x54\x0f\x46\xe7\xe0\x9e\x89\xa2\xb5\x18\x54"
        "\x2d\xe5\x36\xd5\x16\xdd\x99\x2b\xcc\x37\x31\x70\xf7\x71\x6b\xe7",
        4096));
    syscall(__NR_ioctl, r[2], 0x4080aebf, 0x20001040);
    break;
  }
}
int main(void)
{
  syscall(__NR_mmap, 0x20000000, 0x1000000, 3, 0x32, -1, 0);
  install_segv_handler();
  use_temporary_dir();
  do_sandbox_none();
  return 0;
}
